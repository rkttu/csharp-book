# 29장. 성능과 메모리 최적화

C# 프로그램의 성능과 메모리 사용을 최적화하는 것은 실무에서 매우 중요합니다. 이 장에서는 .NET의 고성능 타입과 메모리 효율적인 프로그래밍 기법을 학습합니다.

## 이 장에서 배울 내용

- **Span<T>과 Memory<T>**: 힙 할당 없이 메모리를 효율적으로 다루는 방법
- **ValueTask**: 비동기 작업의 메모리 할당을 줄이는 기법
- **구조체 최적화**: 값 타입을 효율적으로 사용하는 방법
- **string vs StringBuilder**: 문자열 처리의 성능 차이 이해
- **컬렉션 선택 가이드**: 상황에 맞는 최적의 컬렉션 선택

---

## 29.1 Span<T>과 Memory<T>

Span<T>과 Memory<T>는 .NET Core 2.1에서 도입된 고성능 타입으로, 배열이나 문자열의 일부를 힙 할당 없이 참조할 수 있게 합니다.

**Span<T>의 기본 개념:**

Span<T>는 연속된 메모리 영역을 나타내는 ref struct입니다. 배열, stackalloc, 또는 네이티브 메모리를 안전하게 참조할 수 있습니다.

```csharp
// 배열에서 Span 생성
int[] numbers = { 1, 2, 3, 4, 5 };
Span<int> span = numbers;

// 부분 범위 참조 (힙 할당 없음)
Span<int> slice = span.Slice(1, 3);  // { 2, 3, 4 }

// 값 수정 (원본 배열도 변경됨)
slice[0] = 20;
Console.WriteLine(numbers[1]);  // 20
```

**문자열 처리에서의 Span<T>:**

```csharp
string text = "Hello, World!";
ReadOnlySpan<char> span = text.AsSpan();

// 부분 문자열 추출 (새 string 생성 안 함)
ReadOnlySpan<char> hello = span.Slice(0, 5);  // "Hello"

// 문자열 비교 (할당 없음)
bool isMatch = span.StartsWith("Hello");
```

**stackalloc과 Span<T>:**

```csharp
// 스택에 메모리 할당 (힙 할당 없음)
Span<int> numbers = stackalloc int[100];

// 초기화
for (int i = 0; i < numbers.Length; i++)
{
    numbers[i] = i;
}

// 연산 수행
int sum = 0;
foreach (int n in numbers)
{
    sum += n;
}
```

**Memory<T>와 차이점:**

Memory<T>는 Span<T>와 유사하지만, async 메서드에서 사용할 수 있습니다.

```csharp
// Span<T>는 ref struct이므로 async에서 사용 불가
// Memory<T>는 일반 struct이므로 async 가능

public async Task ProcessDataAsync(Memory<byte> buffer)
{
    // 비동기 작업에서 Memory<T> 사용
    await ReadDataAsync(buffer);
    
    // Span<T>로 변환하여 처리
    Span<byte> span = buffer.Span;
    ProcessBuffer(span);
}
```

**실전 예제 - 파일 읽기 최적화:**

```csharp
public async Task<int> CountLinesAsync(string filePath)
{
    const int BufferSize = 4096;
    using var file = File.OpenRead(filePath);
    
    var buffer = new Memory<byte>(new byte[BufferSize]);
    int lineCount = 0;
    
    while (true)
    {
        int bytesRead = await file.ReadAsync(buffer);
        if (bytesRead == 0) break;
        
        // Span으로 변환하여 처리
        ReadOnlySpan<byte> span = buffer.Span.Slice(0, bytesRead);
        
        // 개행 문자 카운트
        foreach (byte b in span)
        {
            if (b == '\n') lineCount++;
        }
    }
    
    return lineCount;
}
```

---

## 29.2 ValueTask

ValueTask는 Task의 성능 최적화 버전으로, 결과가 이미 완료된 경우 힙 할당을 피할 수 있습니다.

**Task vs ValueTask:**

```csharp
// 일반 Task - 항상 힙에 할당
public async Task<int> GetValueWithTaskAsync()
{
    return 42;  // 이미 값이 있어도 Task 객체 생성
}

// ValueTask - 동기적 완료 시 할당 없음
public async ValueTask<int> GetValueWithValueTaskAsync()
{
    return 42;  // ValueTask는 값만 포장, 힙 할당 없음
}
```

**캐싱 시나리오에서의 활용:**

```csharp
public class UserCache
{
    private readonly Dictionary<int, User> _cache = new();
    
    // 캐시 히트 시 할당 없음
    public ValueTask<User?> GetUserAsync(int userId)
    {
        // 캐시에 있으면 동기적으로 반환
        if (_cache.TryGetValue(userId, out var user))
        {
            return new ValueTask<User?>(user);  // 할당 없음
        }
        
        // 캐시에 없으면 비동기 로드
        return LoadUserAsync(userId);
    }
    
    private async ValueTask<User?> LoadUserAsync(int userId)
    {
        // 데이터베이스에서 로드
        var user = await _database.FindAsync(userId);
        _cache[userId] = user;
        return user;
    }
}
```

**사용 시 주의사항:**

```csharp
// ❌ 잘못된 사용 - 여러 번 await
public async Task BadExampleAsync()
{
    var valueTask = GetDataAsync();
    await valueTask;  // 첫 번째 await
    await valueTask;  // ⚠️ 오류! ValueTask는 한 번만 await 가능
}

// ✅ 올바른 사용 - 한 번만 await
public async Task GoodExampleAsync()
{
    var result = await GetDataAsync();
    // result를 여러 번 사용 가능
}

// ✅ 여러 번 사용해야 하면 Task로 변환
public async Task MultipleAwaitAsync()
{
    var valueTask = GetDataAsync();
    var task = valueTask.AsTask();  // Task로 변환
    
    await task;
    await task;  // OK
}
```

**성능 비교:**

```csharp
// 벤치마크 예제
public class CachePerformance
{
    private readonly Dictionary<string, string> _cache = new();
    
    // Task 버전
    public async Task<string> GetWithTaskAsync(string key)
    {
        if (_cache.TryGetValue(key, out var value))
        {
            return await Task.FromResult(value);  // 힙 할당 발생
        }
        return await LoadAsync(key);
    }
    
    // ValueTask 버전
    public async ValueTask<string> GetWithValueTaskAsync(string key)
    {
        if (_cache.TryGetValue(key, out var value))
        {
            return value;  // 할당 없음
        }
        return await LoadAsync(key);
    }
    
    private async Task<string> LoadAsync(string key)
    {
        await Task.Delay(10);
        return $"Value for {key}";
    }
}

// 결과: ValueTask가 캐시 히트 시 약 10배 빠름
```

---

## 29.3 구조체 최적화

구조체(struct)는 값 타입으로, 적절히 사용하면 힙 할당을 줄이고 성능을 향상시킬 수 있습니다.

**struct vs class 선택 기준:**

```csharp
// ✅ struct가 적합한 경우
public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    
    // 작은 크기 (16바이트 이하 권장)
    // 불변성(immutability) 지향
    // 논리적으로 단일 값을 표현
}

// ❌ class가 적합한 경우
public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public Address Address { get; set; }
    
    // 큰 크기의 데이터
    // 참조 의미가 중요한 경우
    // 상속이 필요한 경우
}
```

**readonly struct로 복사 최적화:**

```csharp
// 일반 struct - 메서드 호출 시 복사 발생
public struct MutablePoint
{
    public int X { get; set; }
    public int Y { get; set; }
    
    public double Distance()
    {
        return Math.Sqrt(X * X + Y * Y);  // 방어적 복사 발생
    }
}

// readonly struct - 복사 방지
public readonly struct ImmutablePoint
{
    public int X { get; }
    public int Y { get; }
    
    public ImmutablePoint(int x, int y)
    {
        X = x;
        Y = y;
    }
    
    public double Distance()
    {
        return Math.Sqrt(X * X + Y * Y);  // 복사 없음
    }
}
```

**in 매개변수로 복사 방지:**

```csharp
public readonly struct Vector3
{
    public float X { get; }
    public float Y { get; }
    public float Z { get; }
    
    public Vector3(float x, float y, float z)
    {
        X = x;
        Y = y;
        Z = z;
    }
}

// ❌ 값 복사 발생
public float DotProduct(Vector3 a, Vector3 b)
{
    return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
}

// ✅ 참조로 전달 (복사 없음)
public float DotProductOptimized(in Vector3 a, in Vector3 b)
{
    return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
}
```

**ref struct로 스택 전용 타입:**

```csharp
// ref struct는 스택에만 존재 (힙 할당 불가)
public ref struct StackOnlyBuffer
{
    private Span<byte> _buffer;
    
    public StackOnlyBuffer(Span<byte> buffer)
    {
        _buffer = buffer;
    }
    
    public void Process()
    {
        // 스택 메모리 처리
        for (int i = 0; i < _buffer.Length; i++)
        {
            _buffer[i] = (byte)(i % 256);
        }
    }
}

// 사용 예
public void UseStackBuffer()
{
    Span<byte> buffer = stackalloc byte[1024];
    var processor = new StackOnlyBuffer(buffer);
    processor.Process();
    
    // buffer는 메서드 종료 시 자동 정리
}
```

---

## 29.4 string vs StringBuilder 성능

문자열은 불변(immutable)이므로 반복적인 연결 작업은 성능 문제를 일으킬 수 있습니다.

**string 연결의 문제점:**

```csharp
// ❌ 비효율적 - 매번 새 string 생성
public string BuildMessageBad(List<string> items)
{
    string result = "";
    
    foreach (var item in items)
    {
        result += item + ", ";  // 매번 새 객체 생성
    }
    
    return result;
}

// 100개 항목: 100번의 string 객체 생성
// 1000개 항목: 1000번의 string 객체 생성
```

**StringBuilder 사용:**

```csharp
// ✅ 효율적 - 내부 버퍼 사용
public string BuildMessageGood(List<string> items)
{
    var sb = new StringBuilder();
    
    foreach (var item in items)
    {
        sb.Append(item);
        sb.Append(", ");
    }
    
    return sb.ToString();
}

// 초기 용량 지정으로 더 최적화
public string BuildMessageBetter(List<string> items)
{
    var estimatedLength = items.Count * 20;  // 예상 크기
    var sb = new StringBuilder(estimatedLength);
    
    foreach (var item in items)
    {
        sb.Append(item);
        sb.Append(", ");
    }
    
    return sb.ToString();
}
```

**선택 기준:**

```csharp
public class StringConcatenationGuide
{
    // ✅ 소수의 문자열 연결 - string 사용
    public string FormatName(string first, string last)
    {
        return $"{first} {last}";  // 간단하고 읽기 쉬움
    }
    
    // ✅ 반복문에서 연결 - StringBuilder 사용
    public string BuildCsv(List<string> values)
    {
        var sb = new StringBuilder();
        for (int i = 0; i < values.Count; i++)
        {
            if (i > 0) sb.Append(',');
            sb.Append(values[i]);
        }
        return sb.ToString();
    }
    
    // ✅ 고정된 개수 - string.Join 사용
    public string JoinWords(params string[] words)
    {
        return string.Join(" ", words);  // 내부적으로 최적화됨
    }
}
```

**성능 비교 예제:**

```csharp
public class PerformanceComparison
{
    public void ComparePerformance()
    {
        const int iterations = 10000;
        
        // string 연결 - 매우 느림
        var sw1 = Stopwatch.StartNew();
        string result1 = "";
        for (int i = 0; i < iterations; i++)
        {
            result1 += i.ToString();
        }
        sw1.Stop();
        Console.WriteLine($"String concat: {sw1.ElapsedMilliseconds}ms");
        
        // StringBuilder - 빠름
        var sw2 = Stopwatch.StartNew();
        var sb = new StringBuilder();
        for (int i = 0; i < iterations; i++)
        {
            sb.Append(i);
        }
        string result2 = sb.ToString();
        sw2.Stop();
        Console.WriteLine($"StringBuilder: {sw2.ElapsedMilliseconds}ms");
        
        // 결과: StringBuilder가 100배 이상 빠름
    }
}
```

---

## 29.5 컬렉션 선택 가이드

적절한 컬렉션을 선택하면 성능과 메모리 효율을 크게 개선할 수 있습니다.

**List<T> vs Array:**

```csharp
// Array - 크기 고정, 약간 더 빠름
public void UseArray()
{
    int[] numbers = new int[100];
    numbers[0] = 1;  // 직접 접근
    
    // 크기 변경 불가
    // 메모리 오버헤드 최소
}

// List<T> - 동적 크기, 편리한 메서드
public void UseList()
{
    var numbers = new List<int>();
    numbers.Add(1);  // 동적 추가
    numbers.Remove(1);  // 제거
    
    // 크기 자동 조정
    // 약간의 메모리 오버헤드
}
```

**Dictionary<TKey, TValue> vs List<T> 검색:**

```csharp
public class SearchPerformance
{
    // ❌ List - O(n) 검색
    public bool FindInList(List<int> list, int target)
    {
        return list.Contains(target);  // 전체 순회
    }
    
    // ✅ HashSet - O(1) 검색
    public bool FindInHashSet(HashSet<int> set, int target)
    {
        return set.Contains(target);  // 즉시 찾기
    }
    
    // ✅ Dictionary - 키-값 쌍 저장 및 O(1) 검색
    public string? FindInDictionary(Dictionary<int, string> dict, int key)
    {
        return dict.TryGetValue(key, out var value) ? value : null;
    }
}
```

**Stack<T> vs Queue<T>:**

```csharp
// Stack - LIFO (후입선출)
public void UseStack()
{
    var stack = new Stack<string>();
    stack.Push("first");
    stack.Push("second");
    
    var last = stack.Pop();  // "second"
    var first = stack.Pop();  // "first"
}

// Queue - FIFO (선입선출)
public void UseQueue()
{
    var queue = new Queue<string>();
    queue.Enqueue("first");
    queue.Enqueue("second");
    
    var first = queue.Dequeue();  // "first"
    var second = queue.Dequeue();  // "second"
}
```

**컬렉션 선택 체크리스트:**

```csharp
public class CollectionSelector
{
    // 1. 순서가 중요하고 인덱스 접근이 필요한가?
    // → List<T> 또는 Array
    
    // 2. 빠른 검색이 필요한가?
    // → HashSet<T> (값만) 또는 Dictionary<TKey, TValue> (키-값)
    
    // 3. 중복을 허용하지 않는가?
    // → HashSet<T>
    
    // 4. 정렬된 상태를 유지해야 하는가?
    // → SortedSet<T> 또는 SortedDictionary<TKey, TValue>
    
    // 5. LIFO 동작이 필요한가?
    // → Stack<T>
    
    // 6. FIFO 동작이 필요한가?
    // → Queue<T>
    
    // 7. 동시성이 필요한가?
    // → ConcurrentDictionary<TKey, TValue>, ConcurrentQueue<T> 등
}
```

**실전 예제 - 캐시 구현:**

```csharp
public class DataCache<TKey, TValue> where TKey : notnull
{
    // Dictionary - 빠른 조회를 위해
    private readonly Dictionary<TKey, CacheEntry<TValue>> _cache = new();
    
    // Queue - FIFO 제거를 위해
    private readonly Queue<TKey> _accessOrder = new();
    
    private readonly int _maxSize;
    
    public DataCache(int maxSize)
    {
        _maxSize = maxSize;
    }
    
    public void Add(TKey key, TValue value)
    {
        if (_cache.ContainsKey(key))
        {
            _cache[key] = new CacheEntry<TValue>(value, DateTime.Now);
            return;
        }
        
        // 크기 제한 확인
        if (_cache.Count >= _maxSize)
        {
            // 가장 오래된 항목 제거
            var oldestKey = _accessOrder.Dequeue();
            _cache.Remove(oldestKey);
        }
        
        _cache[key] = new CacheEntry<TValue>(value, DateTime.Now);
        _accessOrder.Enqueue(key);
    }
    
    public bool TryGet(TKey key, out TValue? value)
    {
        if (_cache.TryGetValue(key, out var entry))
        {
            value = entry.Value;
            return true;
        }
        
        value = default;
        return false;
    }
    
    private record CacheEntry<T>(T Value, DateTime AddedAt);
}
```

---

## 마치며

이 장에서는 C#의 성능과 메모리 최적화 기법을 학습했습니다:

1. **Span<T>과 Memory<T>**: 힙 할당을 줄이는 고성능 메모리 타입
2. **ValueTask**: 비동기 작업의 메모리 효율성 향상
3. **구조체 최적화**: readonly struct와 in 매개변수 활용
4. **string vs StringBuilder**: 문자열 처리 성능 개선
5. **컬렉션 선택**: 용도에 맞는 최적의 컬렉션 선택

**다음 단계:**
- 실제 프로젝트에 성능 측정 도구를 도입하세요
- BenchmarkDotNet을 사용하여 최적화 전후를 비교하세요
- 메모리 프로파일러로 메모리 사용 패턴을 분석하세요

**실습 과제:**
1. Span<T>을 사용하여 문자열 파싱 최적화하기
2. StringBuilder를 활용한 CSV 파일 생성기 만들기
3. 다양한 컬렉션의 성능 비교 벤치마크 작성하기

---

**참고 자료:**
- [Microsoft Docs - Span<T>](https://docs.microsoft.com/en-us/dotnet/api/system.span-1)
- [Microsoft Docs - Memory<T>](https://docs.microsoft.com/en-us/dotnet/api/system.memory-1)
- [Performance improvements in .NET](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/)
- [BenchmarkDotNet Documentation](https://benchmarkdotnet.org/)
