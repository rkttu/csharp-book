# 10장. 상속과 다형성

상속(Inheritance)과 다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 개념입니다. 상속을 통해 기존 클래스의 기능을 재사용하고 확장할 수 있으며, 다형성을 통해 같은 인터페이스로 다양한 타입의 객체를 다룰 수 있습니다.

## 이 장에서 배울 내용

- **상속의 기본**: 기본 클래스와 파생 클래스의 관계, base 키워드, 메서드 오버라이딩
- **추상 클래스**: 인스턴스화할 수 없는 추상 클래스와 추상 메서드
- **인터페이스**: 계약을 정의하는 인터페이스의 활용
- **다형성**: 하나의 타입으로 여러 형태의 객체를 다루는 방법

---

## 10.1 상속 (Inheritance)

상속은 기존 클래스의 기능을 물려받아 새로운 클래스를 만드는 기법입니다. 코드 재사용성을 높이고 클래스 간의 계층 구조를 표현할 수 있습니다.

### 10.1.1 기본 클래스와 파생 클래스

기본 클래스(Base Class)는 상속을 제공하는 클래스이고, 파생 클래스(Derived Class)는 상속을 받는 클래스입니다.

```csharp
// 기본 클래스
class Animal
{
    public string Name { get; set; }
    
    public void Eat()
    {
        Console.WriteLine($"{Name}이(가) 먹이를 먹습니다.");
    }
}

// 파생 클래스
class Dog : Animal
{
    public void Bark()
    {
        Console.WriteLine($"{Name}이(가) 짖습니다: 멍멍!");
    }
}

// 사용 예제
Dog myDog = new Dog();
myDog.Name = "바둑이";
myDog.Eat();   // 상속받은 메서드
myDog.Bark();  // Dog 클래스의 메서드

// 출력:
// 바둑이이(가) 먹이를 먹습니다.
// 바둑이이(가) 짖습니다: 멍멍!
```

**상속의 특징:**
- 파생 클래스는 기본 클래스의 public, protected 멤버를 사용할 수 있습니다
- C#은 단일 상속만 지원합니다 (하나의 클래스만 상속 가능)
- 모든 클래스는 암묵적으로 `object` 클래스를 상속합니다

### 10.1.2 base 키워드

`base` 키워드는 기본 클래스의 멤버에 접근할 때 사용합니다.

```csharp
class Animal
{
    public string Name { get; set; }
    
    public Animal(string name)
    {
        Name = name;
        Console.WriteLine($"Animal 생성자: {name}");
    }
    
    public virtual void MakeSound()
    {
        Console.WriteLine("동물 소리");
    }
}

class Dog : Animal
{
    public string Breed { get; set; }
    
    // base를 사용하여 기본 클래스 생성자 호출
    public Dog(string name, string breed) : base(name)
    {
        Breed = breed;
        Console.WriteLine($"Dog 생성자: {breed}");
    }
    
    public override void MakeSound()
    {
        // base를 사용하여 기본 클래스 메서드 호출
        base.MakeSound();
        Console.WriteLine("멍멍!");
    }
}

// 사용 예제
Dog dog = new Dog("바둑이", "진돗개");
dog.MakeSound();

// 출력:
// Animal 생성자: 바둑이
// Dog 생성자: 진돗개
// 동물 소리
// 멍멍!
```

### 10.1.3 메서드 오버라이딩

메서드 오버라이딩(Method Overriding)은 기본 클래스의 메서드를 파생 클래스에서 재정의하는 것입니다.

```csharp
class Shape
{
    public virtual double GetArea()
    {
        return 0;
    }
    
    public virtual void Draw()
    {
        Console.WriteLine("도형을 그립니다.");
    }
}

class Circle : Shape
{
    public double Radius { get; set; }
    
    public Circle(double radius)
    {
        Radius = radius;
    }
    
    // 메서드 오버라이딩
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"반지름 {Radius}인 원을 그립니다.");
    }
}

class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }
    
    public override double GetArea()
    {
        return Width * Height;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"{Width}x{Height} 사각형을 그립니다.");
    }
}

// 사용 예제
Circle circle = new Circle(5);
Console.WriteLine($"원의 넓이: {circle.GetArea():F2}");
circle.Draw();

Rectangle rect = new Rectangle(4, 6);
Console.WriteLine($"사각형의 넓이: {rect.GetArea()}");
rect.Draw();

// 출력:
// 원의 넓이: 78.54
// 반지름 5인 원을 그립니다.
// 사각형의 넓이: 24
// 4x6 사각형을 그립니다.
```

**오버라이딩 규칙:**
- 기본 클래스 메서드에 `virtual` 키워드 필요
- 파생 클래스 메서드에 `override` 키워드 필요
- 메서드 시그니처(이름, 매개변수)가 동일해야 함
- 접근 제한자는 같거나 더 넓어야 함

---

## 10.2 추상 클래스 (Abstract Class)

추상 클래스는 인스턴스를 직접 생성할 수 없으며, 상속을 통해서만 사용할 수 있는 클래스입니다. 추상 메서드는 구현 없이 선언만 하고, 파생 클래스에서 반드시 구현해야 합니다.

```csharp
// 추상 클래스
abstract class Vehicle
{
    public string Model { get; set; }
    
    // 일반 메서드
    public void DisplayInfo()
    {
        Console.WriteLine($"모델: {Model}");
    }
    
    // 추상 메서드 (구현 없음)
    public abstract void Start();
    public abstract void Stop();
}

class Car : Vehicle
{
    // 추상 메서드 구현 필수
    public override void Start()
    {
        Console.WriteLine($"{Model} 자동차 시동을 겁니다.");
    }
    
    public override void Stop()
    {
        Console.WriteLine($"{Model} 자동차를 정지합니다.");
    }
}

class Motorcycle : Vehicle
{
    public override void Start()
    {
        Console.WriteLine($"{Model} 오토바이 시동을 겁니다.");
    }
    
    public override void Stop()
    {
        Console.WriteLine($"{Model} 오토바이를 정지합니다.");
    }
}

// 사용 예제
// Vehicle vehicle = new Vehicle();  // 오류! 추상 클래스는 인스턴스화 불가

Car car = new Car { Model = "소나타" };
car.DisplayInfo();
car.Start();
car.Stop();

Motorcycle motorcycle = new Motorcycle { Model = "혼다" };
motorcycle.DisplayInfo();
motorcycle.Start();
motorcycle.Stop();

// 출력:
// 모델: 소나타
// 소나타 자동차 시동을 겁니다.
// 소나타 자동차를 정지합니다.
// 모델: 혼다
// 혼다 오토바이 시동을 겁니다.
// 혼다 오토바이를 정지합니다.
```

**추상 클래스의 특징:**
- `abstract` 키워드로 선언
- 인스턴스 생성 불가
- 추상 메서드와 일반 메서드를 모두 포함 가능
- 파생 클래스는 모든 추상 메서드를 구현해야 함
- 생성자, 필드, 속성을 가질 수 있음

---

## 10.3 인터페이스 (Interface)

인터페이스는 클래스가 구현해야 하는 메서드와 속성의 계약을 정의합니다. 추상 클래스와 달리 다중 구현이 가능합니다.

### 10.3.1 인터페이스 정의와 구현

```csharp
// 인터페이스 정의
interface IDrawable
{
    void Draw();
    void Erase();
}

interface IResizable
{
    void Resize(double scale);
}

// 인터페이스 구현
class Square : IDrawable, IResizable
{
    public double Size { get; set; }
    
    public Square(double size)
    {
        Size = size;
    }
    
    // IDrawable 구현
    public void Draw()
    {
        Console.WriteLine($"크기 {Size}인 정사각형을 그립니다.");
    }
    
    public void Erase()
    {
        Console.WriteLine("정사각형을 지웁니다.");
    }
    
    // IResizable 구현
    public void Resize(double scale)
    {
        Size *= scale;
        Console.WriteLine($"정사각형 크기를 {scale}배로 조정했습니다. 새 크기: {Size}");
    }
}

// 사용 예제
Square square = new Square(10);
square.Draw();
square.Resize(1.5);
square.Draw();
square.Erase();

// 출력:
// 크기 10인 정사각형을 그립니다.
// 정사각형 크기를 1.5배로 조정했습니다. 새 크기: 15
// 크기 15인 정사각형을 그립니다.
// 정사각형을 지웁니다.
```

**인터페이스의 특징:**
- `interface` 키워드로 선언
- 메서드, 속성, 이벤트, 인덱서만 포함 가능 (구현 없음)
- 모든 멤버는 public (접근 제한자 불필요)
- 다중 인터페이스 구현 가능
- 관례상 이름은 'I'로 시작 (예: IDrawable)

### 10.3.2 다중 인터페이스 구현

```csharp
interface IMovable
{
    void Move(int x, int y);
}

interface IRotatable
{
    void Rotate(double angle);
}

interface IScalable
{
    void Scale(double factor);
}

// 여러 인터페이스 동시 구현
class GameObject : IMovable, IRotatable, IScalable
{
    public int X { get; set; }
    public int Y { get; set; }
    public double Angle { get; set; }
    public double Size { get; set; }
    
    public void Move(int x, int y)
    {
        X = x;
        Y = y;
        Console.WriteLine($"위치 이동: ({X}, {Y})");
    }
    
    public void Rotate(double angle)
    {
        Angle = angle;
        Console.WriteLine($"회전: {Angle}도");
    }
    
    public void Scale(double factor)
    {
        Size *= factor;
        Console.WriteLine($"크기 조정: {factor}배");
    }
}

// 사용 예제
GameObject obj = new GameObject { Size = 1.0 };
obj.Move(100, 200);
obj.Rotate(45);
obj.Scale(2.0);

// 인터페이스 타입으로 참조 가능
IMovable movable = obj;
movable.Move(300, 400);

// 출력:
// 위치 이동: (100, 200)
// 회전: 45도
// 크기 조정: 2배
// 위치 이동: (300, 400)
```

### 10.3.3 기본 인터페이스 메서드

C# 8.0부터 인터페이스에 기본 구현을 제공할 수 있습니다.

```csharp
interface ILogger
{
    // 구현이 필요한 메서드
    void Log(string message);
    
    // 기본 구현이 있는 메서드
    void LogError(string error)
    {
        Log($"[오류] {error}");
    }
    
    void LogWarning(string warning)
    {
        Log($"[경고] {warning}");
    }
}

class ConsoleLogger : ILogger
{
    // Log 메서드만 구현하면 됨
    public void Log(string message)
    {
        Console.WriteLine(message);
    }
    
    // LogError, LogWarning은 기본 구현 사용 가능
}

class CustomLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($">> {message}");
    }
    
    // 기본 구현을 오버라이드할 수도 있음
    public void LogError(string error)
    {
        Console.WriteLine($"!!! 오류: {error} !!!");
    }
}

// 사용 예제
ILogger logger1 = new ConsoleLogger();
logger1.Log("일반 메시지");
logger1.LogError("오류 발생");
logger1.LogWarning("주의 필요");

Console.WriteLine();

ILogger logger2 = new CustomLogger();
logger2.Log("일반 메시지");
logger2.LogError("오류 발생");
logger2.LogWarning("주의 필요");

// 출력:
// 일반 메시지
// [오류] 오류 발생
// [경고] 주의 필요
//
// >> 일반 메시지
// !!! 오류: 오류 발생 !!!
// [경고] 주의 필요
```

---

## 10.4 다형성 (Polymorphism)

다형성은 하나의 타입으로 여러 종류의 객체를 참조할 수 있는 능력입니다. 상속과 인터페이스를 통해 다형성을 구현할 수 있습니다.

```csharp
// 기본 클래스
abstract class Employee
{
    public string Name { get; set; }
    public abstract double CalculateSalary();
    
    public void DisplayInfo()
    {
        Console.WriteLine($"이름: {Name}, 급여: {CalculateSalary():C}");
    }
}

class FullTimeEmployee : Employee
{
    public double MonthlySalary { get; set; }
    
    public override double CalculateSalary()
    {
        return MonthlySalary;
    }
}

class PartTimeEmployee : Employee
{
    public double HourlyRate { get; set; }
    public int HoursWorked { get; set; }
    
    public override double CalculateSalary()
    {
        return HourlyRate * HoursWorked;
    }
}

class Contractor : Employee
{
    public double ProjectFee { get; set; }
    
    public override double CalculateSalary()
    {
        return ProjectFee;
    }
}

// 다형성 활용
List<Employee> employees = new List<Employee>
{
    new FullTimeEmployee { Name = "김철수", MonthlySalary = 3000000 },
    new PartTimeEmployee { Name = "이영희", HourlyRate = 15000, HoursWorked = 80 },
    new Contractor { Name = "박민수", ProjectFee = 5000000 }
};

Console.WriteLine("=== 직원 급여 목록 ===");
foreach (Employee emp in employees)
{
    // 각 객체의 실제 타입에 따라 다른 CalculateSalary 메서드 호출
    emp.DisplayInfo();
}

double totalSalary = 0;
foreach (Employee emp in employees)
{
    totalSalary += emp.CalculateSalary();
}
Console.WriteLine($"\n총 급여: {totalSalary:C}");

// 출력:
// === 직원 급여 목록 ===
// 이름: 김철수, 급여: ₩3,000,000.00
// 이름: 이영희, 급여: ₩1,200,000.00
// 이름: 박민수, 급여: ₩5,000,000.00
//
// 총 급여: ₩9,200,000.00
```

**인터페이스를 활용한 다형성:**

```csharp
interface IPayable
{
    double GetPaymentAmount();
}

class Invoice : IPayable
{
    public string PartNumber { get; set; }
    public string PartDescription { get; set; }
    public int Quantity { get; set; }
    public double PricePerItem { get; set; }
    
    public double GetPaymentAmount()
    {
        return Quantity * PricePerItem;
    }
}

class SalariedEmployee : IPayable
{
    public string Name { get; set; }
    public double WeeklySalary { get; set; }
    
    public double GetPaymentAmount()
    {
        return WeeklySalary;
    }
}

// 다형성으로 서로 다른 타입을 동일하게 처리
List<IPayable> payables = new List<IPayable>
{
    new Invoice 
    { 
        PartNumber = "A101", 
        PartDescription = "부품", 
        Quantity = 10, 
        PricePerItem = 5000 
    },
    new SalariedEmployee 
    { 
        Name = "최수정", 
        WeeklySalary = 800000 
    }
};

Console.WriteLine("=== 지불 목록 ===");
foreach (IPayable payable in payables)
{
    Console.WriteLine($"지불 금액: {payable.GetPaymentAmount():C}");
}

// 출력:
// === 지불 목록 ===
// 지불 금액: ₩50,000.00
// 지불 금액: ₩800,000.00
```

**다형성의 장점:**
- 코드의 유연성과 확장성 향상
- 새로운 타입 추가 시 기존 코드 수정 최소화
- 공통 인터페이스로 다양한 객체를 일관되게 처리
- 개방-폐쇄 원칙(Open-Closed Principle) 실현

---

## 마무리

이 장에서는 객체지향 프로그래밍의 핵심인 상속과 다형성에 대해 학습했습니다:

✅ **상속**: 기본 클래스의 기능을 파생 클래스가 재사용하고 확장
✅ **추상 클래스**: 공통 기능과 추상 메서드를 정의하는 템플릿
✅ **인터페이스**: 구현 계약을 정의하고 다중 구현 지원
✅ **다형성**: 하나의 타입으로 여러 형태의 객체를 처리

**다음 단계:**

11장에서는 sealed 클래스, record 타입, 구조체, 열거형 등 고급 객체지향 개념을 다룹니다.
