# 10장. 상속과 다형성

객체지향 프로그래밍(Object-Oriented Programming, OOP)의 세계에서 상속(Inheritance)과 다형성(Polymorphism)은 단순한 프로그래밍 기법을 넘어, 소프트웨어 설계의 근본적인 철학을 구현하는 핵심 메커니즘입니다. 이 두 개념은 1960년대 중반 Simula 67 언어에서 처음 도입된 이후, 현대 소프트웨어 공학의 근간이 되었으며, 코드 재사용성(Reusability), 확장성(Extensibility), 유지보수성(Maintainability)을 획기적으로 향상시켰습니다.

상속은 자연계의 분류학(Taxonomy)에서 영감을 받은 개념으로, 생물학적 분류 체계처럼 소프트웨어 엔티티 간의 "is-a" 관계를 표현합니다. 예를 들어, "개는 동물이다(Dog is-a Animal)"라는 관계를 코드로 직접 표현할 수 있게 해줍니다. 다형성은 그리스어로 "여러 형태(poly = many, morph = form)"를 의미하며, 동일한 인터페이스를 통해 서로 다른 타입의 객체를 일관되게 다룰 수 있게 하는 강력한 추상화 메커니즘입니다.

**객체지향 프로그래밍의 역사적 맥락:**

객체지향 프로그래밍의 개념은 1960년대 노르웨이의 Ole-Johan Dahl과 Kristen Nygaard가 개발한 Simula 67에서 시작되었습니다. 이들은 시뮬레이션 프로그램을 작성하면서 현실 세계의 객체들을 프로그래밍으로 모델링할 필요성을 느꼈고, 클래스(Class)와 상속(Inheritance)이라는 혁신적인 개념을 도입했습니다. 1970년대 Xerox PARC의 Alan Kay는 Smalltalk 언어를 통해 객체지향 개념을 더욱 발전시켰으며, "메시지 전달(Message Passing)"이라는 다형성의 핵심 아이디어를 정립했습니다.

1980년대 Bjarne Stroustrup이 개발한 C++은 객체지향 프로그래밍을 주류로 만들었으며, 1990년대 Java의 등장으로 "순수한" 객체지향 언어의 시대가 열렸습니다. C#은 2000년대 초반 Microsoft가 .NET 플랫폼을 위해 설계한 언어로, Java의 장점을 흡수하면서도 더욱 현대적이고 실용적인 객체지향 기능을 제공합니다.

**SOLID 원칙과의 관계:**

상속과 다형성은 Robert C. Martin이 제시한 SOLID 원칙과 밀접한 관계가 있습니다:

1. **단일 책임 원칙(Single Responsibility Principle, SRP)**: 클래스는 하나의 책임만 가져야 하며, 상속을 통해 관심사를 분리할 수 있습니다
2. **개방-폐쇄 원칙(Open-Closed Principle, OCP)**: 소프트웨어 엔터티는 확장에는 열려 있고 수정에는 닫혀 있어야 하며, 상속과 다형성이 이를 가능하게 합니다
3. **리스코프 치환 원칙(Liskov Substitution Principle, LSP)**: 파생 클래스는 기본 클래스를 대체할 수 있어야 하며, 이는 올바른 상속 설계의 핵심입니다
4. **인터페이스 분리 원칙(Interface Segregation Principle, ISP)**: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다
5. **의존성 역전 원칙(Dependency Inversion Principle, DIP)**: 구체적인 것이 아닌 추상에 의존해야 하며, 인터페이스와 추상 클래스가 이를 실현합니다

이러한 원칙들은 단순히 이론적인 개념이 아니라, 실제 대규모 소프트웨어 프로젝트에서 검증된 모범 사례(Best Practices)입니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 객체지향 프로그래밍의 핵심 메커니즘을 체계적으로 학습하게 됩니다:

- **상속의 이론과 실제**: 기본 클래스와 파생 클래스의 관계, base 키워드의 활용, 메서드 오버라이딩의 메커니즘, 그리고 상속의 올바른 사용법과 주의사항을 깊이 있게 이해합니다. "is-a" 관계의 의미와 상속 계층 구조 설계의 원칙, 그리고 Fragile Base Class Problem 같은 상속의 함정을 배웁니다.

- **추상 클래스의 설계 패턴**: 인스턴스화할 수 없는 추상 클래스의 철학적 배경과 실용적 활용법, 템플릿 메서드 패턴(Template Method Pattern)의 구현, 그리고 추상 클래스와 인터페이스의 선택 기준을 학습합니다.

- **인터페이스 기반 설계**: 계약(Contract) 지향 프로그래밍의 핵심인 인터페이스의 정의와 구현, C#의 다중 인터페이스 구현 메커니즘, 그리고 C# 8.0의 혁신적인 기본 인터페이스 메서드(Default Interface Methods)를 깊이 있게 다룹니다.

- **다형성의 원리와 응용**: 컴파일 타임 다형성(메서드 오버로딩)과 런타임 다형성(메서드 오버라이딩)의 차이, 가상 메서드 테이블(Virtual Method Table, VMT)의 동작 원리, 그리고 다형성을 활용한 디자인 패턴을 실무 관점에서 학습합니다.

**학습 목표:**
- 상속 계층 구조의 올바른 설계와 구현 능력 배양
- 추상화(Abstraction)와 캡슐화(Encapsulation)의 실제 적용
- 인터페이스 기반의 유연한 아키텍처 설계
- 다형성을 활용한 확장 가능한 시스템 구축
- SOLID 원칙을 코드로 구현하는 실무 능력

---

## 10.1 상속 (Inheritance)

상속은 기존 클래스의 특성과 동작을 물려받아 새로운 클래스를 정의하는 객체지향 프로그래밍의 핵심 메커니즘입니다. 이는 단순히 코드를 복사-붙여넣기하는 것이 아니라, 클래스 간의 의미론적(Semantic) 관계를 명시적으로 표현하는 강력한 도구입니다. 상속을 통해 코드 재사용성(Code Reusability)을 극대화하고, 클래스 간의 계층 구조(Class Hierarchy)를 자연스럽게 표현하며, 다형성(Polymorphism)의 기반을 마련할 수 있습니다.

**상속의 이론적 배경:**

상속은 생물학의 분류학(Taxonomy)에서 영감을 받은 개념입니다. 린네(Carl Linnaeus)의 생물 분류 체계가 생물을 계(Kingdom), 문(Phylum), 강(Class), 목(Order), 과(Family), 속(Genus), 종(Species)으로 계층화했듯이, 객체지향 프로그래밍도 클래스를 계층적으로 조직화합니다. 예를 들어, "포유류는 동물의 일종이고, 개는 포유류의 일종이다"라는 생물학적 관계를 "Dog is-a Mammal, Mammal is-a Animal"이라는 상속 관계로 표현할 수 있습니다.

**"is-a" vs "has-a" 관계:**

상속을 올바르게 사용하기 위해서는 "is-a"(~은 ~이다)와 "has-a"(~은 ~을 가지고 있다) 관계를 명확히 구분해야 합니다:

- **is-a 관계 (상속 사용)**: "개는 동물이다(Dog is-a Animal)" - 상속으로 구현
- **has-a 관계 (컴포지션 사용)**: "자동차는 엔진을 가지고 있다(Car has-a Engine)" - 멤버 변수로 구현

이 구분은 단순한 문법적 차이가 아니라, 소프트웨어 설계의 근본적인 철학적 차이를 반영합니다. Gang of Four의 디자인 패턴 책에서는 "상속보다 컴포지션을 선호하라(Favor Composition Over Inheritance)"는 원칙을 강조하는데, 이는 상속의 남용이 코드의 결합도(Coupling)를 높이고 유연성을 떨어뜨릴 수 있기 때문입니다.

**C#의 상속 모델:**

C#은 **단일 상속(Single Inheritance)** 모델을 채택했습니다. 이는 하나의 클래스가 오직 하나의 기본 클래스만 상속할 수 있다는 의미입니다. 이러한 제약은 C++의 다중 상속이 야기하는 "다이아몬드 문제(Diamond Problem)"를 근본적으로 방지합니다. 대신 C#은 **다중 인터페이스 구현(Multiple Interface Implementation)**을 통해 다중 상속의 이점을 취하면서도 복잡성을 줄였습니다.

```
다이아몬드 문제 (C++에서 발생):
        A
       / \
      B   C
       \ /
        D
D가 B와 C를 모두 상속하면, A의 멤버가 중복되는 문제 발생
C#은 단일 상속으로 이 문제를 원천적으로 차단
```

**상속의 메모리 레이아웃:**

상속된 클래스의 인스턴스는 메모리에서 기본 클래스의 필드를 먼저 배치하고, 그 다음 파생 클래스의 필드를 배치하는 순차적 구조를 가집니다:

```
[기본 클래스 필드들] [파생 클래스 필드들] [가상 메서드 테이블 포인터]
```

이러한 레이아웃 덕분에 파생 클래스의 인스턴스를 기본 클래스 타입으로 참조할 때, 추가적인 변환 없이 기본 클래스의 멤버에 직접 접근할 수 있습니다.

### 10.1.1 기본 클래스와 파생 클래스

기본 클래스(Base Class, 또는 부모 클래스, 슈퍼 클래스)는 상속을 제공하는 클래스이고, 파생 클래스(Derived Class, 또는 자식 클래스, 서브 클래스)는 상속을 받는 클래스입니다. 이러한 용어는 객체지향 언어마다 다르게 사용되지만, C#에서는 주로 "기본 클래스"와 "파생 클래스"라는 용어를 사용합니다.

**상속 구문의 이해:**

C#에서 상속은 콜론(`:`) 기호를 사용하여 표현합니다. 이는 Pascal 계열 언어의 영향을 받은 문법으로, Java의 `extends` 키워드보다 간결하면서도 명확합니다:

```csharp
class 파생클래스명 : 기본클래스명
{
    // 파생 클래스의 추가 멤버
}
```

**기본적인 상속 예제:**

```csharp
// 기본 클래스 - 동물의 공통 특성 정의
class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public void Eat()
    {
        Console.WriteLine($"{Name}이(가) 먹이를 먹습니다.");
    }
    
    public void Sleep()
    {
        Console.WriteLine($"{Name}이(가) 잠을 잡니다.");
    }
}

// 파생 클래스 - Dog는 Animal의 모든 특성을 상속받고 추가 기능을 정의
class Dog : Animal
{
    public string Breed { get; set; }  // Dog만의 속성
    
    // Dog만의 메서드
    public void Bark()
    {
        Console.WriteLine($"{Name}이(가) 짖습니다: 멍멍!");
    }
    
    public void WagTail()
    {
        Console.WriteLine($"{Name}이(가) 꼬리를 흔듭니다.");
    }
}

// 또 다른 파생 클래스
class Cat : Animal
{
    public string FurColor { get; set; }
    
    public void Meow()
    {
        Console.WriteLine($"{Name}이(가) 웁니다: 야옹~");
    }
    
    public void Purr()
    {
        Console.WriteLine($"{Name}이(가) 가르랑거립니다.");
    }
}

// 사용 예제
Dog myDog = new Dog();
myDog.Name = "바둑이";
myDog.Age = 3;
myDog.Breed = "진돗개";
myDog.Eat();      // Animal로부터 상속받은 메서드
myDog.Sleep();    // Animal로부터 상속받은 메서드
myDog.Bark();     // Dog 클래스 고유의 메서드
myDog.WagTail();  // Dog 클래스 고유의 메서드

Cat myCat = new Cat();
myCat.Name = "나비";
myCat.Age = 2;
myCat.FurColor = "하얀색";
myCat.Eat();      // Animal로부터 상속받은 메서드
myCat.Meow();     // Cat 클래스 고유의 메서드

// 출력:
// 바둑이이(가) 먹이를 먹습니다.
// 바둑이이(가) 잠을 잡니다.
// 바둑이이(가) 짖습니다: 멍멍!
// 바둑이이(가) 꼬리를 흔듭니다.
// 나비이(가) 먹이를 먹습니다.
// 나비이(가) 웁니다: 야옹~
```

**멤버 접근성과 상속:**

상속에서 접근 제한자(Access Modifier)는 파생 클래스가 기본 클래스의 어떤 멤버에 접근할 수 있는지 결정합니다:

| 접근 제한자 | 동일 클래스 | 파생 클래스 | 동일 어셈블리 | 외부 어셈블리 |
|------------|-----------|------------|-------------|-------------|
| `public` | ✅ | ✅ | ✅ | ✅ |
| `protected` | ✅ | ✅ | ❌ | ❌ |
| `internal` | ✅ | ✅* | ✅ | ❌ |
| `protected internal` | ✅ | ✅ | ✅ | ✅ (파생 클래스만) |
| `private protected` | ✅ | ✅ | ❌ | ❌ |
| `private` | ✅ | ❌ | ❌ | ❌ |

*internal: 동일 어셈블리 내에서만

```csharp
class Animal
{
    public string Name { get; set; }         // 모든 곳에서 접근 가능
    protected int age;                        // 파생 클래스에서 접근 가능
    private string secretIdentity;            // Animal 클래스 내부에서만 접근 가능
    
    public void PublicMethod() { }
    protected void ProtectedMethod() { }      // 파생 클래스에서 호출 가능
    private void PrivateMethod() { }          // 파생 클래스에서 호출 불가
}

class Dog : Animal
{
    public void AccessMembers()
    {
        Console.WriteLine(Name);              // ✅ OK: public
        Console.WriteLine(age);               // ✅ OK: protected
        // Console.WriteLine(secretIdentity); // ❌ Error: private
        
        PublicMethod();                       // ✅ OK
        ProtectedMethod();                    // ✅ OK: protected
        // PrivateMethod();                   // ❌ Error: private
    }
}
```

**object 클래스: 모든 타입의 조상**

C#의 모든 타입은 명시적이든 암묵적이든 `System.Object` 클래스(별칭 `object`)를 상속받습니다. 이는 .NET의 통합 타입 시스템(Unified Type System)의 핵심입니다:

```csharp
// 명시적 object 상속 (일반적으로 생략)
class MyClass : object
{
}

// 암묵적 object 상속 (일반적인 방식)
class MyClass
{
    // 실제로는 object를 상속받고 있음
}
```

`object` 클래스는 다음과 같은 기본 메서드를 제공하며, 모든 클래스가 이를 상속받습니다:

```csharp
class Object
{
    public virtual bool Equals(object obj);          // 객체 동등성 비교
    public virtual int GetHashCode();                // 해시 코드 생성
    public virtual string ToString();                // 문자열 표현 반환
    public Type GetType();                           // 런타임 타입 정보
    protected virtual void Finalize();               // 소멸자 (거의 사용 안 함)
    protected object MemberwiseClone();              // 얕은 복사
}
```

**실용적인 object 메서드 오버라이딩:**

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    // ToString 오버라이딩 - 객체의 문자열 표현 정의
    public override string ToString()
    {
        return $"Person: {Name}, Age: {Age}";
    }
    
    // Equals 오버라이딩 - 동등성 비교 논리 정의
    public override bool Equals(object obj)
    {
        if (obj == null || GetType() != obj.GetType())
            return false;
        
        Person other = (Person)obj;
        return Name == other.Name && Age == other.Age;
    }
    
    // GetHashCode 오버라이딩 - Equals와 일관성 유지 필요
    public override int GetHashCode()
    {
        return HashCode.Combine(Name, Age);
    }
}

Person p1 = new Person { Name = "김철수", Age = 30 };
Person p2 = new Person { Name = "김철수", Age = 30 };

Console.WriteLine(p1.ToString());        // Person: 김철수, Age: 30
Console.WriteLine(p1.Equals(p2));        // True (내용이 같음)
Console.WriteLine(p1 == p2);             // False (참조가 다름)
```

**상속의 주요 특징과 제약사항:**

1. **단일 상속 제약**: C#은 클래스의 다중 상속을 지원하지 않습니다. 하나의 클래스는 오직 하나의 기본 클래스만 상속할 수 있습니다.

```csharp
// ❌ 오류: 다중 상속 불가
class FlyingFish : Fish, Bird  // Compile Error!
{
}

// ✅ 올바른 방법: 인터페이스로 해결
class FlyingFish : Fish, IFlyable
{
    public void Fly() { /* 구현 */ }
}
```

2. **sealed 클래스**: `sealed` 키워드로 표시된 클래스는 상속할 수 없습니다. 이는 클래스 설계자가 의도한 대로만 사용되도록 보장합니다.

```csharp
sealed class FinalClass
{
    // 이 클래스는 더 이상 상속될 수 없음
}

// ❌ 오류
class DerivedClass : FinalClass  // Compile Error!
{
}
```

C# BCL(Base Class Library)의 많은 클래스가 sealed로 선언되어 있습니다:
- `System.String`
- `System.Int32`, `System.Double` 등 모든 값 타입의 래퍼 클래스
- `System.ValueType`

3. **암묵적 object 상속**: 명시적으로 기본 클래스를 지정하지 않으면 자동으로 `object`를 상속합니다.

4. **생성자 체이닝**: 파생 클래스의 인스턴스가 생성될 때, 기본 클래스의 생성자가 먼저 실행됩니다. 이는 다음 섹션에서 자세히 다룹니다.

### 10.1.2 base 키워드

`base` 키워드는 파생 클래스에서 기본 클래스의 멤버에 명시적으로 접근할 때 사용하는 특별한 참조입니다. 이는 Java의 `super` 키워드와 유사한 역할을 하며, 주로 두 가지 주요 상황에서 사용됩니다: 기본 클래스의 생성자 호출과 기본 클래스의 멤버(메서드, 속성) 접근입니다.

**생성자 체이닝과 초기화 순서:**

객체지향 프로그래밍에서 파생 클래스의 객체가 생성될 때, 기본 클래스의 생성자가 먼저 실행된 후 파생 클래스의 생성자가 실행됩니다. 이를 **생성자 체이닝(Constructor Chaining)**이라고 합니다. 이는 논리적으로 당연한 순서인데, 파생 클래스가 기본 클래스의 기능에 의존하므로 기본 클래스가 먼저 완전히 초기화되어야 하기 때문입니다.

**생성자 호출 순서의 이해:**

```
[기본 클래스 생성자] → [파생 클래스 생성자]

더 깊은 상속 계층에서는:
[최상위 기본 클래스] → [중간 클래스] → [최종 파생 클래스]
```

**base를 사용한 생성자 호출:**

```csharp
class Animal
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    // 기본 생성자
    public Animal()
    {
        Console.WriteLine("Animal 기본 생성자 실행");
    }
    
    // 매개변수가 있는 생성자
    public Animal(string name, int age)
    {
        Name = name;
        Age = age;
        Console.WriteLine($"Animal 생성자: {name}, {age}세");
    }
    
    public virtual void MakeSound()
    {
        Console.WriteLine($"{Name}: 동물 소리");
    }
}

class Dog : Animal
{
    public string Breed { get; set; }
    
    // 기본 생성자 - 명시적으로 기본 클래스 생성자 호출
    public Dog() : base()
    {
        Console.WriteLine("Dog 기본 생성자 실행");
    }
    
    // 매개변수 생성자 - base를 사용하여 기본 클래스 생성자에 값 전달
    public Dog(string name, int age, string breed) : base(name, age)
    {
        Breed = breed;
        Console.WriteLine($"Dog 생성자: 품종 {breed}");
    }
    
    public override void MakeSound()
    {
        // base를 사용하여 기본 클래스 메서드 호출
        base.MakeSound();
        Console.WriteLine($"{Name}: 멍멍!");
    }
}

// 사용 예제 1: 기본 생성자
Console.WriteLine("=== 기본 생성자 사용 ===");
Dog dog1 = new Dog();
// 출력:
// Animal 기본 생성자 실행
// Dog 기본 생성자 실행

Console.WriteLine("\n=== 매개변수 생성자 사용 ===");
Dog dog2 = new Dog("바둑이", 3, "진돗개");
// 출력:
// Animal 생성자: 바둑이, 3세
// Dog 생성자: 품종 진돗개

Console.WriteLine("\n=== 메서드 호출 ===");
dog2.MakeSound();
// 출력:
// 바둑이: 동물 소리
// 바둑이: 멍멍!
```

**base의 필요성과 활용 시나리오:**

1. **기본 클래스 생성자 명시적 호출**: 기본 클래스에 매개변수가 있는 생성자만 있고 기본 생성자가 없는 경우, 파생 클래스는 반드시 `base(...)`를 사용해야 합니다.

```csharp
class Vehicle
{
    public string Model { get; set; }
    
    // 기본 생성자가 없음 - 오직 매개변수 생성자만 존재
    public Vehicle(string model)
    {
        Model = model;
        Console.WriteLine($"Vehicle 생성: {model}");
    }
}

class Car : Vehicle
{
    public int Seats { get; set; }
    
    // ❌ 오류: 기본 클래스에 매개변수 없는 생성자가 없음
    // public Car() { }
    
    // ✅ 올바른 방법: base를 사용하여 기본 클래스 생성자 호출
    public Car(string model, int seats) : base(model)
    {
        Seats = seats;
        Console.WriteLine($"Car 생성: {seats}인승");
    }
}
```

2. **기본 클래스 메서드 확장**: 기본 클래스의 메서드 동작을 완전히 대체하지 않고, 추가 기능을 덧붙일 때 사용합니다.

```csharp
class Logger
{
    protected string prefix = "[LOG]";
    
    public virtual void Log(string message)
    {
        Console.WriteLine($"{prefix} {DateTime.Now:HH:mm:ss} - {message}");
    }
}

class DetailedLogger : Logger
{
    public override void Log(string message)
    {
        // 기본 클래스의 Log 메서드 호출 (기본 동작 유지)
        base.Log(message);
        
        // 추가 상세 정보 출력
        Console.WriteLine($"    Thread: {Thread.CurrentThread.ManagedThreadId}");
        Console.WriteLine($"    Source: {System.Reflection.MethodBase.GetCurrentMethod()?.DeclaringType?.Name}");
    }
}

DetailedLogger logger = new DetailedLogger();
logger.Log("시스템 초기화 완료");
// 출력:
// [LOG] 14:30:45 - 시스템 초기화 완료
//     Thread: 1
//     Source: DetailedLogger
```

3. **속성 접근**: 기본 클래스와 파생 클래스에 같은 이름의 멤버가 있을 때, `base`로 기본 클래스 멤버에 명확히 접근할 수 있습니다.

```csharp
class BaseClass
{
    public string Message { get; set; } = "기본 클래스 메시지";
    
    public void ShowMessage()
    {
        Console.WriteLine($"BaseClass: {Message}");
    }
}

class DerivedClass : BaseClass
{
    // new 키워드로 기본 클래스 멤버를 숨김 (hiding)
    public new string Message { get; set; } = "파생 클래스 메시지";
    
    public void ShowBothMessages()
    {
        Console.WriteLine($"파생 클래스 Message: {Message}");
        Console.WriteLine($"기본 클래스 Message: {base.Message}");
        
        // 기본 클래스의 메서드 호출
        base.ShowMessage();
    }
}

DerivedClass obj = new DerivedClass();
obj.ShowBothMessages();
// 출력:
// 파생 클래스 Message: 파생 클래스 메시지
// 기본 클래스 Message: 기본 클래스 메시지
// BaseClass: 기본 클래스 메시지
```

**복잡한 상속 계층에서의 base:**

```csharp
class Organism
{
    public string Species { get; set; }
    
    public Organism(string species)
    {
        Species = species;
        Console.WriteLine($"[1] Organism 생성: {species}");
    }
    
    public virtual void Live()
    {
        Console.WriteLine($"{Species}가(이) 생명 활동을 합니다.");
    }
}

class Animal : Organism
{
    public int LegCount { get; set; }
    
    public Animal(string species, int legCount) : base(species)
    {
        LegCount = legCount;
        Console.WriteLine($"[2] Animal 생성: {legCount}개의 다리");
    }
    
    public override void Live()
    {
        base.Live();
        Console.WriteLine($"{Species}가(이) 움직입니다.");
    }
}

class Mammal : Animal
{
    public bool HasFur { get; set; }
    
    public Mammal(string species, int legCount, bool hasFur) : base(species, legCount)
    {
        HasFur = hasFur;
        Console.WriteLine($"[3] Mammal 생성: 털 {(hasFur ? "있음" : "없음")}");
    }
    
    public override void Live()
    {
        base.Live();
        Console.WriteLine($"{Species}가(이) 체온을 유지합니다.");
    }
}

Console.WriteLine("=== 객체 생성 ===");
Mammal dog = new Mammal("개", 4, true);
// 출력:
// [1] Organism 생성: 개
// [2] Animal 생성: 4개의 다리
// [3] Mammal 생성: 털 있음

Console.WriteLine("\n=== Live 메서드 호출 ===");
dog.Live();
// 출력:
// 개가(이) 생명 활동을 합니다.
// 개가(이) 움직입니다.
// 개가(이) 체온을 유지합니다.
```

**base 키워드 사용 시 주의사항:**

1. **생성자에서만 사용 가능한 base(...)**: 생성자 체이닝에서 `base(...)`는 생성자 본문 전에, 초기화자 위치에서만 사용할 수 있습니다.

```csharp
// ✅ 올바른 사용
public Dog(string name) : base(name)
{
}

// ❌ 오류: 생성자 본문 내에서는 base 생성자를 호출할 수 없음
public Dog(string name)
{
    base(name);  // Compile Error!
}
```

2. **정적 멤버 접근 불가**: `base` 키워드는 인스턴스 멤버에만 접근할 수 있고, 정적(static) 멤버에는 사용할 수 없습니다.

```csharp
class BaseClass
{
    public static void StaticMethod() { }
    public void InstanceMethod() { }
}

class DerivedClass : BaseClass
{
    public void TestAccess()
    {
        base.InstanceMethod();     // ✅ OK
        // base.StaticMethod();    // ❌ Error: 정적 멤버는 base로 접근 불가
        BaseClass.StaticMethod();  // ✅ OK: 클래스 이름으로 접근
    }
}
```

3. **순환 참조 방지**: 기본 클래스와 파생 클래스의 메서드가 서로를 호출하면 무한 재귀가 발생할 수 있습니다.

```csharp
// ⚠️ 위험: 무한 재귀 가능성
class BaseClass
{
    public virtual void Method()
    {
        // 파생 클래스의 오버라이드된 메서드가 호출됨 (다형성)
    }
}

class DerivedClass : BaseClass
{
    public override void Method()
    {
        base.Method();  // 기본 클래스 호출
        // 추가 로직...
    }
}
```

### 10.1.3 메서드 오버라이딩

메서드 오버라이딩(Method Overriding)은 기본 클래스의 메서드를 파생 클래스에서 재정의하는 것입니다.

```csharp
class Shape
{
    public virtual double GetArea()
    {
        return 0;
    }
    
    public virtual void Draw()
    {
        Console.WriteLine("도형을 그립니다.");
    }
}

class Circle : Shape
{
    public double Radius { get; set; }
    
    public Circle(double radius)
    {
        Radius = radius;
    }
    
    // 메서드 오버라이딩
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"반지름 {Radius}인 원을 그립니다.");
    }
}

class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }
    
    public override double GetArea()
    {
        return Width * Height;
    }
    
    public override void Draw()
    {
        Console.WriteLine($"{Width}x{Height} 사각형을 그립니다.");
    }
}

// 사용 예제
Circle circle = new Circle(5);
Console.WriteLine($"원의 넓이: {circle.GetArea():F2}");
circle.Draw();

Rectangle rect = new Rectangle(4, 6);
Console.WriteLine($"사각형의 넓이: {rect.GetArea()}");
rect.Draw();

// 출력:
// 원의 넓이: 78.54
// 반지름 5인 원을 그립니다.
// 사각형의 넓이: 24
// 4x6 사각형을 그립니다.
```

**오버라이딩 규칙:**
- 기본 클래스 메서드에 `virtual` 키워드 필요
- 파생 클래스 메서드에 `override` 키워드 필요
- 메서드 시그니처(이름, 매개변수)가 동일해야 함
- 접근 제한자는 같거나 더 넓어야 함

---

## 10.2 추상 클래스 (Abstract Class)

추상 클래스는 인스턴스를 직접 생성할 수 없으며, 상속을 통해서만 사용할 수 있는 클래스입니다. 추상 메서드는 구현 없이 선언만 하고, 파생 클래스에서 반드시 구현해야 합니다.

```csharp
// 추상 클래스
abstract class Vehicle
{
    public string Model { get; set; }
    
    // 일반 메서드
    public void DisplayInfo()
    {
        Console.WriteLine($"모델: {Model}");
    }
    
    // 추상 메서드 (구현 없음)
    public abstract void Start();
    public abstract void Stop();
}

class Car : Vehicle
{
    // 추상 메서드 구현 필수
    public override void Start()
    {
        Console.WriteLine($"{Model} 자동차 시동을 겁니다.");
    }
    
    public override void Stop()
    {
        Console.WriteLine($"{Model} 자동차를 정지합니다.");
    }
}

class Motorcycle : Vehicle
{
    public override void Start()
    {
        Console.WriteLine($"{Model} 오토바이 시동을 겁니다.");
    }
    
    public override void Stop()
    {
        Console.WriteLine($"{Model} 오토바이를 정지합니다.");
    }
}

// 사용 예제
// Vehicle vehicle = new Vehicle();  // 오류! 추상 클래스는 인스턴스화 불가

Car car = new Car { Model = "소나타" };
car.DisplayInfo();
car.Start();
car.Stop();

Motorcycle motorcycle = new Motorcycle { Model = "혼다" };
motorcycle.DisplayInfo();
motorcycle.Start();
motorcycle.Stop();

// 출력:
// 모델: 소나타
// 소나타 자동차 시동을 겁니다.
// 소나타 자동차를 정지합니다.
// 모델: 혼다
// 혼다 오토바이 시동을 겁니다.
// 혼다 오토바이를 정지합니다.
```

**추상 클래스의 특징:**
- `abstract` 키워드로 선언
- 인스턴스 생성 불가
- 추상 메서드와 일반 메서드를 모두 포함 가능
- 파생 클래스는 모든 추상 메서드를 구현해야 함
- 생성자, 필드, 속성을 가질 수 있음

---

## 10.3 인터페이스 (Interface)

인터페이스는 클래스가 구현해야 하는 메서드와 속성의 계약을 정의합니다. 추상 클래스와 달리 다중 구현이 가능합니다.

### 10.3.1 인터페이스 정의와 구현

```csharp
// 인터페이스 정의
interface IDrawable
{
    void Draw();
    void Erase();
}

interface IResizable
{
    void Resize(double scale);
}

// 인터페이스 구현
class Square : IDrawable, IResizable
{
    public double Size { get; set; }
    
    public Square(double size)
    {
        Size = size;
    }
    
    // IDrawable 구현
    public void Draw()
    {
        Console.WriteLine($"크기 {Size}인 정사각형을 그립니다.");
    }
    
    public void Erase()
    {
        Console.WriteLine("정사각형을 지웁니다.");
    }
    
    // IResizable 구현
    public void Resize(double scale)
    {
        Size *= scale;
        Console.WriteLine($"정사각형 크기를 {scale}배로 조정했습니다. 새 크기: {Size}");
    }
}

// 사용 예제
Square square = new Square(10);
square.Draw();
square.Resize(1.5);
square.Draw();
square.Erase();

// 출력:
// 크기 10인 정사각형을 그립니다.
// 정사각형 크기를 1.5배로 조정했습니다. 새 크기: 15
// 크기 15인 정사각형을 그립니다.
// 정사각형을 지웁니다.
```

**인터페이스의 특징:**
- `interface` 키워드로 선언
- 메서드, 속성, 이벤트, 인덱서만 포함 가능 (구현 없음)
- 모든 멤버는 public (접근 제한자 불필요)
- 다중 인터페이스 구현 가능
- 관례상 이름은 'I'로 시작 (예: IDrawable)

### 10.3.2 다중 인터페이스 구현

```csharp
interface IMovable
{
    void Move(int x, int y);
}

interface IRotatable
{
    void Rotate(double angle);
}

interface IScalable
{
    void Scale(double factor);
}

// 여러 인터페이스 동시 구현
class GameObject : IMovable, IRotatable, IScalable
{
    public int X { get; set; }
    public int Y { get; set; }
    public double Angle { get; set; }
    public double Size { get; set; }
    
    public void Move(int x, int y)
    {
        X = x;
        Y = y;
        Console.WriteLine($"위치 이동: ({X}, {Y})");
    }
    
    public void Rotate(double angle)
    {
        Angle = angle;
        Console.WriteLine($"회전: {Angle}도");
    }
    
    public void Scale(double factor)
    {
        Size *= factor;
        Console.WriteLine($"크기 조정: {factor}배");
    }
}

// 사용 예제
GameObject obj = new GameObject { Size = 1.0 };
obj.Move(100, 200);
obj.Rotate(45);
obj.Scale(2.0);

// 인터페이스 타입으로 참조 가능
IMovable movable = obj;
movable.Move(300, 400);

// 출력:
// 위치 이동: (100, 200)
// 회전: 45도
// 크기 조정: 2배
// 위치 이동: (300, 400)
```

### 10.3.3 기본 인터페이스 메서드

C# 8.0부터 인터페이스에 기본 구현을 제공할 수 있습니다.

```csharp
interface ILogger
{
    // 구현이 필요한 메서드
    void Log(string message);
    
    // 기본 구현이 있는 메서드
    void LogError(string error)
    {
        Log($"[오류] {error}");
    }
    
    void LogWarning(string warning)
    {
        Log($"[경고] {warning}");
    }
}

class ConsoleLogger : ILogger
{
    // Log 메서드만 구현하면 됨
    public void Log(string message)
    {
        Console.WriteLine(message);
    }
    
    // LogError, LogWarning은 기본 구현 사용 가능
}

class CustomLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($">> {message}");
    }
    
    // 기본 구현을 오버라이드할 수도 있음
    public void LogError(string error)
    {
        Console.WriteLine($"!!! 오류: {error} !!!");
    }
}

// 사용 예제
ILogger logger1 = new ConsoleLogger();
logger1.Log("일반 메시지");
logger1.LogError("오류 발생");
logger1.LogWarning("주의 필요");

Console.WriteLine();

ILogger logger2 = new CustomLogger();
logger2.Log("일반 메시지");
logger2.LogError("오류 발생");
logger2.LogWarning("주의 필요");

// 출력:
// 일반 메시지
// [오류] 오류 발생
// [경고] 주의 필요
//
// >> 일반 메시지
// !!! 오류: 오류 발생 !!!
// [경고] 주의 필요
```

---

## 10.4 다형성 (Polymorphism)

다형성은 하나의 타입으로 여러 종류의 객체를 참조할 수 있는 능력입니다. 상속과 인터페이스를 통해 다형성을 구현할 수 있습니다.

```csharp
// 기본 클래스
abstract class Employee
{
    public string Name { get; set; }
    public abstract double CalculateSalary();
    
    public void DisplayInfo()
    {
        Console.WriteLine($"이름: {Name}, 급여: {CalculateSalary():C}");
    }
}

class FullTimeEmployee : Employee
{
    public double MonthlySalary { get; set; }
    
    public override double CalculateSalary()
    {
        return MonthlySalary;
    }
}

class PartTimeEmployee : Employee
{
    public double HourlyRate { get; set; }
    public int HoursWorked { get; set; }
    
    public override double CalculateSalary()
    {
        return HourlyRate * HoursWorked;
    }
}

class Contractor : Employee
{
    public double ProjectFee { get; set; }
    
    public override double CalculateSalary()
    {
        return ProjectFee;
    }
}

// 다형성 활용
List<Employee> employees = new List<Employee>
{
    new FullTimeEmployee { Name = "김철수", MonthlySalary = 3000000 },
    new PartTimeEmployee { Name = "이영희", HourlyRate = 15000, HoursWorked = 80 },
    new Contractor { Name = "박민수", ProjectFee = 5000000 }
};

Console.WriteLine("=== 직원 급여 목록 ===");
foreach (Employee emp in employees)
{
    // 각 객체의 실제 타입에 따라 다른 CalculateSalary 메서드 호출
    emp.DisplayInfo();
}

double totalSalary = 0;
foreach (Employee emp in employees)
{
    totalSalary += emp.CalculateSalary();
}
Console.WriteLine($"\n총 급여: {totalSalary:C}");

// 출력:
// === 직원 급여 목록 ===
// 이름: 김철수, 급여: ₩3,000,000.00
// 이름: 이영희, 급여: ₩1,200,000.00
// 이름: 박민수, 급여: ₩5,000,000.00
//
// 총 급여: ₩9,200,000.00
```

**인터페이스를 활용한 다형성:**

```csharp
interface IPayable
{
    double GetPaymentAmount();
}

class Invoice : IPayable
{
    public string PartNumber { get; set; }
    public string PartDescription { get; set; }
    public int Quantity { get; set; }
    public double PricePerItem { get; set; }
    
    public double GetPaymentAmount()
    {
        return Quantity * PricePerItem;
    }
}

class SalariedEmployee : IPayable
{
    public string Name { get; set; }
    public double WeeklySalary { get; set; }
    
    public double GetPaymentAmount()
    {
        return WeeklySalary;
    }
}

// 다형성으로 서로 다른 타입을 동일하게 처리
List<IPayable> payables = new List<IPayable>
{
    new Invoice 
    { 
        PartNumber = "A101", 
        PartDescription = "부품", 
        Quantity = 10, 
        PricePerItem = 5000 
    },
    new SalariedEmployee 
    { 
        Name = "최수정", 
        WeeklySalary = 800000 
    }
};

Console.WriteLine("=== 지불 목록 ===");
foreach (IPayable payable in payables)
{
    Console.WriteLine($"지불 금액: {payable.GetPaymentAmount():C}");
}

// 출력:
// === 지불 목록 ===
// 지불 금액: ₩50,000.00
// 지불 금액: ₩800,000.00
```

**다형성의 장점:**
- 코드의 유연성과 확장성 향상
- 새로운 타입 추가 시 기존 코드 수정 최소화
- 공통 인터페이스로 다양한 객체를 일관되게 처리
- 개방-폐쇄 원칙(Open-Closed Principle) 실현

---

## 마무리

이 장에서는 객체지향 프로그래밍의 핵심인 상속과 다형성에 대해 학습했습니다:

✅ **상속**: 기본 클래스의 기능을 파생 클래스가 재사용하고 확장
✅ **추상 클래스**: 공통 기능과 추상 메서드를 정의하는 템플릿
✅ **인터페이스**: 구현 계약을 정의하고 다중 구현 지원
✅ **다형성**: 하나의 타입으로 여러 형태의 객체를 처리

**다음 단계:**

11장에서는 sealed 클래스, record 타입, 구조체, 열거형 등 고급 객체지향 개념을 다룹니다.
