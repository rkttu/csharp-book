# 17장. 비동기 프로그래밍 기초

비동기 프로그래밍(Asynchronous Programming)은 현대 소프트웨어 개발의 핵심 패러다임 중 하나로, 응답성(Responsiveness)과 확장성(Scalability)을 동시에 달성할 수 있게 해주는 강력한 메커니즘입니다. 웹 API 호출, 파일 I/O, 데이터베이스 쿼리 등 시간이 오래 걸리는 작업을 효율적으로 처리하면서도 애플리케이션이 다른 작업을 계속 수행할 수 있도록 합니다. 이는 단순한 프로그래밍 기법을 넘어, **동시성(Concurrency)**과 **병렬성(Parallelism)**의 개념을 실용적으로 구현하는 방법입니다.

**비동기 프로그래밍의 역사적 발전:**

비동기 프로그래밍의 개념은 1960년대 초 운영체제의 I/O 처리에서 시작되었습니다. 초기 컴퓨터 시스템에서는 CPU가 I/O 작업이 완료될 때까지 대기하는 것이 큰 자원 낭비였고, 이를 해결하기 위해 **인터럽트(Interrupt)** 기반의 비동기 I/O가 개발되었습니다. 1970년대에는 **이벤트 기반 프로그래밍(Event-driven Programming)**이 등장했으며, 1980년대 GUI 프로그래밍의 발전과 함께 **이벤트 루프(Event Loop)** 모델이 확립되었습니다.

프로그래밍 언어 차원에서 비동기 지원은 더디게 진행되었습니다. C와 C++에서는 **콜백(Callback)** 함수를 통해 비동기를 구현했지만, 이는 악명 높은 **콜백 지옥(Callback Hell)**을 야기했습니다. 1990년대 후반 JavaScript의 등장과 2000년대 Node.js의 인기로 비동기 프로그래밍이 주목받기 시작했고, **Promise**와 **Future** 패턴이 발전했습니다.

C#의 비동기 프로그래밍 여정은 다음과 같이 진화했습니다:

- **C# 1.0-4.0 (2002-2010)**: BeginInvoke/EndInvoke 패턴 (APM - Asynchronous Programming Model), BackgroundWorker
- **C# 5.0 (2012)**: `async`와 `await` 키워드 도입 - **혁명적 변화**
- **C# 7.0-8.0 (2017-2019)**: ValueTask, IAsyncEnumerable, async streams
- **C# 9.0-10.0 (2020-2021)**: 개선된 성능과 패턴 매칭

C# 5.0에서 도입된 `async`/`await`는 **Erik Meijer**, **Anders Hejlsberg** 등 Microsoft 연구진의 작업 결과로, **continuation-passing style (CPS)**와 **모나드(Monad)** 이론을 실용적으로 구현한 것입니다. 이는 F#의 **computation expressions**와 Haskell의 **do-notation**에서 영감을 받았으며, 복잡한 비동기 코드를 동기 코드처럼 읽기 쉽게 작성할 수 있게 만들었습니다.

**비동기 프로그래밍의 이론적 기반:**

비동기 프로그래밍은 다음과 같은 컴퓨터 과학의 개념들과 연결되어 있습니다:

1. **동시성(Concurrency)**: 여러 작업이 논리적으로 동시에 진행되는 것처럼 보이는 상태. Rob Pike는 "Concurrency is about dealing with lots of things at once"라고 정의했습니다.

2. **병렬성(Parallelism)**: 여러 작업이 물리적으로 동시에 실행되는 것. "Parallelism is about doing lots of things at once"입니다. 비동기는 주로 동시성에 관한 것이지만, 병렬성도 활용할 수 있습니다.

3. **논블로킹 I/O (Non-blocking I/O)**: 시스템 호출이 즉시 반환되어 스레드가 차단되지 않는 I/O 방식. Linux의 epoll, Windows의 IOCP(I/O Completion Ports) 등이 대표적입니다.

4. **협력적 멀티태스킹(Cooperative Multitasking)**: 작업이 자발적으로 제어권을 넘겨주는 방식. `await`는 협력적 양보(yield) 지점입니다.

5. **연속(Continuation)**: 프로그램의 실행 상태를 나타내는 개념. `await` 이후의 코드는 **continuation**으로 변환됩니다.

**비동기 프로그래밍이 해결하는 문제:**

1. **I/O 바운드 작업의 비효율성**: 전통적인 동기 I/O에서 스레드는 작업이 완료될 때까지 차단됩니다. 웹 서버가 1000개의 요청을 처리한다면 1000개의 스레드가 필요하고, 각 스레드는 약 1MB의 스택 메모리를 소비합니다. 비동기는 소수의 스레드로 수천 개의 동시 연결을 처리할 수 있게 합니다.

2. **UI 응답성**: 데스크톱 애플리케이션에서 UI 스레드가 차단되면 화면이 멈춥니다. 비동기는 UI 스레드를 차단하지 않으면서 백그라운드 작업을 수행할 수 있게 합니다.

3. **확장성(Scalability)**: 클라우드 시대에 서버는 제한된 리소스로 많은 요청을 처리해야 합니다. 비동기는 스레드 풀을 효율적으로 사용하여 **처리량(Throughput)**을 극대화합니다.

4. **복잡한 비동기 로직의 간결성**: 콜백 지옥을 피하고, 순차적 코드처럼 읽히는 비동기 코드를 작성할 수 있습니다.

**C#의 async/await가 특별한 이유:**

C#의 `async`/`await`는 단순한 문법 설탕(Syntactic Sugar)이 아닙니다. 컴파일러는 비동기 메서드를 **상태 머신(State Machine)**으로 변환하며, 이는 다음과 같은 특징을 가집니다:

- **제로 할당(Zero Allocation)**: 대부분의 경우 추가 힙 할당 없이 동작합니다 (ValueTask 사용 시).
- **예외 전파(Exception Propagation)**: 비동기 경계를 넘어 예외가 올바르게 전파됩니다.
- **컨텍스트 캡처(Context Capture)**: SynchronizationContext를 자동으로 캡처하여 UI 스레드로 돌아갑니다.
- **취소 지원(Cancellation Support)**: CancellationToken을 통한 협력적 취소를 지원합니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 비동기 프로그래밍의 이론적 기반과 실용적 구현을 체계적으로 학습하게 됩니다:

- **동기 vs 비동기의 근본적 차이**: 블로킹(Blocking) vs 논블로킹(Non-blocking), 동시성과 병렬성의 개념, 스레드 풀(Thread Pool)의 동작 원리, I/O 바운드 vs CPU 바운드 작업의 구분, 그리고 실제 성능 측정 방법을 이해합니다.

- **async와 await 키워드의 의미론**: 컴파일러가 생성하는 상태 머신의 구조, 연속(Continuation)의 개념, SynchronizationContext와 ConfigureAwait의 역할, 그리고 비동기 메서드의 실행 모델을 깊이 이해합니다.

- **Task와 Task<T>의 내부 구조**: Task의 생명주기와 상태 전환, TaskScheduler의 역할, Task vs ValueTask의 성능 차이, Task 기반 비동기 패턴(TAP), 그리고 Task Parallel Library (TPL)의 활용 방법을 학습합니다.

- **비동기 메서드 작성의 모범 사례**: 비동기 메서드 명명 규칙, 예외 처리 패턴, 데드락(Deadlock) 방지, 비동기 void의 위험성, 그리고 비동기 디스포즈 패턴(IAsyncDisposable)을 배웁니다.

- **비동기 작업 조율(Orchestration)**: Task.WhenAll과 Task.WhenAny의 활용, 병렬 실행과 순차 실행의 선택, 재시도(Retry)와 회로 차단기(Circuit Breaker) 패턴, 그리고 비동기 스트림(IAsyncEnumerable)의 기초를 익힙니다.

**학습 목표:**

- 비동기 프로그래밍의 이론적 기반과 역사적 맥락 이해
- 동시성과 병렬성의 차이, I/O 바운드 vs CPU 바운드 작업 구분
- async/await의 내부 동작 원리와 컴파일러 변환 이해
- Task 기반 비동기 패턴(TAP)의 올바른 사용법 습득
- 비동기 코드의 성능 특성과 최적화 기법 이해
- 실무에서 마주치는 비동기 안티패턴 회피 능력 배양

---

## 17.1 동기 vs 비동기

동기(Synchronous)와 비동기(Asynchronous) 프로그래밍의 차이는 단순한 실행 순서의 문제가 아니라, **제어 흐름(Control Flow)**과 **자원 활용(Resource Utilization)**에 대한 근본적으로 다른 접근 방식입니다. 이 차이를 이해하는 것은 현대 소프트웨어 아키텍처 설계의 핵심입니다.

**컴퓨터 과학적 관점에서의 동기 vs 비동기:**

동기와 비동기의 차이는 **호출자(Caller)**와 **피호출자(Callee)** 사이의 결합도(Coupling)와 관련이 있습니다:

- **동기(Synchronous)**: 호출자는 피호출자가 완료될 때까지 **차단(Blocking)**됩니다. 이는 **긴밀한 시간적 결합(Tight Temporal Coupling)**을 의미하며, 호출 스택(Call Stack)이 유지됩니다.

- **비동기(Asynchronous)**: 호출자는 피호출자의 완료를 기다리지 않고 **즉시 반환(Immediate Return)**됩니다. 이는 **느슨한 시간적 결합(Loose Temporal Coupling)**이며, 완료 통지는 **콜백(Callback)**, **Promise/Future**, 또는 **이벤트(Event)**를 통해 이루어집니다.

**블로킹(Blocking) vs 논블로킹(Non-blocking):**

비동기 프로그래밍을 이해하려면 블로킹과 논블로킹의 개념을 명확히 해야 합니다:

**블로킹 I/O (Synchronous I/O)**는 운영체제 수준에서 시스템 호출이 완료될 때까지 스레드가 **대기 상태(Waiting State)**로 전환되는 것을 의미합니다. 이 동안 스레드는 CPU를 사용하지 않지만, 스레드 자체는 여전히 메모리를 차지하고 컨텍스트 스위칭(Context Switching) 비용이 발생합니다.

```
블로킹 I/O의 스레드 상태:
Thread → Blocked (waiting for I/O) → Ready → Running
         ^^^^^^^^^^^^^^^^^^^^^^
         이 기간 동안 스레드는 "좀비" 상태
```

**논블로킹 I/O (Asynchronous I/O)**는 시스템 호출이 즉시 반환되고, 작업은 백그라운드에서 진행됩니다. 완료는 **폴링(Polling)**, **이벤트 통지(Event Notification)**, 또는 **완료 포트(Completion Port)**를 통해 확인됩니다.

```
논블로킹 I/O의 흐름:
Thread → Initiates I/O → Returns immediately → Does other work
                                               ↓
         I/O Complete Event ← Hardware/OS ← I/O Device
```

Windows의 **IOCP (I/O Completion Ports)**와 Linux의 **epoll/io_uring**은 고성능 비동기 I/O를 위한 운영체제 메커니즘입니다. .NET의 비동기 I/O는 내부적으로 이러한 플랫폼 API를 활용합니다.

### 동기 프로그래밍 (Synchronous Programming)

동기 방식에서는 한 작업이 완료될 때까지 다음 작업이 대기합니다. 이는 **순차적 실행(Sequential Execution)** 모델로, 프로그램의 제어 흐름이 명확하고 예측 가능합니다. 각 명령어는 이전 명령어가 완료된 후에 실행되며, 호출 스택(Call Stack)은 LIFO(Last-In-First-Out) 순서를 유지합니다.

```csharp
// 동기 방식 - 파일 읽기
string content = File.ReadAllText("data.txt");
Console.WriteLine("파일 내용:");
Console.WriteLine(content);
Console.WriteLine("작업 완료");

// 출력:
// 파일 내용:
// (파일의 내용)
// 작업 완료
```

**동기 방식의 문제점:**

```csharp
// 동기 방식으로 여러 파일 읽기
Console.WriteLine("파일 읽기 시작...");

string file1 = File.ReadAllText("file1.txt");  // 완료될 때까지 대기
string file2 = File.ReadAllText("file2.txt");  // 완료될 때까지 대기
string file3 = File.ReadAllText("file3.txt");  // 완료될 때까지 대기

Console.WriteLine("모든 파일 읽기 완료");

// 각 파일을 순차적으로 읽기 때문에 총 시간 = file1 + file2 + file3
```

### 비동기 프로그래밍 (Asynchronous Programming)

비동기 방식에서는 시간이 오래 걸리는 작업을 시작한 후, 완료를 기다리지 않고 다른 작업을 계속 수행할 수 있습니다.

```csharp
// 비동기 방식 - 파일 읽기
string content = await File.ReadAllTextAsync("data.txt");
Console.WriteLine("파일 내용:");
Console.WriteLine(content);
Console.WriteLine("작업 완료");
```

**비동기 방식의 장점:**

```csharp
// 비동기 방식으로 여러 파일 동시에 읽기
Console.WriteLine("파일 읽기 시작...");

Task<string> task1 = File.ReadAllTextAsync("file1.txt");  // 시작하고 계속 진행
Task<string> task2 = File.ReadAllTextAsync("file2.txt");  // 시작하고 계속 진행
Task<string> task3 = File.ReadAllTextAsync("file3.txt");  // 시작하고 계속 진행

// 모든 작업이 완료될 때까지 대기
await Task.WhenAll(task1, task2, task3);

Console.WriteLine("모든 파일 읽기 완료");

// 여러 파일을 동시에 읽기 때문에 총 시간 ≈ max(file1, file2, file3)
```

### 비동기가 필요한 상황

- **I/O 작업**: 파일 읽기/쓰기, 네트워크 통신
- **웹 요청**: HTTP API 호출
- **데이터베이스 쿼리**: 시간이 걸리는 쿼리 실행
- **UI 애플리케이션**: 사용자 인터페이스가 멈추지 않도록 유지

---

## 17.2 async와 await 키워드

C#의 비동기 프로그래밍은 `async`와 `await` 키워드를 중심으로 동작합니다.

### async 키워드

`async` 키워드는 메서드가 비동기 작업을 포함한다는 것을 나타냅니다.

```csharp
async Task ProcessDataAsync()
{
    // 비동기 작업
    await Task.Delay(1000);
    Console.WriteLine("처리 완료");
}
```

**async 메서드의 특징:**
- 메서드 내에서 `await`를 사용할 수 있습니다
- 반환 타입은 `Task`, `Task<T>`, 또는 `void` (이벤트 핸들러만)이어야 합니다
- 메서드 이름은 관례적으로 `Async` 접미사를 붙입니다

### await 키워드

`await` 키워드는 비동기 작업이 완료될 때까지 기다리지만, 스레드를 차단하지 않습니다.

```csharp
async Task DownloadDataAsync()
{
    Console.WriteLine("다운로드 시작...");
    
    // 비동기로 대기 - 스레드는 다른 작업 수행 가능
    await Task.Delay(2000);
    
    Console.WriteLine("다운로드 완료!");
}
```

### 기본 사용 예제

```csharp
// 비동기 메서드 정의
async Task<string> GetGreetingAsync(string name)
{
    // 시뮬레이션: 데이터베이스나 API 호출
    await Task.Delay(1000);
    return $"안녕하세요, {name}님!";
}

// 비동기 메서드 호출
async Task RunAsync()
{
    Console.WriteLine("작업 시작");
    
    string greeting = await GetGreetingAsync("홍길동");
    Console.WriteLine(greeting);
    
    Console.WriteLine("작업 완료");
}

// 출력:
// 작업 시작
// (1초 대기)
// 안녕하세요, 홍길동님!
// 작업 완료
```

### 동기 vs 비동기 비교

```csharp
// 동기 방식
void DownloadSync()
{
    Console.WriteLine("다운로드 시작...");
    Thread.Sleep(2000);  // 스레드 차단
    Console.WriteLine("다운로드 완료!");
}

// 비동기 방식
async Task DownloadAsync()
{
    Console.WriteLine("다운로드 시작...");
    await Task.Delay(2000);  // 스레드 차단 없음
    Console.WriteLine("다운로드 완료!");
}
```

---

## 17.3 Task와 Task<T>

`Task`는 비동기 작업을 나타내는 객체입니다. C#의 비동기 프로그래밍은 Task를 중심으로 동작합니다.

### Task - 값을 반환하지 않는 비동기 작업

`Task`는 반환값이 없는 비동기 작업을 나타냅니다 (void 메서드의 비동기 버전).

```csharp
async Task PrintMessageAsync()
{
    await Task.Delay(1000);
    Console.WriteLine("메시지 출력!");
}

// 호출
await PrintMessageAsync();
```

### Task<T> - 값을 반환하는 비동기 작업

`Task<T>`는 `T` 타입의 값을 반환하는 비동기 작업을 나타냅니다.

```csharp
async Task<int> CalculateAsync(int a, int b)
{
    await Task.Delay(500);
    return a + b;
}

// 호출
int result = await CalculateAsync(10, 20);
Console.WriteLine($"결과: {result}");

// 출력:
// 결과: 30
```

### Task 생성 방법

**1. Task.Run() - CPU 집약적 작업**

```csharp
Task<int> task = Task.Run(() =>
{
    // 시간이 걸리는 계산
    int sum = 0;
    for (int i = 0; i < 1000000; i++)
    {
        sum += i;
    }
    return sum;
});

int result = await task;
Console.WriteLine($"합계: {result}");
```

**2. Task.Delay() - 지연**

```csharp
// 1초 대기
await Task.Delay(1000);

// 지정된 시간만큼 대기
await Task.Delay(TimeSpan.FromSeconds(2));
```

**3. Task.FromResult() - 즉시 완료된 Task**

```csharp
Task<int> GetCachedValue()
{
    int cachedValue = 42;
    return Task.FromResult(cachedValue);
}

int value = await GetCachedValue();
```

### Task의 상태

Task는 다음과 같은 상태를 가질 수 있습니다:

```csharp
Task task = SomeAsyncOperation();

// Task 상태 확인
if (task.IsCompleted)
    Console.WriteLine("작업 완료");

if (task.IsFaulted)
    Console.WriteLine("작업 실패");

if (task.IsCanceled)
    Console.WriteLine("작업 취소됨");
```

---

## 17.4 비동기 메서드 작성하기

비동기 메서드를 올바르게 작성하는 방법을 배웁니다.

### 기본 패턴

```csharp
// 반환값이 없는 비동기 메서드
async Task DoWorkAsync()
{
    await Task.Delay(1000);
    Console.WriteLine("작업 완료");
}

// 반환값이 있는 비동기 메서드
async Task<string> GetDataAsync()
{
    await Task.Delay(1000);
    return "데이터";
}
```

### 실용적인 예제 - 파일 읽기

```csharp
async Task<string> ReadFileAsync(string path)
{
    try
    {
        // 비동기로 파일 읽기
        string content = await File.ReadAllTextAsync(path);
        return content;
    }
    catch (FileNotFoundException)
    {
        Console.WriteLine("파일을 찾을 수 없습니다.");
        return string.Empty;
    }
}

// 사용
string content = await ReadFileAsync("data.txt");
Console.WriteLine(content);
```

### 실용적인 예제 - HTTP 요청

```csharp
async Task<string> DownloadContentAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        try
        {
            string content = await client.GetStringAsync(url);
            return content;
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"다운로드 오류: {ex.Message}");
            return string.Empty;
        }
    }
}

// 사용
string html = await DownloadContentAsync("https://example.com");
Console.WriteLine($"다운로드 크기: {html.Length} 문자");
```

### 여러 비동기 작업 조합

```csharp
async Task<int> GetUserCountAsync()
{
    await Task.Delay(500);
    return 100;
}

async Task<int> GetProductCountAsync()
{
    await Task.Delay(500);
    return 50;
}

async Task<string> GetStatisticsAsync()
{
    // 순차 실행 (총 1초)
    int userCount = await GetUserCountAsync();
    int productCount = await GetProductCountAsync();
    
    return $"사용자: {userCount}, 제품: {productCount}";
}

// 더 나은 방법: 동시 실행
async Task<string> GetStatisticsFastAsync()
{
    // 동시 실행 (총 0.5초)
    Task<int> userTask = GetUserCountAsync();
    Task<int> productTask = GetProductCountAsync();
    
    await Task.WhenAll(userTask, productTask);
    
    return $"사용자: {userTask.Result}, 제품: {productTask.Result}";
}
```

### 비동기 메서드의 반환 타입

**1. Task - 반환값 없음**

```csharp
async Task LogMessageAsync(string message)
{
    await Task.Delay(100);
    Console.WriteLine(message);
}
```

**2. Task<T> - T 타입 반환**

```csharp
async Task<int> AddAsync(int a, int b)
{
    await Task.Delay(100);
    return a + b;
}
```

**3. void - 이벤트 핸들러만 (권장하지 않음)**

```csharp
// 예외 처리가 어려우므로 이벤트 핸들러에서만 사용
async void Button_Click(object sender, EventArgs e)
{
    await DoWorkAsync();
}
```

---

## 17.5 비동기 메서드 호출과 대기

비동기 메서드를 호출하고 결과를 기다리는 다양한 방법을 학습합니다.

### 기본 await 사용

```csharp
async Task RunAsync()
{
    Console.WriteLine("작업 시작");
    
    // 비동기 메서드 호출 및 완료 대기
    await Task.Delay(1000);
    
    Console.WriteLine("작업 완료");
}
```

### 결과값 받기

```csharp
async Task<int> CalculateAsync()
{
    await Task.Delay(500);
    return 42;
}

async Task UseResultAsync()
{
    int result = await CalculateAsync();
    Console.WriteLine($"결과: {result}");
}
```

### 여러 Task 동시에 대기하기

**1. Task.WhenAll - 모든 작업 완료 대기**

```csharp
async Task DownloadAllAsync()
{
    Task task1 = DownloadFileAsync("file1.txt");
    Task task2 = DownloadFileAsync("file2.txt");
    Task task3 = DownloadFileAsync("file3.txt");
    
    // 모든 작업이 완료될 때까지 대기
    await Task.WhenAll(task1, task2, task3);
    
    Console.WriteLine("모든 다운로드 완료!");
}
```

**2. Task.WhenAll - 결과값 수집**

```csharp
async Task<int> GetNumberAsync(int n)
{
    await Task.Delay(100);
    return n * 2;
}

async Task ProcessNumbersAsync()
{
    Task<int>[] tasks = new Task<int>[]
    {
        GetNumberAsync(1),
        GetNumberAsync(2),
        GetNumberAsync(3)
    };
    
    // 모든 작업 완료 후 결과 배열 반환
    int[] results = await Task.WhenAll(tasks);
    
    Console.WriteLine($"결과: {string.Join(", ", results)}");
    // 출력: 결과: 2, 4, 6
}
```

**3. Task.WhenAny - 첫 번째 완료 작업 대기**

```csharp
async Task<string> QueryServerAsync(string serverName, int delay)
{
    await Task.Delay(delay);
    return $"{serverName} 응답";
}

async Task UseFirstResponseAsync()
{
    Task<string> server1 = QueryServerAsync("서버1", 1000);
    Task<string> server2 = QueryServerAsync("서버2", 2000);
    Task<string> server3 = QueryServerAsync("서버3", 1500);
    
    // 가장 먼저 완료되는 작업 대기
    Task<string> firstCompleted = await Task.WhenAny(server1, server2, server3);
    
    string result = await firstCompleted;
    Console.WriteLine($"첫 응답: {result}");
    // 출력: 첫 응답: 서버1 응답
}
```

### 비동기 작업 체이닝

```csharp
async Task<string> Step1Async()
{
    await Task.Delay(500);
    Console.WriteLine("1단계 완료");
    return "데이터1";
}

async Task<string> Step2Async(string input)
{
    await Task.Delay(500);
    Console.WriteLine("2단계 완료");
    return input + " + 데이터2";
}

async Task<string> Step3Async(string input)
{
    await Task.Delay(500);
    Console.WriteLine("3단계 완료");
    return input + " + 데이터3";
}

async Task RunPipelineAsync()
{
    string result1 = await Step1Async();
    string result2 = await Step2Async(result1);
    string result3 = await Step3Async(result2);
    
    Console.WriteLine($"최종 결과: {result3}");
}

// 출력:
// 1단계 완료
// 2단계 완료
// 3단계 완료
// 최종 결과: 데이터1 + 데이터2 + 데이터3
```

### 예외 처리

```csharp
async Task<string> RiskyOperationAsync()
{
    await Task.Delay(500);
    throw new InvalidOperationException("작업 실패!");
}

async Task HandleExceptionAsync()
{
    try
    {
        string result = await RiskyOperationAsync();
        Console.WriteLine(result);
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"오류 처리: {ex.Message}");
    }
}

// 출력:
// 오류 처리: 작업 실패!
```

### 실전 예제 - 여러 파일 동시 처리

```csharp
async Task ProcessFilesAsync(string[] filePaths)
{
    Console.WriteLine($"{filePaths.Length}개 파일 처리 시작...");
    
    // 모든 파일을 동시에 읽기
    Task<string>[] readTasks = filePaths
        .Select(path => File.ReadAllTextAsync(path))
        .ToArray();
    
    try
    {
        // 모든 읽기 작업 완료 대기
        string[] contents = await Task.WhenAll(readTasks);
        
        // 각 파일 내용 처리
        for (int i = 0; i < filePaths.Length; i++)
        {
            Console.WriteLine($"{filePaths[i]}: {contents[i].Length} 문자");
        }
        
        Console.WriteLine("모든 파일 처리 완료!");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"파일 처리 중 오류: {ex.Message}");
    }
}

// 사용
string[] files = { "file1.txt", "file2.txt", "file3.txt" };
await ProcessFilesAsync(files);
```

---

## 17장 정리

이 장에서는 C#의 비동기 프로그래밍 기초를 학습했습니다.

### 핵심 개념

**1. 동기 vs 비동기**
- 동기: 순차적 실행, 작업 완료까지 대기
- 비동기: 동시 실행 가능, 대기 중에도 다른 작업 수행

**2. async와 await**
- `async`: 메서드가 비동기 작업을 포함함을 표시
- `await`: 비동기 작업 완료를 기다리지만 스레드는 차단하지 않음

**3. Task와 Task<T>**
- `Task`: 반환값이 없는 비동기 작업
- `Task<T>`: T 타입을 반환하는 비동기 작업

**4. 비동기 메서드 작성**
- 반환 타입: `Task` 또는 `Task<T>`
- 메서드 이름: `Async` 접미사 사용 권장
- 예외 처리: try-catch 사용 가능

**5. 비동기 작업 조합**
- `Task.WhenAll`: 모든 작업 완료 대기
- `Task.WhenAny`: 첫 번째 완료 작업 대기
- 동시 실행으로 성능 향상

### 비동기 프로그래밍의 장점

- **응답성 향상**: UI가 멈추지 않음
- **성능 개선**: I/O 대기 중 다른 작업 수행
- **리소스 효율**: 스레드를 차단하지 않음
- **확장성**: 더 많은 동시 요청 처리 가능

### 주의사항

- `async void`는 이벤트 핸들러에서만 사용
- 비동기 메서드는 항상 `await`으로 호출
- 예외 처리를 반드시 포함
- CPU 집약적 작업은 `Task.Run()` 사용

### 실전 활용

비동기 프로그래밍은 다음과 같은 경우에 특히 유용합니다:
- 웹 API 호출
- 파일 I/O
- 데이터베이스 쿼리
- 네트워크 통신
- UI 애플리케이션

### 다음 단계

18장에서는 고급 비동기 패턴을 학습하며, 취소 토큰(CancellationToken), 비동기 스트림(IAsyncEnumerable<T>), ConfigureAwait 등의 고급 주제를 다룹니다.

---

## 실습 예제

### 예제 1: 간단한 비동기 다운로드

```csharp
async Task<string> DownloadPageAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        Console.WriteLine($"다운로드 시작: {url}");
        string content = await client.GetStringAsync(url);
        Console.WriteLine($"다운로드 완료: {content.Length} 문자");
        return content;
    }
}

// 사용
string page = await DownloadPageAsync("https://example.com");
```

### 예제 2: 여러 작업 동시 실행

```csharp
async Task<int> ComputeAsync(int value, int delay)
{
    await Task.Delay(delay);
    return value * 2;
}

async Task RunParallelAsync()
{
    var tasks = new[]
    {
        ComputeAsync(1, 1000),
        ComputeAsync(2, 800),
        ComputeAsync(3, 1200)
    };
    
    int[] results = await Task.WhenAll(tasks);
    Console.WriteLine($"결과: {string.Join(", ", results)}");
    // 출력: 결과: 2, 4, 6
}
```

### 예제 3: 파일 처리

```csharp
async Task ProcessLargeFileAsync(string path)
{
    try
    {
        Console.WriteLine("파일 읽기 시작...");
        string content = await File.ReadAllTextAsync(path);
        
        Console.WriteLine("데이터 처리 중...");
        await Task.Delay(1000);  // 처리 시뮬레이션
        
        Console.WriteLine($"처리 완료: {content.Length} 문자");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"오류: {ex.Message}");
    }
}
```

비동기 프로그래밍은 현대 C# 개발의 필수 요소입니다. 이 장에서 배운 기초를 바탕으로 더 복잡한 비동기 패턴을 이해하고 활용할 수 있습니다!
