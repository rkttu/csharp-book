# 13장. 파일 입출력

파일 입출력(File I/O)은 컴퓨터 과학의 가장 근본적이고도 보편적인 작업 중 하나로, 프로그램이 외부 영속 저장 장치(Persistent Storage)와 데이터를 주고받는 모든 활동을 포괄합니다. 폰 노이만 아키텍처(Von Neumann Architecture)에서 정의한 컴퓨터의 기본 구성 요소인 중앙처리장치(CPU), 메모리(Memory), 그리고 입출력 장치(I/O Devices) 중에서, 파일 시스템은 입출력 장치의 가장 핵심적인 추상화 계층입니다. 휘발성 메모리(Volatile Memory)인 RAM에 저장된 데이터는 프로그램 종료나 시스템 재부팅 시 모두 소실되지만, 비휘발성 저장 장치(Non-Volatile Storage)인 하드 디스크, SSD, 또는 네트워크 스토리지에 파일로 저장된 데이터는 영구적으로 보존됩니다.

현대 소프트웨어 시스템에서 파일 입출력은 단순한 데이터 저장을 넘어서, 프로세스 간 통신(Inter-Process Communication, IPC), 설정 관리(Configuration Management), 로깅(Logging), 캐싱(Caching), 데이터 직렬화(Serialization), 그리고 분산 시스템에서의 상태 공유 등 다양한 고수준 추상화의 기반이 됩니다. 사용자 설정 파일, 게임 세이브 데이터, 애플리케이션 로그, 데이터베이스 백업, 문서 파일, 미디어 콘텐츠 등 거의 모든 실용적인 애플리케이션은 파일 시스템과의 복잡한 상호작용을 필요로 합니다.

**파일 시스템의 역사적 진화와 컴퓨터 과학적 토대:**

파일 시스템의 개념은 1960년대 초기 메인프레임 시대에 자기 테이프(Magnetic Tape)와 디스크 드라이브가 보급되면서 태동했습니다. 초기 컴퓨터는 천공 카드(Punched Cards)나 종이 테이프(Paper Tape)를 입출력 매체로 사용했으나, 이들은 순차 접근(Sequential Access)만 가능했고 검색과 수정이 극도로 비효율적이었습니다. 1956년 IBM의 RAMAC(Random Access Method of Accounting and Control)이 최초의 하드 디스크 드라이브를 도입하면서 임의 접근(Random Access) 저장 장치의 시대가 열렸습니다.

1964년 IBM의 OS/360 운영체제는 **계층적 파일 시스템(Hierarchical File System)**의 개념을 정립했으며, 이는 디렉터리(Directory) 구조를 통해 파일을 체계적으로 조직하는 현대 파일 시스템의 근간이 되었습니다. 1969년 켄 톰프슨(Ken Thompson)과 데니스 리치(Dennis Ritchie)가 개발한 Unix 운영체제는 "**모든 것은 파일이다(Everything is a file)**"라는 획기적인 추상화 철학을 도입했습니다. 이 철학에서 일반 파일뿐만 아니라 디렉터리, 디바이스, 파이프, 소켓 등 모든 시스템 리소스를 통일된 파일 인터페이스로 접근할 수 있게 함으로써, 단순하면서도 강력한 프로그래밍 모델을 제공했습니다.

이후 FAT(File Allocation Table, 1977), ext(Extended File System, 1992), NTFS(New Technology File System, 1993), HFS+(Hierarchical File System Plus, 1998), ext4(2008), Btrfs(B-tree File System, 2009) 등 다양한 파일 시스템이 발전해 왔으며, 각각은 저널링(Journaling), 스냅샷(Snapshot), 압축(Compression), 암호화(Encryption), 중복 제거(Deduplication) 등의 고급 기능을 제공하게 되었습니다. 현대의 분산 파일 시스템(Distributed File Systems)인 HDFS(Hadoop Distributed File System), GFS(Google File System), Amazon S3 등은 페타바이트(Petabyte) 규모의 데이터를 수천 대의 서버에 분산하여 저장하고 처리할 수 있는 능력을 제공합니다.

**C#과 .NET의 파일 시스템 추상화:**

C#의 파일 입출력 API는 .NET Framework의 `System.IO` 네임스페이스에 정의되어 있으며, 이는 Common Language Infrastructure(CLI) 명세의 일부로 표준화되어 있습니다. .NET의 파일 시스템 추상화는 Windows의 Win32 API, Linux의 POSIX(Portable Operating System Interface) 시스템 콜, 그리고 macOS의 BSD 계열 인터페이스를 모두 통합하여, 플랫폼 독립적인(Platform-Agnostic) 일관된 프로그래밍 모델을 제공합니다. 이는 **추상화(Abstraction)**의 힘을 극대화한 사례로, 개발자는 운영체제별 세부 구현을 의식하지 않고도 동일한 코드로 Windows, Linux, macOS에서 파일을 다룰 수 있습니다.

.NET의 파일 I/O 아키텍처는 다층 구조(Layered Architecture)로 설계되어 있습니다. 최하위 계층은 운영체제의 네이티브 API(Native API)를 래핑(Wrapping)하는 Platform Abstraction Layer(PAL)이며, 그 위에 스트림(Stream) 기반의 I/O 추상화, 그리고 최상위에 편의 메서드(Convenience Methods)를 제공하는 고수준 API가 위치합니다. 이러한 계층화는 **관심사의 분리(Separation of Concerns)** 원칙을 실현하며, 각 계층은 독립적으로 최적화되고 테스트될 수 있습니다.

**텍스트 파일 vs 바이너리 파일의 이론적 구분:**

파일은 내용의 구조와 의미론(Semantics)에 따라 크게 텍스트 파일(Text File)과 바이너리 파일(Binary File)로 구분됩니다. 이 구분은 단순히 파일 확장자나 MIME 타입으로 결정되는 것이 아니라, 데이터의 인코딩 방식과 해석 의미론에 기반합니다.

**텍스트 파일**은 문자 인코딩 표준(ASCII, UTF-8, UTF-16, ISO-8859 등)에 따라 인코딩된 문자 시퀀스로 구성되며, 텍스트 에디터나 터미널에서 직접 읽고 편집할 수 있는 **사람이 읽을 수 있는(Human-Readable)** 형식입니다. .txt, .csv, .json, .xml, .html, .md, .log, .ini, .yaml 등이 대표적인 텍스트 파일 형식입니다. 텍스트 파일의 핵심 특징은 **플랫폼 간 상호 운용성(Interoperability)**입니다. 표준 인코딩을 사용하므로 서로 다른 운영체제, 프로그래밍 언어, 애플리케이션 간에 데이터를 교환할 수 있으며, 버전 관리 시스템(Git, SVN 등)에서 변경 내역을 추적하기 용이합니다.

반면 **바이너리 파일**은 특정 애플리케이션이나 포맷 명세에 따라 구조화된 이진 데이터(Raw Binary Data)로 구성되며, 전용 프로그램 없이는 해석할 수 없는 **기계가 읽는(Machine-Readable)** 형식입니다. .exe, .dll, .so, .jpg, .png, .mp3, .mp4, .pdf, .docx, .db, .dat 등이 바이너리 파일에 해당합니다. 바이너리 파일의 장점은 **공간 효율성(Space Efficiency)**과 **처리 성능(Processing Performance)**입니다. 텍스트로 "1234567890"을 저장하면 10바이트가 필요하지만, 32비트 정수로 저장하면 4바이트만 필요합니다. 또한 파싱(Parsing) 오버헤드 없이 메모리에 직접 로드하여 사용할 수 있어, 대용량 데이터 처리에 유리합니다.

이 장에서는 주로 텍스트 파일 처리를 다루며, 특히 설정 파일(Configuration Files), 로그 파일(Log Files), 데이터 교환 형식(Data Interchange Formats)인 CSV와 JSON 같은 실용적인 예제를 중심으로 학습합니다. 바이너리 파일 처리는 `BinaryReader`와 `BinaryWriter` 클래스를 통해 수행할 수 있으며, 고급 주제로 다룰 수 있습니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#에서 파일 시스템을 다루는 이론적 토대와 실무적 기법을 종합적으로 습득하게 됩니다:

- **텍스트 파일 읽기의 이론과 실제**: `File.ReadAllText()`, `File.ReadAllLines()`, `StreamReader` 등 다양한 읽기 메커니즘의 내부 동작 원리, 메모리 관리 전략, 그리고 버퍼링(Buffering)과 스트리밍(Streaming)의 성능 특성을 이해합니다. 작은 파일의 원자적(Atomic) 읽기부터 대용량 파일의 메모리 효율적 스트림 처리까지, 각 시나리오에 최적화된 접근 방법을 학습합니다.

- **텍스트 파일 쓰기의 다양한 패러다임**: `File.WriteAllText()`, `File.WriteAllLines()`, `StreamWriter`를 통한 파일 쓰기의 원자성(Atomicity), 내구성(Durability), 그리고 동시성(Concurrency) 이슈를 탐구합니다. 덮어쓰기(Overwrite)와 추가(Append) 모드의 차이, 버퍼 플러싱(Buffer Flushing) 전략, 그리고 트랜잭션 파일 쓰기(Transactional File Writing) 패턴을 이해합니다.

- **파일 시스템 메타데이터 조작과 경로 처리**: `File`, `Directory`, `Path` 클래스를 활용한 파일 시스템 메타데이터 관리, 경로 정규화(Path Normalization), 플랫폼 독립적 경로 처리, 그리고 파일 속성(File Attributes) 및 권한(Permissions) 관리를 배웁니다. 파일 복사, 이동, 삭제의 원자성 보장과 예외 처리 전략을 학습합니다.

- **JSON 직렬화의 현대적 접근**: `System.Text.Json`을 사용한 고성능 JSON 직렬화와 역직렬화의 내부 메커니즘, 타입 안전성(Type Safety), 그리고 스키마 진화(Schema Evolution) 전략을 이해합니다. 객체-관계 매핑(Object-Relational Mapping)과 유사한 객체-JSON 매핑의 원리, 커스텀 컨버터(Custom Converter), 그리고 성능 최적화 기법을 습득합니다.

---

## 13.1 텍스트 파일 읽기

파일 읽기는 파일 입출력의 가장 기본적이면서도 가장 빈번하게 수행되는 작업으로, 프로그램이 외부 데이터를 메모리로 로드하여 처리할 수 있게 하는 핵심 메커니즘입니다. C#과 .NET은 파일 읽기를 위한 계층화된 API를 제공하며, 각 계층은 서로 다른 추상화 수준과 성능 특성을 가집니다. 최상위의 편의 메서드(Convenience Methods)인 `File.ReadAllText()`와 `File.ReadAllLines()`는 간결한 코드로 빠른 개발을 가능하게 하지만, 파일 전체를 메모리에 로드하므로 대용량 파일에는 적합하지 않습니다. 반면 중간 계층의 `StreamReader`는 스트림 기반 읽기를 통해 메모리 효율성을 제공하며, 최하위 계층의 `FileStream`과 `BufferedStream`은 버퍼 크기와 읽기 전략에 대한 세밀한 제어를 가능하게 합니다.

**파일 읽기의 시스템 레벨 동작 원리:**

운영체제 수준에서 파일 읽기는 여러 복잡한 단계를 거칩니다. 먼저 애플리케이션이 파일 열기 시스템 콜(예: Windows의 `CreateFile`, Unix의 `open`)을 호출하면, 운영체제는 파일 경로를 파싱하고 파일 시스템 메타데이터를 조회하여 파일의 물리적 위치(inode, MFT 엔트리 등)를 확인합니다. 파일이 존재하고 권한이 허용되면, 커널은 파일 디스크립터(File Descriptor) 또는 핸들(Handle)을 할당하고 애플리케이션에 반환합니다. 이 디스크립터는 파일의 현재 읽기 위치(File Pointer)와 메타데이터를 관리하는 커널 내부 구조체를 가리킵니다.

실제 데이터 읽기는 여러 단계의 캐싱과 버퍼링을 통해 최적화됩니다. 먼저 운영체제의 **페이지 캐시(Page Cache)** 또는 **버퍼 캐시(Buffer Cache)**를 확인하여, 요청된 데이터가 이미 메모리에 있는지 검사합니다. 캐시 히트(Cache Hit)인 경우 디스크 I/O 없이 메모리에서 직접 데이터를 복사하므로 극도로 빠릅니다(수백 나노초). 캐시 미스(Cache Miss)인 경우 디스크 컨트롤러에 읽기 명령을 보내고, 디스크는 기계적 헤드 이동(HDD의 경우)이나 전자적 셀 접근(SSD의 경우) 후 데이터를 읽어 DMA(Direct Memory Access)를 통해 시스템 메모리로 전송합니다(수 밀리초). 읽어진 데이터는 페이지 캐시에 저장되어 후속 읽기 요청에 재사용됩니다.

.NET의 파일 읽기 클래스들은 이러한 운영체제 메커니즘 위에 추가적인 추상화와 최적화를 제공합니다. `StreamReader`는 내부적으로 고정 크기 버퍼(기본 1KB)를 유지하며, 애플리케이션이 한 줄을 요청하더라도 한 번에 여러 줄을 미리 읽어(Prefetch) 버퍼에 저장합니다. 이는 시스템 콜 오버헤드를 줄이고(Context Switching 최소화), 디스크의 순차 읽기(Sequential Read) 패턴을 활용하여 전체적인 처리량(Throughput)을 향상시킵니다.

**인코딩(Encoding)의 이론적 토대와 실무적 함의:**

텍스트 파일을 읽을 때 가장 중요한 개념이 **문자 인코딩(Character Encoding)**입니다. 컴퓨터는 본질적으로 이진 데이터(Binary Data)만 처리할 수 있으므로, 문자를 숫자로 매핑(Mapping)하는 표준화된 규칙이 필요합니다. 이러한 매핑 체계를 인코딩 또는 문자 집합(Character Set)이라고 합니다.

역사적으로 가장 초기의 표준은 1963년 제정된 **ASCII(American Standard Code for Information Interchange)**입니다. ASCII는 7비트를 사용하여 128개의 문자(영문 대소문자, 숫자, 기본 기호, 제어 문자)를 표현합니다. 그러나 ASCII는 영어권 문자만 지원하므로, 다국어 지원을 위해 ISO-8859 시리즈(Latin-1, Latin-2 등), Windows-1252, EUC-KR(한국어), Shift-JIS(일본어), GB2312(중국어) 등 다양한 8비트 확장 인코딩이 등장했습니다. 이러한 레거시 인코딩들은 각국의 문자를 지원했지만, 서로 호환되지 않아 데이터 교환 시 **문자 깨짐(Mojibake)** 문제를 야기했습니다.

1991년 유니코드 컨소시엄(Unicode Consortium)은 전 세계 모든 문자 체계를 단일 표준으로 통합하는 **유니코드(Unicode)** 표준을 발표했습니다. 유니코드는 현재 약 150,000개 이상의 문자를 정의하며, 각 문자에 고유한 코드 포인트(Code Point, 예: U+AC00은 '가')를 할당합니다. 하지만 유니코드 자체는 추상적인 문자 집합일 뿐이며, 실제로 바이트 시퀀스로 인코딩하기 위해서는 **UTF(Unicode Transformation Format)** 인코딩 방식이 필요합니다.

**UTF-8**은 현대 인터넷과 소프트웨어 개발의 사실상 표준(De Facto Standard) 인코딩으로, 가변 길이(Variable-Length) 인코딩 방식입니다. ASCII 문자(U+0000~U+007F)는 1바이트로 표현되어 ASCII와 완전히 호환되며, 한글과 한자는 3바이트, 이모지와 고대 문자는 4바이트로 표현됩니다. UTF-8의 장점은 **공간 효율성**(영어 중심 텍스트에서 최소 메모리 사용), **견고성**(중간에 바이트가 손실되어도 자가 동기화 가능), 그리고 **바이트 순서 독립성**(Byte Order Independence, BOM 불필요)입니다.

**UTF-16**은 .NET 내부에서 문자열을 표현하는 인코딩으로, 대부분의 문자를 2바이트로 표현하지만 일부 문자(Supplementary Characters, U+10000 이상)는 4바이트(서로게이트 쌍, Surrogate Pair)로 표현합니다. UTF-16의 장점은 대부분의 현대 언어 문자에 대해 **고정 너비(Fixed-Width)** 처리가 가능하여 인덱싱이 빠르다는 점이지만, ASCII 호환성이 없고 바이트 순서(Byte Order, Endianness)에 따라 UTF-16LE(Little-Endian)와 UTF-16BE(Big-Endian)로 구분되어 BOM(Byte Order Mark)이 필요할 수 있습니다.

.NET의 파일 읽기 메서드는 기본적으로 UTF-8 인코딩을 사용하지만, `Encoding` 클래스를 통해 다양한 인코딩을 명시적으로 지정할 수 있습니다. 레거시 시스템이나 외부 데이터와의 통합 시, 올바른 인코딩을 지정하지 않으면 **문자 손실(Character Loss)**이나 **잘못된 문자 표시(Character Corruption)**가 발생할 수 있으므로, 인코딩에 대한 정확한 이해가 필수적입니다.

### 13.1.1 File.ReadAllText()

`File.ReadAllText()` 메서드는 .NET의 파일 읽기 API 중 가장 높은 추상화 수준을 제공하는 정적 메서드로, 파일의 전체 내용을 단일 문자열(Single String)로 원자적(Atomically)으로 읽어옵니다. 이 메서드는 내부적으로 파일을 열고, 모든 바이트를 읽고, 지정된 인코딩으로 디코딩하고, 파일을 닫는 일련의 과정을 캡슐화하여, 단 한 줄의 코드로 완전한 파일 읽기 작업을 수행할 수 있게 합니다.

**내부 동작 메커니즘과 메모리 할당 전략:**

`File.ReadAllText()`의 내부 구현은 효율성과 안전성을 모두 고려하여 설계되었습니다. 메서드는 먼저 `FileInfo`를 통해 파일의 크기를 조회한 후, 정확한 크기의 문자 배열(Character Array)을 미리 할당합니다. 이는 **사전 할당(Pre-Allocation)** 전략으로, 동적 배열 확장(Dynamic Array Expansion)의 오버헤드를 회피하고 메모리 단편화(Memory Fragmentation)를 최소화합니다. 파일 크기가 2GB(Int32.MaxValue) 이하인 경우, 단일 연속 메모리 블록에 전체 내용을 로드할 수 있습니다.

읽기 작업은 `FileStream`을 사용하며, 운영체제의 파일 캐시를 최대한 활용하기 위해 순차 접근(Sequential Access) 힌트를 제공합니다. 데이터는 내부 버퍼를 통해 효율적으로 읽히며, `Encoding.GetString()` 메서드를 통해 바이트 배열이 문자열로 변환됩니다. 이 과정에서 UTF-8의 경우 SIMD(Single Instruction Multiple Data) 명령어를 활용한 벡터화 디코딩(Vectorized Decoding)이 수행되어 성능이 극대화됩니다.

중요한 점은 `File.ReadAllText()`가 **비버퍼링(Unbuffered)** 방식이 아니라는 것입니다. 내부적으로는 여전히 버퍼를 사용하지만, 이는 메서드 호출자에게 투명(Transparent)하게 처리됩니다. 또한 파일은 읽기가 완료되면 자동으로 닫히며, 예외가 발생하더라도 `finally` 블록을 통해 리소스가 안전하게 해제됩니다. 이는 **RAII(Resource Acquisition Is Initialization)** 패턴의 C# 구현으로, 리소스 누수(Resource Leak)를 방지합니다.

**성능 특성과 적용 시나리오:**

`File.ReadAllText()`의 시간 복잡도는 O(n)으로, 여기서 n은 파일의 바이트 크기입니다. 공간 복잡도도 O(n)으로, 파일 크기와 동일한 메모리를 사용합니다. 이는 작은 파일(일반적으로 수 MB 이하)에 대해서는 이상적이지만, 대용량 파일의 경우 메모리 부족(Out of Memory) 예외를 발생시킬 수 있습니다. .NET의 힙(Heap)은 단일 객체 크기를 2GB로 제한하므로, 이를 초과하는 파일은 이 메서드로 읽을 수 없습니다.

또 다른 고려사항은 **가비지 컬렉션(Garbage Collection)** 압력입니다. 큰 문자열은 LOH(Large Object Heap, 85,000바이트 이상의 객체가 할당되는 특수한 힙 영역)에 할당되며, LOH는 일반 힙과 달리 압축(Compaction)되지 않아 메모리 단편화를 야기할 수 있습니다. 빈번한 대용량 파일 읽기는 Gen 2 가비지 컬렉션을 유발하여 애플리케이션 일시 정지(Application Pause)를 초래할 수 있습니다.

따라서 `File.ReadAllText()`는 다음 시나리오에 가장 적합합니다:
- **설정 파일(Configuration Files)**: JSON, XML, INI, YAML 등 일반적으로 수 KB ~ 수백 KB 크기
- **작은 데이터 파일**: 캐시 데이터, 세션 정보, 임시 데이터 등
- **전체 내용 분석**: 정규 표현식 매칭, 전체 텍스트 검색 등 파일 전체를 메모리에 로드해야 하는 경우
- **원자적 읽기가 필요한 경우**: 파일 내용의 일관성(Consistency)이 중요한 경우

**기본 사용법:**

```csharp
// 파일 전체를 문자열로 읽기
string content = File.ReadAllText("sample.txt");
Console.WriteLine(content);
```

**파일이 존재하는지 확인:**

파일을 읽기 전에 파일이 존재하는지 확인하는 것이 좋은 습관입니다. `File.Exists()` 메서드를 사용하여 파일 존재 여부를 체크할 수 있습니다.

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    string content = File.ReadAllText(filePath);
    Console.WriteLine($"파일 내용:\n{content}");
}
else
{
    Console.WriteLine("파일을 찾을 수 없습니다.");
}
```

**인코딩 지정:**

기본적으로 UTF-8 인코딩을 사용하지만, 다른 인코딩이 필요한 경우 명시적으로 지정할 수 있습니다.

```csharp
using System.Text;

// EUC-KR 인코딩으로 읽기 (한국어 레거시 파일)
string content = File.ReadAllText("legacy.txt", Encoding.GetEncoding("euc-kr"));
Console.WriteLine(content);
```

**실용 예제 - 설정 파일 읽기:**

```csharp
string configPath = "config.txt";

if (File.Exists(configPath))
{
    string config = File.ReadAllText(configPath);
    Console.WriteLine("=== 설정 정보 ===");
    Console.WriteLine(config);
}
else
{
    Console.WriteLine("설정 파일이 없습니다. 기본 설정을 사용합니다.");
}
```

**장점과 한계:**

- **장점**: 코드가 매우 간단하고 직관적입니다.
- **한계**: 파일 전체를 메모리에 로드하므로, 큰 파일(수백 MB 이상)은 메모리 부족을 초래할 수 있습니다.

### 13.1.2 File.ReadAllLines()

`File.ReadAllLines()` 메서드는 파일의 각 줄을 문자열 배열의 요소로 읽어옵니다. 줄 단위로 처리해야 하는 CSV 파일이나 로그 파일을 읽을 때 유용합니다.

**기본 사용법:**

```csharp
string[] lines = File.ReadAllLines("data.txt");

Console.WriteLine($"총 {lines.Length}줄");

foreach (string line in lines)
{
    Console.WriteLine(line);
}
```

**실용 예제 - CSV 파일 읽기:**

```csharp
string csvPath = "students.csv";

if (File.Exists(csvPath))
{
    string[] lines = File.ReadAllLines(csvPath);
    
    // 첫 줄은 헤더로 처리
    Console.WriteLine("=== 학생 목록 ===");
    
    for (int i = 1; i < lines.Length; i++)
    {
        string[] fields = lines[i].Split(',');
        string name = fields[0];
        string age = fields[1];
        string grade = fields[2];
        
        Console.WriteLine($"{name} ({age}세, {grade}학년)");
    }
}
```

**줄 번호와 함께 출력:**

```csharp
string[] lines = File.ReadAllLines("source.cs");

for (int i = 0; i < lines.Length; i++)
{
    Console.WriteLine($"{i + 1,4}: {lines[i]}");
}
```

**빈 줄 제거:**

```csharp
string[] lines = File.ReadAllLines("data.txt");

// 빈 줄이 아닌 것만 필터링
string[] nonEmptyLines = lines
    .Where(line => !string.IsNullOrWhiteSpace(line))
    .ToArray();

Console.WriteLine($"유효한 줄: {nonEmptyLines.Length}개");
```

### 13.1.3 StreamReader 사용

`StreamReader`는 파일을 스트림 방식으로 읽는 클래스로, 큰 파일을 효율적으로 처리할 수 있습니다. 파일 전체를 메모리에 로드하지 않고 필요한 만큼만 읽기 때문에 메모리 효율적입니다.

**기본 사용법 - using 문:**

`StreamReader`는 `IDisposable` 인터페이스를 구현하므로, `using` 문을 사용하여 자동으로 리소스를 해제해야 합니다.

```csharp
using (StreamReader reader = new StreamReader("large.txt"))
{
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        Console.WriteLine(line);
    }
}
```

**C# 8.0 이후의 간결한 using 선언:**

```csharp
using StreamReader reader = new StreamReader("data.txt");

string line;
while ((line = reader.ReadLine()) != null)
{
    Console.WriteLine(line);
}
// 메서드 종료 시 자동으로 Dispose 호출
```

**파일 전체를 한 번에 읽기:**

```csharp
using StreamReader reader = new StreamReader("file.txt");
string content = reader.ReadToEnd();
Console.WriteLine(content);
```

**실용 예제 - 로그 파일 분석:**

```csharp
string logPath = "application.log";
int errorCount = 0;
int warningCount = 0;

if (File.Exists(logPath))
{
    using StreamReader reader = new StreamReader(logPath);
    
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        if (line.Contains("[ERROR]"))
        {
            errorCount++;
            Console.WriteLine($"에러: {line}");
        }
        else if (line.Contains("[WARNING]"))
        {
            warningCount++;
        }
    }
    
    Console.WriteLine($"\n총 에러: {errorCount}개");
    Console.WriteLine($"총 경고: {warningCount}개");
}
```

**조건에 맞는 줄만 읽기:**

```csharp
using StreamReader reader = new StreamReader("data.txt");

string line;
int lineNumber = 0;

while ((line = reader.ReadLine()) != null)
{
    lineNumber++;
    
    // 특정 키워드가 포함된 줄만 출력
    if (line.Contains("중요"))
    {
        Console.WriteLine($"줄 {lineNumber}: {line}");
    }
}
```

**StreamReader의 장점:**

- **메모리 효율**: 파일을 한 번에 로드하지 않으므로 큰 파일도 처리 가능
- **유연성**: 줄 단위, 문자 단위, 블록 단위로 다양하게 읽을 수 있음
- **제어 가능**: 읽기 위치를 제어하고 조건부로 읽기를 중단할 수 있음

---

## 13.2 텍스트 파일 쓰기

파일 쓰기는 프로그램의 데이터를 영구적으로 저장하는 작업입니다. 사용자 설정, 게임 진행 상황, 로그 기록 등을 파일로 저장할 수 있습니다. C#은 파일 쓰기를 위한 여러 방법을 제공하며, 읽기와 마찬가지로 간단한 방법부터 세밀한 제어가 가능한 방법까지 다양합니다.

**파일 쓰기 시 주의사항:**

파일을 쓸 때는 기존 파일을 덮어쓸지(overwrite), 내용을 추가할지(append)를 결정해야 합니다. 또한 파일 경로의 디렉터리가 존재하지 않으면 예외가 발생하므로, 필요한 경우 디렉터리를 먼저 생성해야 합니다.

### 13.2.1 File.WriteAllText()

`File.WriteAllText()` 메서드는 문자열을 파일에 씁니다. 파일이 이미 존재하면 내용을 덮어쓰고, 없으면 새로 생성합니다.

**기본 사용법:**

```csharp
string content = "안녕하세요, C# 파일 입출력입니다.";
File.WriteAllText("output.txt", content);

Console.WriteLine("파일이 저장되었습니다.");
```

**여러 줄 쓰기:**

```csharp
string content = @"첫 번째 줄
두 번째 줄
세 번째 줄";

File.WriteAllText("multiline.txt", content);
```

**실용 예제 - 사용자 설정 저장:**

```csharp
string username = "홍길동";
string theme = "다크 모드";
int fontSize = 14;

string config = $@"사용자명: {username}
테마: {theme}
폰트 크기: {fontSize}";

File.WriteAllText("config.txt", config);
Console.WriteLine("설정이 저장되었습니다.");
```

**기존 파일 덮어쓰기:**

```csharp
// 기존 파일이 있으면 덮어쓰기
File.WriteAllText("data.txt", "새로운 내용");
Console.WriteLine("파일이 덮어쓰기되었습니다.");
```

**인코딩 지정:**

```csharp
using System.Text;

string content = "한글 내용입니다.";

// UTF-8 (BOM 없음) 인코딩으로 저장
File.WriteAllText("output.txt", content, new UTF8Encoding(false));
```

### 13.2.2 File.WriteAllLines()

`File.WriteAllLines()` 메서드는 문자열 배열을 파일에 씁니다. 각 배열 요소가 파일의 한 줄이 됩니다.

**기본 사용법:**

```csharp
string[] lines = new string[]
{
    "첫 번째 줄",
    "두 번째 줄",
    "세 번째 줄"
};

File.WriteAllLines("lines.txt", lines);
Console.WriteLine("파일이 저장되었습니다.");
```

**실용 예제 - 학생 명단 저장:**

```csharp
string[] students = new string[]
{
    "이름,나이,학년",
    "홍길동,20,3",
    "김철수,19,2",
    "이영희,21,4"
};

File.WriteAllLines("students.csv", students);
Console.WriteLine("학생 명단이 저장되었습니다.");
```

**컬렉션에서 파일 생성:**

```csharp
List<string> logMessages = new List<string>();
logMessages.Add($"[{DateTime.Now}] 프로그램 시작");
logMessages.Add($"[{DateTime.Now}] 데이터 로딩 완료");
logMessages.Add($"[{DateTime.Now}] 처리 완료");

File.WriteAllLines("log.txt", logMessages);
```

**LINQ를 사용한 데이터 변환:**

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };

// 숫자를 문자열로 변환하여 파일에 저장
string[] lines = numbers.Select(n => $"숫자: {n}").ToArray();
File.WriteAllLines("numbers.txt", lines);
```

### 13.2.3 StreamWriter 사용

`StreamWriter`는 파일에 데이터를 스트림 방식으로 쓰는 클래스입니다. 대용량 데이터를 쓰거나, 파일에 내용을 추가(append)하거나, 세밀한 제어가 필요할 때 사용합니다.

**기본 사용법 - 새 파일 생성:**

```csharp
using (StreamWriter writer = new StreamWriter("output.txt"))
{
    writer.WriteLine("첫 번째 줄");
    writer.WriteLine("두 번째 줄");
    writer.WriteLine("세 번째 줄");
}

Console.WriteLine("파일이 저장되었습니다.");
```

**C# 8.0 이후의 간결한 using 선언:**

```csharp
using StreamWriter writer = new StreamWriter("data.txt");

writer.WriteLine("Hello, World!");
writer.WriteLine("C# 파일 쓰기");
// 메서드 종료 시 자동으로 Dispose 호출
```

**파일에 내용 추가 (Append):**

두 번째 매개변수를 `true`로 설정하면 기존 파일 끝에 내용을 추가합니다.

```csharp
using (StreamWriter writer = new StreamWriter("log.txt", append: true))
{
    writer.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 새 로그 항목");
}

Console.WriteLine("로그가 추가되었습니다.");
```

**실용 예제 - 로그 파일 작성:**

```csharp
void WriteLog(string message, string level = "INFO")
{
    string logPath = "application.log";
    
    using StreamWriter writer = new StreamWriter(logPath, append: true);
    
    string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
    writer.WriteLine($"[{timestamp}] [{level}] {message}");
}

// 로그 작성
WriteLog("애플리케이션 시작");
WriteLog("데이터베이스 연결 성공");
WriteLog("파일 처리 완료");
WriteLog("메모리 부족", "WARNING");
WriteLog("치명적 오류 발생", "ERROR");
```

**실용 예제 - 보고서 생성:**

```csharp
string reportPath = "report.txt";

using StreamWriter writer = new StreamWriter(reportPath);

writer.WriteLine("=== 월간 보고서 ===");
writer.WriteLine($"생성 날짜: {DateTime.Now:yyyy년 MM월 dd일}");
writer.WriteLine();
writer.WriteLine("주요 지표:");
writer.WriteLine($"  - 사용자 수: 1,234명");
writer.WriteLine($"  - 매출액: ₩5,678,000");
writer.WriteLine($"  - 성장률: 12.5%");
writer.WriteLine();
writer.WriteLine("=== 보고서 끝 ===");

Console.WriteLine("보고서가 생성되었습니다.");
```

**대용량 데이터 쓰기:**

```csharp
using StreamWriter writer = new StreamWriter("large.txt");

// 반복문으로 대량의 데이터 쓰기
for (int i = 1; i <= 100000; i++)
{
    writer.WriteLine($"줄 번호: {i}");
}

Console.WriteLine("대용량 파일이 생성되었습니다.");
```

**Write vs WriteLine:**

```csharp
using StreamWriter writer = new StreamWriter("test.txt");

writer.Write("줄바꿈 없음 ");
writer.Write("계속 같은 줄 ");
writer.WriteLine("이제 줄바꿈");
writer.WriteLine("새로운 줄");

// 결과:
// 줄바꿈 없음 계속 같은 줄 이제 줄바꿈
// 새로운 줄
```

---

## 13.3 파일과 디렉터리 관리

파일을 읽고 쓰는 것 외에도, 파일 시스템을 관리하는 작업이 필요합니다. 파일 복사, 이동, 삭제, 디렉터리 생성, 경로 조작 등의 작업을 C#의 `File`, `Directory`, `Path` 클래스를 통해 수행할 수 있습니다.

### 13.3.1 File 클래스

`File` 클래스는 파일에 대한 다양한 작업을 수행하는 정적 메서드를 제공합니다.

**파일 존재 확인:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    Console.WriteLine("파일이 존재합니다.");
}
else
{
    Console.WriteLine("파일이 없습니다.");
}
```

**파일 복사:**

```csharp
string source = "original.txt";
string destination = "backup.txt";

if (File.Exists(source))
{
    File.Copy(source, destination, overwrite: true);
    Console.WriteLine("파일이 복사되었습니다.");
}
```

**파일 이동 (이름 변경):**

```csharp
string oldPath = "old_name.txt";
string newPath = "new_name.txt";

if (File.Exists(oldPath))
{
    File.Move(oldPath, newPath);
    Console.WriteLine("파일이 이동되었습니다.");
}
```

**파일 삭제:**

```csharp
string filePath = "temp.txt";

if (File.Exists(filePath))
{
    File.Delete(filePath);
    Console.WriteLine("파일이 삭제되었습니다.");
}
```

**파일 정보 가져오기:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    FileInfo info = new FileInfo(filePath);
    
    Console.WriteLine($"파일명: {info.Name}");
    Console.WriteLine($"전체 경로: {info.FullName}");
    Console.WriteLine($"크기: {info.Length} 바이트");
    Console.WriteLine($"생성 날짜: {info.CreationTime}");
    Console.WriteLine($"마지막 수정: {info.LastWriteTime}");
}
```

**파일 속성 확인:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    FileAttributes attrs = File.GetAttributes(filePath);
    
    bool isReadOnly = (attrs & FileAttributes.ReadOnly) == FileAttributes.ReadOnly;
    bool isHidden = (attrs & FileAttributes.Hidden) == FileAttributes.Hidden;
    
    Console.WriteLine($"읽기 전용: {isReadOnly}");
    Console.WriteLine($"숨김: {isHidden}");
}
```

### 13.3.2 Directory 클래스

`Directory` 클래스는 디렉터리(폴더)에 대한 작업을 수행하는 정적 메서드를 제공합니다.

**디렉터리 존재 확인:**

```csharp
string dirPath = "data";

if (Directory.Exists(dirPath))
{
    Console.WriteLine("디렉터리가 존재합니다.");
}
else
{
    Console.WriteLine("디렉터리가 없습니다.");
}
```

**디렉터리 생성:**

```csharp
string dirPath = "output";

if (!Directory.Exists(dirPath))
{
    Directory.CreateDirectory(dirPath);
    Console.WriteLine("디렉터리가 생성되었습니다.");
}
```

**디렉터리 삭제:**

```csharp
string dirPath = "temp";

if (Directory.Exists(dirPath))
{
    // recursive: true는 하위 파일/폴더도 모두 삭제
    Directory.Delete(dirPath, recursive: true);
    Console.WriteLine("디렉터리가 삭제되었습니다.");
}
```

**디렉터리 내 파일 목록:**

```csharp
string dirPath = ".";  // 현재 디렉터리

string[] files = Directory.GetFiles(dirPath);

Console.WriteLine("=== 파일 목록 ===");
foreach (string file in files)
{
    Console.WriteLine(Path.GetFileName(file));
}
```

**특정 패턴의 파일 검색:**

```csharp
// .txt 파일만 검색
string[] textFiles = Directory.GetFiles(".", "*.txt");

Console.WriteLine("=== 텍스트 파일 ===");
foreach (string file in textFiles)
{
    Console.WriteLine(Path.GetFileName(file));
}
```

**하위 디렉터리 목록:**

```csharp
string dirPath = ".";

string[] subdirs = Directory.GetDirectories(dirPath);

Console.WriteLine("=== 하위 디렉터리 ===");
foreach (string dir in subdirs)
{
    Console.WriteLine(Path.GetFileName(dir));
}
```

**재귀적으로 모든 파일 검색:**

```csharp
string dirPath = ".";

// 모든 하위 디렉터리를 포함하여 검색
string[] allFiles = Directory.GetFiles(dirPath, "*.*", SearchOption.AllDirectories);

Console.WriteLine($"총 {allFiles.Length}개의 파일");
```

**실용 예제 - 백업 디렉터리 생성:**

```csharp
string backupDir = $"backup_{DateTime.Now:yyyyMMdd_HHmmss}";

Directory.CreateDirectory(backupDir);

// 현재 디렉터리의 .txt 파일을 백업 디렉터리로 복사
string[] files = Directory.GetFiles(".", "*.txt");

foreach (string file in files)
{
    string fileName = Path.GetFileName(file);
    string destPath = Path.Combine(backupDir, fileName);
    File.Copy(file, destPath);
}

Console.WriteLine($"{files.Length}개의 파일이 백업되었습니다.");
```

### 13.3.3 Path 클래스

`Path` 클래스는 파일 경로 문자열을 조작하는 유틸리티 메서드를 제공합니다. 플랫폼 독립적인 경로 처리를 가능하게 합니다.

**경로 결합:**

```csharp
string dir = "data";
string file = "config.txt";

// 플랫폼에 맞는 경로 구분자를 자동으로 사용
string fullPath = Path.Combine(dir, file);
Console.WriteLine(fullPath);  // data/config.txt (Linux) 또는 data\config.txt (Windows)
```

**파일명 추출:**

```csharp
string path = "/home/user/documents/file.txt";

string fileName = Path.GetFileName(path);
Console.WriteLine(fileName);  // file.txt
```

**확장자 추출:**

```csharp
string path = "document.txt";

string ext = Path.GetExtension(path);
Console.WriteLine(ext);  // .txt
```

**확장자 제거:**

```csharp
string path = "photo.jpg";

string nameWithoutExt = Path.GetFileNameWithoutExtension(path);
Console.WriteLine(nameWithoutExt);  // photo
```

**디렉터리 경로 추출:**

```csharp
string path = "/home/user/documents/file.txt";

string dir = Path.GetDirectoryName(path);
Console.WriteLine(dir);  // /home/user/documents
```

**확장자 변경:**

```csharp
string path = "document.txt";

string newPath = Path.ChangeExtension(path, ".pdf");
Console.WriteLine(newPath);  // document.pdf
```

**임시 파일 경로 생성:**

```csharp
// 시스템의 임시 디렉터리 경로
string tempDir = Path.GetTempPath();
Console.WriteLine($"임시 디렉터리: {tempDir}");

// 고유한 임시 파일명 생성
string tempFile = Path.GetTempFileName();
Console.WriteLine($"임시 파일: {tempFile}");
```

**경로 유효성 검사:**

```csharp
string path = "data/file.txt";

// 경로가 절대 경로인지 확인
bool isAbsolute = Path.IsPathRooted(path);
Console.WriteLine($"절대 경로: {isAbsolute}");  // False
```

**실용 예제 - 안전한 파일 경로 생성:**

```csharp
string CreateSafeFilePath(string directory, string fileName)
{
    // 디렉터리가 없으면 생성
    if (!Directory.Exists(directory))
    {
        Directory.CreateDirectory(directory);
    }
    
    // 경로 결합
    string filePath = Path.Combine(directory, fileName);
    
    // 파일이 이미 존재하면 번호 추가
    if (File.Exists(filePath))
    {
        string nameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
        string ext = Path.GetExtension(fileName);
        int counter = 1;
        
        do
        {
            fileName = $"{nameWithoutExt}_{counter}{ext}";
            filePath = Path.Combine(directory, fileName);
            counter++;
        } while (File.Exists(filePath));
    }
    
    return filePath;
}

// 사용
string safePath = CreateSafeFilePath("output", "data.txt");
File.WriteAllText(safePath, "테스트 데이터");
Console.WriteLine($"파일 저장됨: {safePath}");
```

---

## 13.4 JSON 데이터 처리

JSON(JavaScript Object Notation)은 데이터를 저장하고 전송하기 위한 경량 텍스트 형식으로, 현대 웹 개발과 API 통신에서 사실상의 표준입니다. C# 객체를 JSON으로 변환하거나, JSON을 C# 객체로 변환하는 작업을 **직렬화(Serialization)**와 **역직렬화(Deserialization)**라고 합니다.

**JSON의 역사와 장점:**

JSON은 2001년 더글러스 크록포드(Douglas Crockford)가 제안한 데이터 형식으로, XML의 복잡성을 개선하여 단순하고 읽기 쉬운 형식을 제공합니다. 사람이 읽을 수 있고(human-readable), 기계가 파싱하기 쉬우며(machine-parsable), 언어 독립적이라는 장점이 있습니다.

### 13.4.1 System.Text.Json 소개

.NET Core 3.0부터 `System.Text.Json` 네임스페이스가 기본 JSON 라이브러리로 제공됩니다. 이전에는 Newtonsoft.Json(Json.NET)을 많이 사용했지만, 이제는 고성능의 내장 라이브러리를 사용할 수 있습니다.

**System.Text.Json의 특징:**

- **고성능**: 최신 .NET의 Span<T>과 Memory<T>를 활용한 제로 할당 파싱
- **보안**: 기본적으로 안전한 설정 (깊은 중첩 제한, 큰 문자열 제한 등)
- **경량**: 추가 패키지 설치 없이 기본 제공
- **현대적**: 최신 C# 기능(nullable reference types, records 등)과 잘 통합

**네임스페이스 추가:**

```csharp
using System.Text.Json;
```

### 13.4.2 JSON 직렬화

직렬화(Serialization)는 C# 객체를 JSON 문자열로 변환하는 과정입니다. 객체의 상태를 텍스트 형식으로 저장하여 파일에 쓰거나 네트워크로 전송할 수 있습니다.

**기본 클래스 정의:**

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
}
```

**객체를 JSON 문자열로 변환:**

```csharp
using System.Text.Json;

Person person = new Person
{
    Name = "홍길동",
    Age = 30,
    Email = "hong@example.com"
};

// 직렬화
string json = JsonSerializer.Serialize(person);
Console.WriteLine(json);

// 출력: {"Name":"홍길동","Age":30,"Email":"hong@example.com"}
```

**가독성 있는 JSON 생성 (들여쓰기):**

```csharp
var options = new JsonSerializerOptions
{
    WriteIndented = true  // 들여쓰기 활성화
};

string json = JsonSerializer.Serialize(person, options);
Console.WriteLine(json);

// 출력:
// {
//   "Name": "홍길동",
//   "Age": 30,
//   "Email": "hong@example.com"
// }
```

**컬렉션 직렬화:**

```csharp
List<Person> people = new List<Person>
{
    new Person { Name = "홍길동", Age = 30, Email = "hong@example.com" },
    new Person { Name = "김철수", Age = 25, Email = "kim@example.com" },
    new Person { Name = "이영희", Age = 28, Email = "lee@example.com" }
};

var options = new JsonSerializerOptions { WriteIndented = true };
string json = JsonSerializer.Serialize(people, options);

Console.WriteLine(json);
```

**JSON 파일로 저장:**

```csharp
Person person = new Person
{
    Name = "홍길동",
    Age = 30,
    Email = "hong@example.com"
};

var options = new JsonSerializerOptions { WriteIndented = true };
string json = JsonSerializer.Serialize(person, options);

File.WriteAllText("person.json", json);
Console.WriteLine("JSON 파일이 저장되었습니다.");
```

**실용 예제 - 게임 설정 저장:**

```csharp
class GameSettings
{
    public string PlayerName { get; set; }
    public int Level { get; set; }
    public int Score { get; set; }
    public bool SoundEnabled { get; set; }
}

void SaveGameSettings(GameSettings settings)
{
    var options = new JsonSerializerOptions { WriteIndented = true };
    string json = JsonSerializer.Serialize(settings, options);
    File.WriteAllText("game_settings.json", json);
    Console.WriteLine("게임 설정이 저장되었습니다.");
}

// 사용
GameSettings settings = new GameSettings
{
    PlayerName = "플레이어1",
    Level = 5,
    Score = 1250,
    SoundEnabled = true
};

SaveGameSettings(settings);
```

### 13.4.3 JSON 역직렬화

역직렬화(Deserialization)는 JSON 문자열을 C# 객체로 변환하는 과정입니다. 파일이나 네트워크에서 받은 JSON 데이터를 프로그램에서 사용할 수 있는 객체로 복원합니다.

**JSON 문자열을 객체로 변환:**

```csharp
string json = @"{
    ""Name"": ""홍길동"",
    ""Age"": 30,
    ""Email"": ""hong@example.com""
}";

// 역직렬화
Person person = JsonSerializer.Deserialize<Person>(json);

Console.WriteLine($"이름: {person.Name}");
Console.WriteLine($"나이: {person.Age}");
Console.WriteLine($"이메일: {person.Email}");
```

**JSON 파일에서 읽기:**

```csharp
if (File.Exists("person.json"))
{
    string json = File.ReadAllText("person.json");
    Person person = JsonSerializer.Deserialize<Person>(json);
    
    Console.WriteLine($"이름: {person.Name}");
    Console.WriteLine($"나이: {person.Age}");
}
```

**컬렉션 역직렬화:**

```csharp
string json = @"[
    {""Name"":""홍길동"",""Age"":30,""Email"":""hong@example.com""},
    {""Name"":""김철수"",""Age"":25,""Email"":""kim@example.com""}
]";

List<Person> people = JsonSerializer.Deserialize<List<Person>>(json);

foreach (var person in people)
{
    Console.WriteLine($"{person.Name} ({person.Age}세)");
}
```

**실용 예제 - 게임 설정 불러오기:**

```csharp
GameSettings LoadGameSettings()
{
    string settingsPath = "game_settings.json";
    
    if (File.Exists(settingsPath))
    {
        string json = File.ReadAllText(settingsPath);
        GameSettings settings = JsonSerializer.Deserialize<GameSettings>(json);
        Console.WriteLine("게임 설정을 불러왔습니다.");
        return settings;
    }
    else
    {
        Console.WriteLine("설정 파일이 없습니다. 기본 설정을 사용합니다.");
        return new GameSettings
        {
            PlayerName = "플레이어",
            Level = 1,
            Score = 0,
            SoundEnabled = true
        };
    }
}

// 사용
GameSettings settings = LoadGameSettings();
Console.WriteLine($"플레이어: {settings.PlayerName}");
Console.WriteLine($"레벨: {settings.Level}");
Console.WriteLine($"점수: {settings.Score}");
```

**null 안전성 처리:**

```csharp
string json = @"{""Name"":""홍길동""}";  // Age와 Email 누락

Person? person = JsonSerializer.Deserialize<Person>(json);

if (person != null)
{
    Console.WriteLine($"이름: {person.Name}");
    Console.WriteLine($"나이: {person.Age}");  // 0 (기본값)
    Console.WriteLine($"이메일: {person.Email ?? "(없음)"}");
}
```

**예외 처리:**

```csharp
string json = @"{잘못된 JSON}";

try
{
    Person person = JsonSerializer.Deserialize<Person>(json);
}
catch (JsonException ex)
{
    Console.WriteLine($"JSON 파싱 오류: {ex.Message}");
}
```

**실용 예제 - 완전한 설정 관리 시스템:**

```csharp
class AppConfig
{
    public string AppName { get; set; }
    public string Version { get; set; }
    public Dictionary<string, string> Settings { get; set; }
}

class ConfigManager
{
    private const string ConfigPath = "app_config.json";
    
    public static void SaveConfig(AppConfig config)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        string json = JsonSerializer.Serialize(config, options);
        File.WriteAllText(ConfigPath, json);
        Console.WriteLine("설정이 저장되었습니다.");
    }
    
    public static AppConfig LoadConfig()
    {
        if (File.Exists(ConfigPath))
        {
            string json = File.ReadAllText(ConfigPath);
            return JsonSerializer.Deserialize<AppConfig>(json);
        }
        else
        {
            // 기본 설정 생성
            return new AppConfig
            {
                AppName = "MyApp",
                Version = "1.0.0",
                Settings = new Dictionary<string, string>
                {
                    { "Theme", "Light" },
                    { "Language", "ko-KR" }
                }
            };
        }
    }
}

// 사용 예제
AppConfig config = ConfigManager.LoadConfig();
Console.WriteLine($"앱: {config.AppName} v{config.Version}");

// 설정 수정
config.Settings["Theme"] = "Dark";
ConfigManager.SaveConfig(config);
```

---

## 13장 정리 및 요약

이 장에서는 C#에서 파일 시스템과 상호작용하는 다양한 방법을 학습했습니다.

### 핵심 개념 정리

1. **텍스트 파일 읽기**
   - `File.ReadAllText()`: 파일 전체를 문자열로 읽기 (작은 파일)
   - `File.ReadAllLines()`: 파일을 줄 단위 배열로 읽기 (CSV, 로그)
   - `StreamReader`: 큰 파일을 효율적으로 읽기 (스트림 방식)

2. **텍스트 파일 쓰기**
   - `File.WriteAllText()`: 문자열을 파일로 저장 (덮어쓰기)
   - `File.WriteAllLines()`: 문자열 배열을 파일로 저장
   - `StreamWriter`: 대용량 파일 쓰기, 내용 추가(append) 가능

3. **파일과 디렉터리 관리**
   - `File` 클래스: 복사, 이동, 삭제, 정보 조회
   - `Directory` 클래스: 디렉터리 생성, 삭제, 파일 목록
   - `Path` 클래스: 경로 문자열 조작 (결합, 추출, 변경)

4. **JSON 데이터 처리**
   - `System.Text.Json`: 고성능 JSON 라이브러리
   - 직렬화: C# 객체 → JSON 문자열
   - 역직렬화: JSON 문자열 → C# 객체

### 실습 문제

#### 문제 1: 할 일 목록 관리

할 일을 파일에 저장하고 불러오는 프로그램을 작성하세요.

```csharp
void SaveTodoList(List<string> todos)
{
    File.WriteAllLines("todos.txt", todos);
    Console.WriteLine("할 일이 저장되었습니다.");
}

List<string> LoadTodoList()
{
    if (File.Exists("todos.txt"))
    {
        return new List<string>(File.ReadAllLines("todos.txt"));
    }
    return new List<string>();
}

// 사용
List<string> todos = LoadTodoList();
todos.Add("C# 공부하기");
todos.Add("파일 입출력 연습");
todos.Add("프로젝트 완성");

SaveTodoList(todos);

// 불러와서 출력
List<string> loadedTodos = LoadTodoList();
Console.WriteLine("=== 할 일 목록 ===");
for (int i = 0; i < loadedTodos.Count; i++)
{
    Console.WriteLine($"{i + 1}. {loadedTodos[i]}");
}
```

#### 문제 2: 점수 기록 시스템

학생들의 점수를 JSON 파일로 저장하고 불러오는 시스템을 작성하세요.

```csharp
using System.Text.Json;

class Student
{
    public string Name { get; set; }
    public int Score { get; set; }
}

void SaveScores(List<Student> students)
{
    var options = new JsonSerializerOptions { WriteIndented = true };
    string json = JsonSerializer.Serialize(students, options);
    File.WriteAllText("scores.json", json);
    Console.WriteLine("점수가 저장되었습니다.");
}

List<Student> LoadScores()
{
    if (File.Exists("scores.json"))
    {
        string json = File.ReadAllText("scores.json");
        return JsonSerializer.Deserialize<List<Student>>(json);
    }
    return new List<Student>();
}

// 사용
List<Student> students = new List<Student>
{
    new Student { Name = "홍길동", Score = 85 },
    new Student { Name = "김철수", Score = 92 },
    new Student { Name = "이영희", Score = 78 }
};

SaveScores(students);

// 불러와서 평균 계산
List<Student> loadedStudents = LoadScores();
double average = loadedStudents.Average(s => s.Score);

Console.WriteLine("=== 학생 점수 ===");
foreach (var student in loadedStudents)
{
    Console.WriteLine($"{student.Name}: {student.Score}점");
}
Console.WriteLine($"평균: {average:F2}점");
```

#### 문제 3: 로그 시스템

타임스탬프가 포함된 로그를 파일에 추가하는 시스템을 작성하세요.

```csharp
class Logger
{
    private const string LogPath = "app.log";
    
    public static void Log(string message, string level = "INFO")
    {
        string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        string logEntry = $"[{timestamp}] [{level}] {message}";
        
        // 파일에 추가
        using StreamWriter writer = new StreamWriter(LogPath, append: true);
        writer.WriteLine(logEntry);
        
        // 콘솔에도 출력
        Console.WriteLine(logEntry);
    }
    
    public static void ShowLogs()
    {
        if (File.Exists(LogPath))
        {
            Console.WriteLine("=== 로그 기록 ===");
            string[] lines = File.ReadAllLines(LogPath);
            foreach (string line in lines)
            {
                Console.WriteLine(line);
            }
        }
    }
}

// 사용
Logger.Log("프로그램 시작");
Logger.Log("데이터 로딩 완료");
Logger.Log("경고: 메모리 사용량 높음", "WARNING");
Logger.Log("에러 발생: 파일 없음", "ERROR");

Console.WriteLine();
Logger.ShowLogs();
```

### 다음 장 예고

14장 "LINQ 기초"에서는 데이터 컬렉션을 효율적으로 쿼리하고 변환하는 강력한 기능을 학습합니다:
- LINQ란 무엇인가?
- Where, Select, OrderBy 등 기본 연산자
- 컬렉션과 파일 데이터를 우아하게 처리하는 방법

파일에서 읽은 데이터를 LINQ로 필터링하고 가공하는 등, 이번 장에서 배운 파일 입출력과 결합하면 더욱 강력한 프로그램을 만들 수 있습니다!
