# 13장. 파일 입출력

파일 입출력(File I/O)은 프로그램이 외부 저장 장치와 데이터를 주고받는 작업으로, 현대 소프트웨어의 핵심 기능 중 하나입니다. 메모리에 저장된 데이터는 프로그램이 종료되면 사라지지만, 파일로 저장하면 영구적으로 보존할 수 있습니다. 사용자 설정, 게임 세이브 파일, 로그 기록, 데이터베이스 백업 등 거의 모든 실용적인 애플리케이션은 파일 시스템과의 상호작용이 필요합니다.

**파일 시스템의 역사적 배경:**

파일 시스템의 개념은 1960년대 초기 컴퓨터 시스템에서 자기 테이프와 디스크 드라이브가 등장하면서 시작되었습니다. 1964년 IBM의 OS/360이 계층적 파일 시스템을 도입했고, 1969년 Unix가 "모든 것은 파일이다(Everything is a file)"라는 철학을 정립하면서 현대 파일 시스템의 기초가 마련되었습니다. 이후 FAT, NTFS, ext 시리즈 등 다양한 파일 시스템이 발전해 왔습니다.

C#의 파일 입출력 API는 .NET Framework의 `System.IO` 네임스페이스에 정의되어 있으며, Windows, Linux, macOS 등 다양한 운영체제에서 일관된 방식으로 파일을 다룰 수 있도록 설계되었습니다. 이는 **추상화(Abstraction)**를 통해 플랫폼 간 차이를 숨기고 통일된 인터페이스를 제공하는 .NET의 철학을 반영합니다.

**텍스트 파일 vs 바이너리 파일:**

파일은 크게 텍스트 파일과 바이너리 파일로 구분됩니다. 텍스트 파일(.txt, .csv, .json, .xml 등)은 사람이 읽을 수 있는 문자로 구성되어 있어 텍스트 에디터로 열어볼 수 있습니다. 반면 바이너리 파일(.exe, .dll, .jpg, .mp3 등)은 기계가 직접 처리하는 이진 데이터로 구성되어 있어 전용 프로그램이 필요합니다. 이 장에서는 주로 텍스트 파일 처리를 다루며, 특히 설정 파일이나 로그 파일 같은 실용적인 예제를 중심으로 학습합니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#에서 파일 시스템을 다루는 기본적이면서도 실용적인 기법들을 익히게 됩니다:

- **텍스트 파일 읽기**: `File.ReadAllText()`, `File.ReadAllLines()`, `StreamReader`를 사용하여 파일의 내용을 읽는 방법을 학습합니다.

- **텍스트 파일 쓰기**: `File.WriteAllText()`, `File.WriteAllLines()`, `StreamWriter`를 사용하여 파일에 데이터를 저장하는 방법을 익힙니다.

- **파일과 디렉터리 관리**: `File`, `Directory`, `Path` 클래스를 활용하여 파일 시스템을 조작하는 방법을 배웁니다.

- **JSON 데이터 처리**: `System.Text.Json`을 사용하여 구조화된 데이터를 JSON 형식으로 직렬화하고 역직렬화하는 방법을 학습합니다.

---

## 13.1 텍스트 파일 읽기

파일을 읽는 것은 파일 입출력의 첫 번째 단계입니다. C#은 파일 읽기를 위한 여러 방법을 제공하며, 각각은 특정 사용 사례에 최적화되어 있습니다. 작은 파일을 한 번에 읽을 때는 `File` 클래스의 정적 메서드가 편리하고, 큰 파일을 처리할 때는 `StreamReader`를 사용하여 메모리 효율적으로 읽을 수 있습니다.

**인코딩(Encoding)의 이해:**

텍스트 파일을 읽을 때 중요한 개념이 **인코딩(Encoding)**입니다. 컴퓨터는 모든 데이터를 0과 1의 이진수로 저장하므로, 문자를 숫자로 변환하는 규칙이 필요합니다. UTF-8은 현대의 표준 인코딩으로, 영어는 1바이트, 한글은 3바이트로 표현합니다. .NET의 파일 읽기 메서드는 기본적으로 UTF-8을 사용하지만, 다른 인코딩을 지정할 수도 있습니다.

### 13.1.1 File.ReadAllText()

`File.ReadAllText()` 메서드는 파일의 전체 내용을 하나의 문자열로 읽어옵니다. 작은 파일을 간단하게 읽을 때 가장 편리한 방법입니다.

**기본 사용법:**

```csharp
// 파일 전체를 문자열로 읽기
string content = File.ReadAllText("sample.txt");
Console.WriteLine(content);
```

**파일이 존재하는지 확인:**

파일을 읽기 전에 파일이 존재하는지 확인하는 것이 좋은 습관입니다. `File.Exists()` 메서드를 사용하여 파일 존재 여부를 체크할 수 있습니다.

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    string content = File.ReadAllText(filePath);
    Console.WriteLine($"파일 내용:\n{content}");
}
else
{
    Console.WriteLine("파일을 찾을 수 없습니다.");
}
```

**인코딩 지정:**

기본적으로 UTF-8 인코딩을 사용하지만, 다른 인코딩이 필요한 경우 명시적으로 지정할 수 있습니다.

```csharp
using System.Text;

// EUC-KR 인코딩으로 읽기 (한국어 레거시 파일)
string content = File.ReadAllText("legacy.txt", Encoding.GetEncoding("euc-kr"));
Console.WriteLine(content);
```

**실용 예제 - 설정 파일 읽기:**

```csharp
string configPath = "config.txt";

if (File.Exists(configPath))
{
    string config = File.ReadAllText(configPath);
    Console.WriteLine("=== 설정 정보 ===");
    Console.WriteLine(config);
}
else
{
    Console.WriteLine("설정 파일이 없습니다. 기본 설정을 사용합니다.");
}
```

**장점과 한계:**

- **장점**: 코드가 매우 간단하고 직관적입니다.
- **한계**: 파일 전체를 메모리에 로드하므로, 큰 파일(수백 MB 이상)은 메모리 부족을 초래할 수 있습니다.

### 13.1.2 File.ReadAllLines()

`File.ReadAllLines()` 메서드는 파일의 각 줄을 문자열 배열의 요소로 읽어옵니다. 줄 단위로 처리해야 하는 CSV 파일이나 로그 파일을 읽을 때 유용합니다.

**기본 사용법:**

```csharp
string[] lines = File.ReadAllLines("data.txt");

Console.WriteLine($"총 {lines.Length}줄");

foreach (string line in lines)
{
    Console.WriteLine(line);
}
```

**실용 예제 - CSV 파일 읽기:**

```csharp
string csvPath = "students.csv";

if (File.Exists(csvPath))
{
    string[] lines = File.ReadAllLines(csvPath);
    
    // 첫 줄은 헤더로 처리
    Console.WriteLine("=== 학생 목록 ===");
    
    for (int i = 1; i < lines.Length; i++)
    {
        string[] fields = lines[i].Split(',');
        string name = fields[0];
        string age = fields[1];
        string grade = fields[2];
        
        Console.WriteLine($"{name} ({age}세, {grade}학년)");
    }
}
```

**줄 번호와 함께 출력:**

```csharp
string[] lines = File.ReadAllLines("source.cs");

for (int i = 0; i < lines.Length; i++)
{
    Console.WriteLine($"{i + 1,4}: {lines[i]}");
}
```

**빈 줄 제거:**

```csharp
string[] lines = File.ReadAllLines("data.txt");

// 빈 줄이 아닌 것만 필터링
string[] nonEmptyLines = lines
    .Where(line => !string.IsNullOrWhiteSpace(line))
    .ToArray();

Console.WriteLine($"유효한 줄: {nonEmptyLines.Length}개");
```

### 13.1.3 StreamReader 사용

`StreamReader`는 파일을 스트림 방식으로 읽는 클래스로, 큰 파일을 효율적으로 처리할 수 있습니다. 파일 전체를 메모리에 로드하지 않고 필요한 만큼만 읽기 때문에 메모리 효율적입니다.

**기본 사용법 - using 문:**

`StreamReader`는 `IDisposable` 인터페이스를 구현하므로, `using` 문을 사용하여 자동으로 리소스를 해제해야 합니다.

```csharp
using (StreamReader reader = new StreamReader("large.txt"))
{
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        Console.WriteLine(line);
    }
}
```

**C# 8.0 이후의 간결한 using 선언:**

```csharp
using StreamReader reader = new StreamReader("data.txt");

string line;
while ((line = reader.ReadLine()) != null)
{
    Console.WriteLine(line);
}
// 메서드 종료 시 자동으로 Dispose 호출
```

**파일 전체를 한 번에 읽기:**

```csharp
using StreamReader reader = new StreamReader("file.txt");
string content = reader.ReadToEnd();
Console.WriteLine(content);
```

**실용 예제 - 로그 파일 분석:**

```csharp
string logPath = "application.log";
int errorCount = 0;
int warningCount = 0;

if (File.Exists(logPath))
{
    using StreamReader reader = new StreamReader(logPath);
    
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        if (line.Contains("[ERROR]"))
        {
            errorCount++;
            Console.WriteLine($"에러: {line}");
        }
        else if (line.Contains("[WARNING]"))
        {
            warningCount++;
        }
    }
    
    Console.WriteLine($"\n총 에러: {errorCount}개");
    Console.WriteLine($"총 경고: {warningCount}개");
}
```

**조건에 맞는 줄만 읽기:**

```csharp
using StreamReader reader = new StreamReader("data.txt");

string line;
int lineNumber = 0;

while ((line = reader.ReadLine()) != null)
{
    lineNumber++;
    
    // 특정 키워드가 포함된 줄만 출력
    if (line.Contains("중요"))
    {
        Console.WriteLine($"줄 {lineNumber}: {line}");
    }
}
```

**StreamReader의 장점:**

- **메모리 효율**: 파일을 한 번에 로드하지 않으므로 큰 파일도 처리 가능
- **유연성**: 줄 단위, 문자 단위, 블록 단위로 다양하게 읽을 수 있음
- **제어 가능**: 읽기 위치를 제어하고 조건부로 읽기를 중단할 수 있음

---

## 13.2 텍스트 파일 쓰기

파일 쓰기는 프로그램의 데이터를 영구적으로 저장하는 작업입니다. 사용자 설정, 게임 진행 상황, 로그 기록 등을 파일로 저장할 수 있습니다. C#은 파일 쓰기를 위한 여러 방법을 제공하며, 읽기와 마찬가지로 간단한 방법부터 세밀한 제어가 가능한 방법까지 다양합니다.

**파일 쓰기 시 주의사항:**

파일을 쓸 때는 기존 파일을 덮어쓸지(overwrite), 내용을 추가할지(append)를 결정해야 합니다. 또한 파일 경로의 디렉터리가 존재하지 않으면 예외가 발생하므로, 필요한 경우 디렉터리를 먼저 생성해야 합니다.

### 13.2.1 File.WriteAllText()

`File.WriteAllText()` 메서드는 문자열을 파일에 씁니다. 파일이 이미 존재하면 내용을 덮어쓰고, 없으면 새로 생성합니다.

**기본 사용법:**

```csharp
string content = "안녕하세요, C# 파일 입출력입니다.";
File.WriteAllText("output.txt", content);

Console.WriteLine("파일이 저장되었습니다.");
```

**여러 줄 쓰기:**

```csharp
string content = @"첫 번째 줄
두 번째 줄
세 번째 줄";

File.WriteAllText("multiline.txt", content);
```

**실용 예제 - 사용자 설정 저장:**

```csharp
string username = "홍길동";
string theme = "다크 모드";
int fontSize = 14;

string config = $@"사용자명: {username}
테마: {theme}
폰트 크기: {fontSize}";

File.WriteAllText("config.txt", config);
Console.WriteLine("설정이 저장되었습니다.");
```

**기존 파일 덮어쓰기:**

```csharp
// 기존 파일이 있으면 덮어쓰기
File.WriteAllText("data.txt", "새로운 내용");
Console.WriteLine("파일이 덮어쓰기되었습니다.");
```

**인코딩 지정:**

```csharp
using System.Text;

string content = "한글 내용입니다.";

// UTF-8 (BOM 없음) 인코딩으로 저장
File.WriteAllText("output.txt", content, new UTF8Encoding(false));
```

### 13.2.2 File.WriteAllLines()

`File.WriteAllLines()` 메서드는 문자열 배열을 파일에 씁니다. 각 배열 요소가 파일의 한 줄이 됩니다.

**기본 사용법:**

```csharp
string[] lines = new string[]
{
    "첫 번째 줄",
    "두 번째 줄",
    "세 번째 줄"
};

File.WriteAllLines("lines.txt", lines);
Console.WriteLine("파일이 저장되었습니다.");
```

**실용 예제 - 학생 명단 저장:**

```csharp
string[] students = new string[]
{
    "이름,나이,학년",
    "홍길동,20,3",
    "김철수,19,2",
    "이영희,21,4"
};

File.WriteAllLines("students.csv", students);
Console.WriteLine("학생 명단이 저장되었습니다.");
```

**컬렉션에서 파일 생성:**

```csharp
List<string> logMessages = new List<string>();
logMessages.Add($"[{DateTime.Now}] 프로그램 시작");
logMessages.Add($"[{DateTime.Now}] 데이터 로딩 완료");
logMessages.Add($"[{DateTime.Now}] 처리 완료");

File.WriteAllLines("log.txt", logMessages);
```

**LINQ를 사용한 데이터 변환:**

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };

// 숫자를 문자열로 변환하여 파일에 저장
string[] lines = numbers.Select(n => $"숫자: {n}").ToArray();
File.WriteAllLines("numbers.txt", lines);
```

### 13.2.3 StreamWriter 사용

`StreamWriter`는 파일에 데이터를 스트림 방식으로 쓰는 클래스입니다. 대용량 데이터를 쓰거나, 파일에 내용을 추가(append)하거나, 세밀한 제어가 필요할 때 사용합니다.

**기본 사용법 - 새 파일 생성:**

```csharp
using (StreamWriter writer = new StreamWriter("output.txt"))
{
    writer.WriteLine("첫 번째 줄");
    writer.WriteLine("두 번째 줄");
    writer.WriteLine("세 번째 줄");
}

Console.WriteLine("파일이 저장되었습니다.");
```

**C# 8.0 이후의 간결한 using 선언:**

```csharp
using StreamWriter writer = new StreamWriter("data.txt");

writer.WriteLine("Hello, World!");
writer.WriteLine("C# 파일 쓰기");
// 메서드 종료 시 자동으로 Dispose 호출
```

**파일에 내용 추가 (Append):**

두 번째 매개변수를 `true`로 설정하면 기존 파일 끝에 내용을 추가합니다.

```csharp
using (StreamWriter writer = new StreamWriter("log.txt", append: true))
{
    writer.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] 새 로그 항목");
}

Console.WriteLine("로그가 추가되었습니다.");
```

**실용 예제 - 로그 파일 작성:**

```csharp
void WriteLog(string message, string level = "INFO")
{
    string logPath = "application.log";
    
    using StreamWriter writer = new StreamWriter(logPath, append: true);
    
    string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
    writer.WriteLine($"[{timestamp}] [{level}] {message}");
}

// 로그 작성
WriteLog("애플리케이션 시작");
WriteLog("데이터베이스 연결 성공");
WriteLog("파일 처리 완료");
WriteLog("메모리 부족", "WARNING");
WriteLog("치명적 오류 발생", "ERROR");
```

**실용 예제 - 보고서 생성:**

```csharp
string reportPath = "report.txt";

using StreamWriter writer = new StreamWriter(reportPath);

writer.WriteLine("=== 월간 보고서 ===");
writer.WriteLine($"생성 날짜: {DateTime.Now:yyyy년 MM월 dd일}");
writer.WriteLine();
writer.WriteLine("주요 지표:");
writer.WriteLine($"  - 사용자 수: 1,234명");
writer.WriteLine($"  - 매출액: ₩5,678,000");
writer.WriteLine($"  - 성장률: 12.5%");
writer.WriteLine();
writer.WriteLine("=== 보고서 끝 ===");

Console.WriteLine("보고서가 생성되었습니다.");
```

**대용량 데이터 쓰기:**

```csharp
using StreamWriter writer = new StreamWriter("large.txt");

// 반복문으로 대량의 데이터 쓰기
for (int i = 1; i <= 100000; i++)
{
    writer.WriteLine($"줄 번호: {i}");
}

Console.WriteLine("대용량 파일이 생성되었습니다.");
```

**Write vs WriteLine:**

```csharp
using StreamWriter writer = new StreamWriter("test.txt");

writer.Write("줄바꿈 없음 ");
writer.Write("계속 같은 줄 ");
writer.WriteLine("이제 줄바꿈");
writer.WriteLine("새로운 줄");

// 결과:
// 줄바꿈 없음 계속 같은 줄 이제 줄바꿈
// 새로운 줄
```

---

## 13.3 파일과 디렉터리 관리

파일을 읽고 쓰는 것 외에도, 파일 시스템을 관리하는 작업이 필요합니다. 파일 복사, 이동, 삭제, 디렉터리 생성, 경로 조작 등의 작업을 C#의 `File`, `Directory`, `Path` 클래스를 통해 수행할 수 있습니다.

### 13.3.1 File 클래스

`File` 클래스는 파일에 대한 다양한 작업을 수행하는 정적 메서드를 제공합니다.

**파일 존재 확인:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    Console.WriteLine("파일이 존재합니다.");
}
else
{
    Console.WriteLine("파일이 없습니다.");
}
```

**파일 복사:**

```csharp
string source = "original.txt";
string destination = "backup.txt";

if (File.Exists(source))
{
    File.Copy(source, destination, overwrite: true);
    Console.WriteLine("파일이 복사되었습니다.");
}
```

**파일 이동 (이름 변경):**

```csharp
string oldPath = "old_name.txt";
string newPath = "new_name.txt";

if (File.Exists(oldPath))
{
    File.Move(oldPath, newPath);
    Console.WriteLine("파일이 이동되었습니다.");
}
```

**파일 삭제:**

```csharp
string filePath = "temp.txt";

if (File.Exists(filePath))
{
    File.Delete(filePath);
    Console.WriteLine("파일이 삭제되었습니다.");
}
```

**파일 정보 가져오기:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    FileInfo info = new FileInfo(filePath);
    
    Console.WriteLine($"파일명: {info.Name}");
    Console.WriteLine($"전체 경로: {info.FullName}");
    Console.WriteLine($"크기: {info.Length} 바이트");
    Console.WriteLine($"생성 날짜: {info.CreationTime}");
    Console.WriteLine($"마지막 수정: {info.LastWriteTime}");
}
```

**파일 속성 확인:**

```csharp
string filePath = "data.txt";

if (File.Exists(filePath))
{
    FileAttributes attrs = File.GetAttributes(filePath);
    
    bool isReadOnly = (attrs & FileAttributes.ReadOnly) == FileAttributes.ReadOnly;
    bool isHidden = (attrs & FileAttributes.Hidden) == FileAttributes.Hidden;
    
    Console.WriteLine($"읽기 전용: {isReadOnly}");
    Console.WriteLine($"숨김: {isHidden}");
}
```

### 13.3.2 Directory 클래스

`Directory` 클래스는 디렉터리(폴더)에 대한 작업을 수행하는 정적 메서드를 제공합니다.

**디렉터리 존재 확인:**

```csharp
string dirPath = "data";

if (Directory.Exists(dirPath))
{
    Console.WriteLine("디렉터리가 존재합니다.");
}
else
{
    Console.WriteLine("디렉터리가 없습니다.");
}
```

**디렉터리 생성:**

```csharp
string dirPath = "output";

if (!Directory.Exists(dirPath))
{
    Directory.CreateDirectory(dirPath);
    Console.WriteLine("디렉터리가 생성되었습니다.");
}
```

**디렉터리 삭제:**

```csharp
string dirPath = "temp";

if (Directory.Exists(dirPath))
{
    // recursive: true는 하위 파일/폴더도 모두 삭제
    Directory.Delete(dirPath, recursive: true);
    Console.WriteLine("디렉터리가 삭제되었습니다.");
}
```

**디렉터리 내 파일 목록:**

```csharp
string dirPath = ".";  // 현재 디렉터리

string[] files = Directory.GetFiles(dirPath);

Console.WriteLine("=== 파일 목록 ===");
foreach (string file in files)
{
    Console.WriteLine(Path.GetFileName(file));
}
```

**특정 패턴의 파일 검색:**

```csharp
// .txt 파일만 검색
string[] textFiles = Directory.GetFiles(".", "*.txt");

Console.WriteLine("=== 텍스트 파일 ===");
foreach (string file in textFiles)
{
    Console.WriteLine(Path.GetFileName(file));
}
```

**하위 디렉터리 목록:**

```csharp
string dirPath = ".";

string[] subdirs = Directory.GetDirectories(dirPath);

Console.WriteLine("=== 하위 디렉터리 ===");
foreach (string dir in subdirs)
{
    Console.WriteLine(Path.GetFileName(dir));
}
```

**재귀적으로 모든 파일 검색:**

```csharp
string dirPath = ".";

// 모든 하위 디렉터리를 포함하여 검색
string[] allFiles = Directory.GetFiles(dirPath, "*.*", SearchOption.AllDirectories);

Console.WriteLine($"총 {allFiles.Length}개의 파일");
```

**실용 예제 - 백업 디렉터리 생성:**

```csharp
string backupDir = $"backup_{DateTime.Now:yyyyMMdd_HHmmss}";

Directory.CreateDirectory(backupDir);

// 현재 디렉터리의 .txt 파일을 백업 디렉터리로 복사
string[] files = Directory.GetFiles(".", "*.txt");

foreach (string file in files)
{
    string fileName = Path.GetFileName(file);
    string destPath = Path.Combine(backupDir, fileName);
    File.Copy(file, destPath);
}

Console.WriteLine($"{files.Length}개의 파일이 백업되었습니다.");
```

### 13.3.3 Path 클래스

`Path` 클래스는 파일 경로 문자열을 조작하는 유틸리티 메서드를 제공합니다. 플랫폼 독립적인 경로 처리를 가능하게 합니다.

**경로 결합:**

```csharp
string dir = "data";
string file = "config.txt";

// 플랫폼에 맞는 경로 구분자를 자동으로 사용
string fullPath = Path.Combine(dir, file);
Console.WriteLine(fullPath);  // data/config.txt (Linux) 또는 data\config.txt (Windows)
```

**파일명 추출:**

```csharp
string path = "/home/user/documents/file.txt";

string fileName = Path.GetFileName(path);
Console.WriteLine(fileName);  // file.txt
```

**확장자 추출:**

```csharp
string path = "document.txt";

string ext = Path.GetExtension(path);
Console.WriteLine(ext);  // .txt
```

**확장자 제거:**

```csharp
string path = "photo.jpg";

string nameWithoutExt = Path.GetFileNameWithoutExtension(path);
Console.WriteLine(nameWithoutExt);  // photo
```

**디렉터리 경로 추출:**

```csharp
string path = "/home/user/documents/file.txt";

string dir = Path.GetDirectoryName(path);
Console.WriteLine(dir);  // /home/user/documents
```

**확장자 변경:**

```csharp
string path = "document.txt";

string newPath = Path.ChangeExtension(path, ".pdf");
Console.WriteLine(newPath);  // document.pdf
```

**임시 파일 경로 생성:**

```csharp
// 시스템의 임시 디렉터리 경로
string tempDir = Path.GetTempPath();
Console.WriteLine($"임시 디렉터리: {tempDir}");

// 고유한 임시 파일명 생성
string tempFile = Path.GetTempFileName();
Console.WriteLine($"임시 파일: {tempFile}");
```

**경로 유효성 검사:**

```csharp
string path = "data/file.txt";

// 경로가 절대 경로인지 확인
bool isAbsolute = Path.IsPathRooted(path);
Console.WriteLine($"절대 경로: {isAbsolute}");  // False
```

**실용 예제 - 안전한 파일 경로 생성:**

```csharp
string CreateSafeFilePath(string directory, string fileName)
{
    // 디렉터리가 없으면 생성
    if (!Directory.Exists(directory))
    {
        Directory.CreateDirectory(directory);
    }
    
    // 경로 결합
    string filePath = Path.Combine(directory, fileName);
    
    // 파일이 이미 존재하면 번호 추가
    if (File.Exists(filePath))
    {
        string nameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
        string ext = Path.GetExtension(fileName);
        int counter = 1;
        
        do
        {
            fileName = $"{nameWithoutExt}_{counter}{ext}";
            filePath = Path.Combine(directory, fileName);
            counter++;
        } while (File.Exists(filePath));
    }
    
    return filePath;
}

// 사용
string safePath = CreateSafeFilePath("output", "data.txt");
File.WriteAllText(safePath, "테스트 데이터");
Console.WriteLine($"파일 저장됨: {safePath}");
```

---

## 13.4 JSON 데이터 처리

JSON(JavaScript Object Notation)은 데이터를 저장하고 전송하기 위한 경량 텍스트 형식으로, 현대 웹 개발과 API 통신에서 사실상의 표준입니다. C# 객체를 JSON으로 변환하거나, JSON을 C# 객체로 변환하는 작업을 **직렬화(Serialization)**와 **역직렬화(Deserialization)**라고 합니다.

**JSON의 역사와 장점:**

JSON은 2001년 더글러스 크록포드(Douglas Crockford)가 제안한 데이터 형식으로, XML의 복잡성을 개선하여 단순하고 읽기 쉬운 형식을 제공합니다. 사람이 읽을 수 있고(human-readable), 기계가 파싱하기 쉬우며(machine-parsable), 언어 독립적이라는 장점이 있습니다.

### 13.4.1 System.Text.Json 소개

.NET Core 3.0부터 `System.Text.Json` 네임스페이스가 기본 JSON 라이브러리로 제공됩니다. 이전에는 Newtonsoft.Json(Json.NET)을 많이 사용했지만, 이제는 고성능의 내장 라이브러리를 사용할 수 있습니다.

**System.Text.Json의 특징:**

- **고성능**: 최신 .NET의 Span<T>과 Memory<T>를 활용한 제로 할당 파싱
- **보안**: 기본적으로 안전한 설정 (깊은 중첩 제한, 큰 문자열 제한 등)
- **경량**: 추가 패키지 설치 없이 기본 제공
- **현대적**: 최신 C# 기능(nullable reference types, records 등)과 잘 통합

**네임스페이스 추가:**

```csharp
using System.Text.Json;
```

### 13.4.2 JSON 직렬화

직렬화(Serialization)는 C# 객체를 JSON 문자열로 변환하는 과정입니다. 객체의 상태를 텍스트 형식으로 저장하여 파일에 쓰거나 네트워크로 전송할 수 있습니다.

**기본 클래스 정의:**

```csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
}
```

**객체를 JSON 문자열로 변환:**

```csharp
using System.Text.Json;

Person person = new Person
{
    Name = "홍길동",
    Age = 30,
    Email = "hong@example.com"
};

// 직렬화
string json = JsonSerializer.Serialize(person);
Console.WriteLine(json);

// 출력: {"Name":"홍길동","Age":30,"Email":"hong@example.com"}
```

**가독성 있는 JSON 생성 (들여쓰기):**

```csharp
var options = new JsonSerializerOptions
{
    WriteIndented = true  // 들여쓰기 활성화
};

string json = JsonSerializer.Serialize(person, options);
Console.WriteLine(json);

// 출력:
// {
//   "Name": "홍길동",
//   "Age": 30,
//   "Email": "hong@example.com"
// }
```

**컬렉션 직렬화:**

```csharp
List<Person> people = new List<Person>
{
    new Person { Name = "홍길동", Age = 30, Email = "hong@example.com" },
    new Person { Name = "김철수", Age = 25, Email = "kim@example.com" },
    new Person { Name = "이영희", Age = 28, Email = "lee@example.com" }
};

var options = new JsonSerializerOptions { WriteIndented = true };
string json = JsonSerializer.Serialize(people, options);

Console.WriteLine(json);
```

**JSON 파일로 저장:**

```csharp
Person person = new Person
{
    Name = "홍길동",
    Age = 30,
    Email = "hong@example.com"
};

var options = new JsonSerializerOptions { WriteIndented = true };
string json = JsonSerializer.Serialize(person, options);

File.WriteAllText("person.json", json);
Console.WriteLine("JSON 파일이 저장되었습니다.");
```

**실용 예제 - 게임 설정 저장:**

```csharp
class GameSettings
{
    public string PlayerName { get; set; }
    public int Level { get; set; }
    public int Score { get; set; }
    public bool SoundEnabled { get; set; }
}

void SaveGameSettings(GameSettings settings)
{
    var options = new JsonSerializerOptions { WriteIndented = true };
    string json = JsonSerializer.Serialize(settings, options);
    File.WriteAllText("game_settings.json", json);
    Console.WriteLine("게임 설정이 저장되었습니다.");
}

// 사용
GameSettings settings = new GameSettings
{
    PlayerName = "플레이어1",
    Level = 5,
    Score = 1250,
    SoundEnabled = true
};

SaveGameSettings(settings);
```

### 13.4.3 JSON 역직렬화

역직렬화(Deserialization)는 JSON 문자열을 C# 객체로 변환하는 과정입니다. 파일이나 네트워크에서 받은 JSON 데이터를 프로그램에서 사용할 수 있는 객체로 복원합니다.

**JSON 문자열을 객체로 변환:**

```csharp
string json = @"{
    ""Name"": ""홍길동"",
    ""Age"": 30,
    ""Email"": ""hong@example.com""
}";

// 역직렬화
Person person = JsonSerializer.Deserialize<Person>(json);

Console.WriteLine($"이름: {person.Name}");
Console.WriteLine($"나이: {person.Age}");
Console.WriteLine($"이메일: {person.Email}");
```

**JSON 파일에서 읽기:**

```csharp
if (File.Exists("person.json"))
{
    string json = File.ReadAllText("person.json");
    Person person = JsonSerializer.Deserialize<Person>(json);
    
    Console.WriteLine($"이름: {person.Name}");
    Console.WriteLine($"나이: {person.Age}");
}
```

**컬렉션 역직렬화:**

```csharp
string json = @"[
    {""Name"":""홍길동"",""Age"":30,""Email"":""hong@example.com""},
    {""Name"":""김철수"",""Age"":25,""Email"":""kim@example.com""}
]";

List<Person> people = JsonSerializer.Deserialize<List<Person>>(json);

foreach (var person in people)
{
    Console.WriteLine($"{person.Name} ({person.Age}세)");
}
```

**실용 예제 - 게임 설정 불러오기:**

```csharp
GameSettings LoadGameSettings()
{
    string settingsPath = "game_settings.json";
    
    if (File.Exists(settingsPath))
    {
        string json = File.ReadAllText(settingsPath);
        GameSettings settings = JsonSerializer.Deserialize<GameSettings>(json);
        Console.WriteLine("게임 설정을 불러왔습니다.");
        return settings;
    }
    else
    {
        Console.WriteLine("설정 파일이 없습니다. 기본 설정을 사용합니다.");
        return new GameSettings
        {
            PlayerName = "플레이어",
            Level = 1,
            Score = 0,
            SoundEnabled = true
        };
    }
}

// 사용
GameSettings settings = LoadGameSettings();
Console.WriteLine($"플레이어: {settings.PlayerName}");
Console.WriteLine($"레벨: {settings.Level}");
Console.WriteLine($"점수: {settings.Score}");
```

**null 안전성 처리:**

```csharp
string json = @"{""Name"":""홍길동""}";  // Age와 Email 누락

Person? person = JsonSerializer.Deserialize<Person>(json);

if (person != null)
{
    Console.WriteLine($"이름: {person.Name}");
    Console.WriteLine($"나이: {person.Age}");  // 0 (기본값)
    Console.WriteLine($"이메일: {person.Email ?? "(없음)"}");
}
```

**예외 처리:**

```csharp
string json = @"{잘못된 JSON}";

try
{
    Person person = JsonSerializer.Deserialize<Person>(json);
}
catch (JsonException ex)
{
    Console.WriteLine($"JSON 파싱 오류: {ex.Message}");
}
```

**실용 예제 - 완전한 설정 관리 시스템:**

```csharp
class AppConfig
{
    public string AppName { get; set; }
    public string Version { get; set; }
    public Dictionary<string, string> Settings { get; set; }
}

class ConfigManager
{
    private const string ConfigPath = "app_config.json";
    
    public static void SaveConfig(AppConfig config)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        string json = JsonSerializer.Serialize(config, options);
        File.WriteAllText(ConfigPath, json);
        Console.WriteLine("설정이 저장되었습니다.");
    }
    
    public static AppConfig LoadConfig()
    {
        if (File.Exists(ConfigPath))
        {
            string json = File.ReadAllText(ConfigPath);
            return JsonSerializer.Deserialize<AppConfig>(json);
        }
        else
        {
            // 기본 설정 생성
            return new AppConfig
            {
                AppName = "MyApp",
                Version = "1.0.0",
                Settings = new Dictionary<string, string>
                {
                    { "Theme", "Light" },
                    { "Language", "ko-KR" }
                }
            };
        }
    }
}

// 사용 예제
AppConfig config = ConfigManager.LoadConfig();
Console.WriteLine($"앱: {config.AppName} v{config.Version}");

// 설정 수정
config.Settings["Theme"] = "Dark";
ConfigManager.SaveConfig(config);
```

---

## 13장 정리 및 요약

이 장에서는 C#에서 파일 시스템과 상호작용하는 다양한 방법을 학습했습니다.

### 핵심 개념 정리

1. **텍스트 파일 읽기**
   - `File.ReadAllText()`: 파일 전체를 문자열로 읽기 (작은 파일)
   - `File.ReadAllLines()`: 파일을 줄 단위 배열로 읽기 (CSV, 로그)
   - `StreamReader`: 큰 파일을 효율적으로 읽기 (스트림 방식)

2. **텍스트 파일 쓰기**
   - `File.WriteAllText()`: 문자열을 파일로 저장 (덮어쓰기)
   - `File.WriteAllLines()`: 문자열 배열을 파일로 저장
   - `StreamWriter`: 대용량 파일 쓰기, 내용 추가(append) 가능

3. **파일과 디렉터리 관리**
   - `File` 클래스: 복사, 이동, 삭제, 정보 조회
   - `Directory` 클래스: 디렉터리 생성, 삭제, 파일 목록
   - `Path` 클래스: 경로 문자열 조작 (결합, 추출, 변경)

4. **JSON 데이터 처리**
   - `System.Text.Json`: 고성능 JSON 라이브러리
   - 직렬화: C# 객체 → JSON 문자열
   - 역직렬화: JSON 문자열 → C# 객체

### 실습 문제

#### 문제 1: 할 일 목록 관리

할 일을 파일에 저장하고 불러오는 프로그램을 작성하세요.

```csharp
void SaveTodoList(List<string> todos)
{
    File.WriteAllLines("todos.txt", todos);
    Console.WriteLine("할 일이 저장되었습니다.");
}

List<string> LoadTodoList()
{
    if (File.Exists("todos.txt"))
    {
        return new List<string>(File.ReadAllLines("todos.txt"));
    }
    return new List<string>();
}

// 사용
List<string> todos = LoadTodoList();
todos.Add("C# 공부하기");
todos.Add("파일 입출력 연습");
todos.Add("프로젝트 완성");

SaveTodoList(todos);

// 불러와서 출력
List<string> loadedTodos = LoadTodoList();
Console.WriteLine("=== 할 일 목록 ===");
for (int i = 0; i < loadedTodos.Count; i++)
{
    Console.WriteLine($"{i + 1}. {loadedTodos[i]}");
}
```

#### 문제 2: 점수 기록 시스템

학생들의 점수를 JSON 파일로 저장하고 불러오는 시스템을 작성하세요.

```csharp
using System.Text.Json;

class Student
{
    public string Name { get; set; }
    public int Score { get; set; }
}

void SaveScores(List<Student> students)
{
    var options = new JsonSerializerOptions { WriteIndented = true };
    string json = JsonSerializer.Serialize(students, options);
    File.WriteAllText("scores.json", json);
    Console.WriteLine("점수가 저장되었습니다.");
}

List<Student> LoadScores()
{
    if (File.Exists("scores.json"))
    {
        string json = File.ReadAllText("scores.json");
        return JsonSerializer.Deserialize<List<Student>>(json);
    }
    return new List<Student>();
}

// 사용
List<Student> students = new List<Student>
{
    new Student { Name = "홍길동", Score = 85 },
    new Student { Name = "김철수", Score = 92 },
    new Student { Name = "이영희", Score = 78 }
};

SaveScores(students);

// 불러와서 평균 계산
List<Student> loadedStudents = LoadScores();
double average = loadedStudents.Average(s => s.Score);

Console.WriteLine("=== 학생 점수 ===");
foreach (var student in loadedStudents)
{
    Console.WriteLine($"{student.Name}: {student.Score}점");
}
Console.WriteLine($"평균: {average:F2}점");
```

#### 문제 3: 로그 시스템

타임스탬프가 포함된 로그를 파일에 추가하는 시스템을 작성하세요.

```csharp
class Logger
{
    private const string LogPath = "app.log";
    
    public static void Log(string message, string level = "INFO")
    {
        string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        string logEntry = $"[{timestamp}] [{level}] {message}";
        
        // 파일에 추가
        using StreamWriter writer = new StreamWriter(LogPath, append: true);
        writer.WriteLine(logEntry);
        
        // 콘솔에도 출력
        Console.WriteLine(logEntry);
    }
    
    public static void ShowLogs()
    {
        if (File.Exists(LogPath))
        {
            Console.WriteLine("=== 로그 기록 ===");
            string[] lines = File.ReadAllLines(LogPath);
            foreach (string line in lines)
            {
                Console.WriteLine(line);
            }
        }
    }
}

// 사용
Logger.Log("프로그램 시작");
Logger.Log("데이터 로딩 완료");
Logger.Log("경고: 메모리 사용량 높음", "WARNING");
Logger.Log("에러 발생: 파일 없음", "ERROR");

Console.WriteLine();
Logger.ShowLogs();
```

### 다음 장 예고

14장 "LINQ 기초"에서는 데이터 컬렉션을 효율적으로 쿼리하고 변환하는 강력한 기능을 학습합니다:
- LINQ란 무엇인가?
- Where, Select, OrderBy 등 기본 연산자
- 컬렉션과 파일 데이터를 우아하게 처리하는 방법

파일에서 읽은 데이터를 LINQ로 필터링하고 가공하는 등, 이번 장에서 배운 파일 입출력과 결합하면 더욱 강력한 프로그램을 만들 수 있습니다!
