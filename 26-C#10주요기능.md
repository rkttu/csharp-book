# 26장. C# 10 주요 기능

C# 10은 2021년 11월 .NET 6와 함께 출시된 버전으로, 언어의 간결성과 표현력을 대폭 향상시킨 주요 릴리스입니다. Anders Hejlsberg와 Mads Torgersen이 이끄는 C# 언어 설계팀은 개발자의 생산성을 높이고 보일러플레이트 코드를 줄이는 데 초점을 맞췄습니다. 특히 이 버전은 "minimal API"와 같은 현대적 개발 패턴을 지원하기 위해 문법을 대폭 개선했으며, record struct의 도입으로 값 타입의 표현력을 크게 향상시켰습니다.

**C# 10의 설계 철학:**

C# 10의 개발은 세 가지 핵심 원칙을 중심으로 진행되었습니다:

1. **간결성(Conciseness)**: Global using과 File-scoped namespace를 통해 반복적인 코드를 제거하고, 실제 비즈니스 로직에 집중할 수 있게 합니다.

2. **일관성(Consistency)**: Record struct의 도입으로 참조 타입(record class)과 값 타입(record struct) 간의 일관된 문법을 제공합니다.

3. **표현력(Expressiveness)**: 개선된 람다 식과 Required Properties를 통해 의도를 더 명확하게 표현할 수 있습니다.

**현대 C# 개발의 변화:**

C# 10은 .NET 6의 "minimal API" 패러다임과 함께 등장하여, 마이크로서비스와 클라우드 네이티브 애플리케이션 개발에 최적화되었습니다. 전통적인 ASP.NET 애플리케이션이 수십 줄의 보일러플레이트 코드를 요구했다면, C# 10과 .NET 6는 단 몇 줄로 웹 서버를 구축할 수 있게 합니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C# 10의 주요 기능들을 체계적으로 학습하게 됩니다:

- **Global using 지시문**: 프로젝트 전체에서 공통으로 사용되는 네임스페이스를 한 곳에서 관리하여 각 파일의 using 선언을 줄이는 방법을 배웁니다.

- **File-scoped 네임스페이스**: 한 단계의 들여쓰기를 제거하여 코드의 가독성을 높이고, 파일 전체를 하나의 네임스페이스로 간단하게 선언하는 방법을 익힙니다.

- **개선된 람다 식**: 람다 식에 특성(Attributes)을 적용하고, 명시적 반환 타입을 지정하며, var를 사용한 자연스러운 타입 추론을 활용하는 방법을 학습합니다.

- **Record struct**: 불변 값 타입을 우아하게 표현하는 record struct의 개념과 활용법을 배우며, record class와의 차이점을 이해합니다.

- **필수 속성(Required Properties)**: 객체 초기화 시 반드시 설정해야 하는 속성을 컴파일 타임에 검증하는 방법을 익힙니다.

**학습 목표:**
- C# 10의 새로운 기능들을 실무에 적용하는 방법 이해
- 코드의 간결성과 가독성을 높이는 현대적 C# 작성법 습득
- .NET 6 이상의 프로젝트에서 생산성을 향상시키는 기법 체득

---

## 26.1 Global using 지시문

Global using 지시문은 C# 10에서 도입된 기능으로, 프로젝트의 모든 파일에서 공통으로 사용되는 네임스페이스를 한 곳에서 선언할 수 있게 합니다. 이는 Java의 import static이나 Python의 __init__.py와 유사한 개념으로, 반복적인 using 선언을 제거하여 코드의 간결성을 크게 향상시킵니다.

**문제 상황:**

전통적인 C# 프로젝트에서는 거의 모든 파일이 동일한 using 선언으로 시작합니다:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

// 실제 코드는 여기서부터 시작
public class MyClass
{
    // ...
}
```

대규모 프로젝트에서는 수백 개의 파일에 이러한 반복적인 선언이 존재하며, 이는 코드 중복과 유지보수의 부담을 증가시킵니다.

**Global using의 해결책:**

Global using을 사용하면 프로젝트의 한 파일(일반적으로 `GlobalUsings.cs`)에서 공통 네임스페이스를 선언할 수 있습니다:

```csharp
// GlobalUsings.cs
global using System;
global using System.Collections.Generic;
global using System.Linq;
global using System.Threading.Tasks;
```

이제 다른 모든 파일에서는 이러한 using 선언 없이 바로 시작할 수 있습니다:

```csharp
// MyClass.cs
public class MyClass
{
    // System, List<T>, LINQ 등을 바로 사용 가능
    public List<string> GetNames()
    {
        return new List<string> { "Alice", "Bob" };
    }
}
```

**실전 예제:**

```csharp
// GlobalUsings.cs - 프로젝트 전체에서 사용할 네임스페이스 정의
global using System;
global using System.Collections.Generic;
global using System.Linq;
global using System.Text;
global using System.Threading.Tasks;
global using System.Text.Json;

// 프로젝트 특정 네임스페이스도 추가 가능
global using MyCompany.Common;
global using MyCompany.Models;
```

```csharp
// Product.cs - using 선언 없이 시작
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

```csharp
// ProductService.cs - 역시 using 선언 없이 시작
public class ProductService
{
    private readonly List<Product> products = new();
    
    public void AddProduct(Product product)
    {
        products.Add(product);
    }
    
    public List<Product> GetExpensiveProducts(decimal minPrice)
    {
        return products.Where(p => p.Price >= minPrice).ToList();
    }
    
    public string SerializeProducts()
    {
        return JsonSerializer.Serialize(products);
    }
}
```

**암시적 Global Usings:**

.NET 6 이상의 SDK 스타일 프로젝트에서는 `<ImplicitUsings>enable</ImplicitUsings>` 설정을 통해 프레임워크가 자동으로 일반적인 네임스페이스를 포함시킵니다:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>
```

이 설정은 프로젝트 유형에 따라 자동으로 다음 네임스페이스들을 포함합니다:
- Console/Library: System, System.Collections.Generic, System.IO, System.Linq, System.Threading.Tasks 등
- ASP.NET: Microsoft.AspNetCore.Builder, Microsoft.AspNetCore.Hosting 등 추가

**모범 사례:**

1. **프로젝트 전체에서 자주 사용하는 네임스페이스만 포함**: 모든 네임스페이스를 global로 만들면 네임스페이스의 목적이 사라집니다.

2. **명시적으로 필요한 경우 로컬 using 사용**: 특정 파일에서만 필요한 네임스페이스는 해당 파일에 선언합니다.

3. **별칭(Alias)도 global로 선언 가능**:
```csharp
global using Json = System.Text.Json.JsonSerializer;
```

---

## 26.2 File-scoped 네임스페이스

File-scoped 네임스페이스는 C# 10에서 도입된 문법으로, 파일 전체를 하나의 네임스페이스로 선언할 때 중괄호와 한 단계의 들여쓰기를 제거할 수 있게 합니다. 이는 Python의 모듈 개념이나 Go의 패키지 선언과 유사한 간결함을 제공합니다.

**전통적인 네임스페이스 선언:**

```csharp
using System;

namespace MyCompany.MyProduct.MyFeature
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
    }
}
```

전체 파일이 한 단계 들여쓰기되어 있으며, 중괄호가 화면 공간을 차지합니다.

**File-scoped 네임스페이스:**

```csharp
using System;

namespace MyCompany.MyProduct.MyFeature;

public class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }
}
```

세미콜론(`;`)으로 네임스페이스를 선언하면, 파일의 나머지 모든 코드가 해당 네임스페이스에 속하게 됩니다.

**실전 예제:**

```csharp
// Product.cs
namespace MyCompany.Models;

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

```csharp
// IProductRepository.cs
namespace MyCompany.Repositories;

public interface IProductRepository
{
    void Add(Product product);
    Product? GetById(int id);
    List<Product> GetAll();
    void Update(Product product);
    void Delete(int id);
}
```

```csharp
// ProductRepository.cs
namespace MyCompany.Repositories;

public class ProductRepository : IProductRepository
{
    private readonly List<Product> products = new();
    
    public void Add(Product product)
    {
        products.Add(product);
    }
    
    public Product? GetById(int id)
    {
        return products.FirstOrDefault(p => p.Id == id);
    }
    
    public List<Product> GetAll()
    {
        return products.ToList();
    }
    
    public void Update(Product product)
    {
        var existing = GetById(product.Id);
        if (existing != null)
        {
            var index = products.IndexOf(existing);
            products[index] = product;
        }
    }
    
    public void Delete(int id)
    {
        var product = GetById(id);
        if (product != null)
        {
            products.Remove(product);
        }
    }
}
```

**장점:**

1. **가독성 향상**: 한 단계 들여쓰기가 줄어들어 코드가 더 명확하고 읽기 쉬워집니다.
2. **수평 공간 절약**: 특히 긴 네임스페이스 이름을 사용할 때 화면에 더 많은 코드가 보입니다.
3. **현대적 스타일**: .NET 6 이상의 새 프로젝트 템플릿에서 기본으로 사용됩니다.

**제약 사항:**

1. **한 파일에 하나의 네임스페이스만**: File-scoped 네임스페이스는 파일당 하나만 선언할 수 있습니다.
2. **전통적 방식과 혼용 불가**: 같은 파일에서 file-scoped와 전통적 네임스페이스를 함께 사용할 수 없습니다.

**마이그레이션 팁:**

기존 프로젝트를 file-scoped 네임스페이스로 변환하려면:
1. Visual Studio의 "Code Cleanup" 기능 사용
2. 또는 수동으로 중괄호를 세미콜론으로 변경하고 들여쓰기 조정

---

## 26.3 개선된 람다 식

C# 10은 람다 식의 표현력을 크게 향상시켰습니다. 람다 식에 특성(Attributes)을 적용할 수 있게 되었고, 명시적 반환 타입을 지정할 수 있으며, 자연스러운 타입 추론이 가능해졌습니다. 이는 람다 식을 메서드와 거의 동등한 수준의 일급 시민(First-class citizen)으로 만들어줍니다.

**람다 식의 역사:**

람다 식은 C# 3.0(2007년)에서 처음 도입되어 LINQ의 핵심 문법이 되었습니다. Alonzo Church의 람다 계산법에서 이름을 따온 이 기능은 함수형 프로그래밍의 개념을 C#에 도입했습니다.

**기존 람다 식의 한계:**

C# 9까지의 람다 식은 다음과 같은 제약이 있었습니다:
- 특성(Attributes)을 적용할 수 없음
- 반환 타입을 명시적으로 지정할 수 없음 (추론에 의존)
- 매개변수에 특성을 적용할 수 없음

**C# 10의 개선사항:**

### 1. 명시적 반환 타입

```csharp
// 기존: 반환 타입 추론에만 의존
Func<int, int> square = x => x * x;

// C# 10: 명시적 반환 타입 지정
var square = int (int x) => x * x;
var getName = string () => "John";
```

### 2. 특성(Attributes) 적용

```csharp
// 람다 식 자체에 특성 적용
var lambda = [MyAttribute] (int x) => x * 2;

// 매개변수에 특성 적용
var validated = ([NotNull] string input) => input.ToUpper();

// 반환 값에 특성 적용
var getData = [return: NotNull] () => "data";
```

### 3. 자연스러운 타입 추론

```csharp
// var를 사용한 람다 선언
var parse = (string s) => int.Parse(s);  // Func<string, int>로 추론

var print = (string message) => Console.WriteLine(message);  // Action<string>으로 추론

// 여러 매개변수
var add = (int a, int b) => a + b;  // Func<int, int, int>로 추론
```

**실전 예제:**

```csharp
// 특성을 활용한 ASP.NET Minimal API
app.MapGet("/users/{id}", 
    [Authorize] 
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    async ([FromRoute] int id, [FromServices] IUserRepository repo) =>
    {
        var user = await repo.GetByIdAsync(id);
        return user is not null ? Results.Ok(user) : Results.NotFound();
    });
```

```csharp
// 명시적 반환 타입을 사용한 복잡한 람다
var processData = async Task<ProcessResult> (string input) =>
{
    if (string.IsNullOrEmpty(input))
        return new ProcessResult { Success = false, Error = "Empty input" };
    
    var data = await ParseDataAsync(input);
    var result = await ProcessAsync(data);
    
    return new ProcessResult { Success = true, Data = result };
};

// 사용
var result = await processData("sample data");
```

```csharp
// 델리게이트 타입 추론
var calculator = new Dictionary<string, Func<int, int, int>>
{
    ["add"] = (a, b) => a + b,
    ["subtract"] = (a, b) => a - b,
    ["multiply"] = (a, b) => a * b,
    ["divide"] = (a, b) => b != 0 ? a / b : 0
};

// 사용
var sum = calculator["add"](10, 5);  // 15
var product = calculator["multiply"](10, 5);  // 50
```

**모범 사례:**

1. **간단한 경우는 타입 추론 활용**: 복잡하지 않은 람다는 추론된 타입을 사용하는 것이 더 간결합니다.

2. **복잡한 경우 명시적 타입 지정**: async 람다나 복잡한 반환 타입의 경우 명시적으로 지정하면 가독성이 향상됩니다.

3. **API 경계에서 특성 활용**: ASP.NET Minimal API나 특성 기반 검증이 필요한 경우 적극 활용합니다.

---

## 26.4 Record struct

Record struct는 C# 10에서 도입된 기능으로, C# 9의 record 타입(참조 타입)을 값 타입으로 확장한 것입니다. 불변(Immutable) 값 타입을 우아하게 표현할 수 있으며, 값 기반 동등성(Value-based equality)과 with 식을 지원합니다.

**값 타입과 참조 타입:**

C#에는 두 가지 주요 타입 범주가 있습니다:
- **참조 타입(Reference Types)**: class, record class - 힙에 할당, 참조로 전달
- **값 타입(Value Types)**: struct, record struct - 스택에 할당, 값으로 전달

**Record의 진화:**

- **C# 9 (2020)**: `record` (record class) 도입 - 참조 타입
- **C# 10 (2021)**: `record struct` 도입 - 값 타입

**기본 record struct:**

```csharp
// 간단한 record struct 정의
public record struct Point(int X, int Y);

// 사용
var p1 = new Point(10, 20);
var p2 = new Point(10, 20);

Console.WriteLine(p1 == p2);  // True (값 기반 동등성)
Console.WriteLine(p1);  // Point { X = 10, Y = 20 } (자동 ToString)
```

**일반 struct vs Record struct 비교:**

```csharp
// 일반 struct - 많은 보일러플레이트 코드 필요
public struct PointStruct
{
    public int X { get; init; }
    public int Y { get; init; }
    
    public PointStruct(int x, int y)
    {
        X = x;
        Y = y;
    }
    
    // 값 기반 동등성을 위해 직접 구현 필요
    public override bool Equals(object? obj)
    {
        return obj is PointStruct other && X == other.X && Y == other.Y;
    }
    
    public override int GetHashCode()
    {
        return HashCode.Combine(X, Y);
    }
    
    public override string ToString()
    {
        return $"PointStruct {{ X = {X}, Y = {Y} }}";
    }
}

// Record struct - 훨씬 간결!
public record struct Point(int X, int Y);
```

**실전 예제:**

```csharp
// 좌표계 record struct
public record struct Coordinate(double Latitude, double Longitude)
{
    // 추가 메서드 정의 가능
    public double DistanceTo(Coordinate other)
    {
        var lat = Latitude - other.Latitude;
        var lon = Longitude - other.Longitude;
        return Math.Sqrt(lat * lat + lon * lon);
    }
}

// 사용
var seoul = new Coordinate(37.5665, 126.9780);
var busan = new Coordinate(35.1796, 129.0756);
var distance = seoul.DistanceTo(busan);
Console.WriteLine($"Distance: {distance}");
```

```csharp
// RGB 색상 표현
public record struct Color(byte Red, byte Green, byte Blue)
{
    public static Color White => new(255, 255, 255);
    public static Color Black => new(0, 0, 0);
    
    public Color Darken(double factor)
    {
        return new Color(
            (byte)(Red * factor),
            (byte)(Green * factor),
            (byte)(Blue * factor)
        );
    }
}

// 사용
var red = new Color(255, 0, 0);
var darkRed = red.Darken(0.5);
Console.WriteLine(darkRed);  // Color { Red = 127, Green = 0, Blue = 0 }
```

**with 식을 사용한 비파괴적 변경:**

```csharp
public record struct Product(int Id, string Name, decimal Price);

var product1 = new Product(1, "Laptop", 1000m);

// 일부 속성만 변경하여 새 인스턴스 생성
var product2 = product1 with { Price = 900m };

Console.WriteLine(product1);  // Product { Id = 1, Name = Laptop, Price = 1000 }
Console.WriteLine(product2);  // Product { Id = 1, Name = Laptop, Price = 900 }
```

**readonly record struct:**

```csharp
// 완전히 불변인 record struct
public readonly record struct ImmutablePoint(int X, int Y);

// 컴파일러가 모든 속성을 readonly로 만듦
var point = new ImmutablePoint(10, 20);
// point.X = 30;  // 컴파일 오류!
```

**Mutable record struct:**

```csharp
// 가변 record struct (권장하지 않음)
public record struct MutablePoint(int X, int Y);

var point = new MutablePoint(10, 20);
point.X = 30;  // 가능하지만 record의 철학과 맞지 않음
```

**사용 시기:**

1. **Record struct 사용**: 작은 불변 값 타입, 좌표, 색상, 날짜 범위 등
2. **Record class 사용**: 도메인 엔티티, 대용량 데이터
3. **Class 사용**: 가변 상태, 다형성이 필요한 경우
4. **Struct 사용**: 성능이 매우 중요하고 값 의미론이 필요한 경우

**성능 고려사항:**

Record struct는 값 타입이므로:
- 스택에 할당되어 가비지 컬렉션 부담이 적음
- 작은 크기(16바이트 이하)일 때 성능상 이점
- 큰 크기의 경우 복사 비용이 높아질 수 있으므로 `in` 매개변수 사용 고려

```csharp
// 큰 record struct를 효율적으로 전달
public record struct LargeData(string A, string B, string C, string D);

public void ProcessData(in LargeData data)  // 복사 없이 참조로 전달
{
    Console.WriteLine(data.A);
}
```

---

## 26.5 필수 속성 (Required Properties)

C# 11에서 정식 도입되었지만 개념적으로 C# 10의 흐름을 이어받은 Required Properties는 객체 초기화 시 반드시 설정해야 하는 속성을 컴파일 타임에 검증할 수 있게 합니다. 이는 NullReferenceException을 방지하고 객체의 유효성을 보장하는 강력한 도구입니다.

**기존 방식의 문제점:**

```csharp
public class Person
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public int Age { get; set; }
}

// 문제: 필수 속성을 설정하지 않아도 컴파일됨
var person = new Person();  // FirstName과 LastName이 null!
Console.WriteLine(person.FirstName.Length);  // NullReferenceException!
```

**생성자를 통한 해결 (전통적 방식):**

```csharp
public class Person
{
    public Person(string firstName, string lastName, int age)
    {
        FirstName = firstName;
        LastName = lastName;
        Age = age;
    }
    
    public string FirstName { get; }
    public string LastName { get; }
    public int Age { get; }
}

// 모든 값을 생성자에 전달해야 함
var person = new Person("John", "Doe", 30);
```

하지만 이 방식은 속성이 많을 때 불편하고, 선택적 속성을 다루기 어렵습니다.

**Required Properties의 해결책:**

```csharp
public class Person
{
    public required string FirstName { get; set; }
    public required string LastName { get; set; }
    public int Age { get; set; }  // 선택적
}

// 컴파일 타임에 필수 속성 검증
var person = new Person
{
    FirstName = "John",
    LastName = "Doe"
    // Age는 선택적이므로 생략 가능
};

// ❌ 컴파일 오류: FirstName이 설정되지 않음
// var invalid = new Person { LastName = "Doe" };
```

**실전 예제:**

```csharp
// 제품 클래스
public class Product
{
    public required int Id { get; set; }
    public required string Name { get; set; }
    public required decimal Price { get; set; }
    
    // 선택적 속성
    public string? Description { get; set; }
    public DateTime? CreatedAt { get; set; }
    public List<string> Tags { get; set; } = new();
}

// 사용
var product = new Product
{
    Id = 1,
    Name = "Laptop",
    Price = 1299.99m,
    Description = "High-performance laptop",  // 선택적
    Tags = { "electronics", "computer" }
};
```

```csharp
// 구성 클래스
public class DatabaseConfig
{
    public required string ConnectionString { get; init; }
    public required string DatabaseName { get; init; }
    public int MaxPoolSize { get; init; } = 100;
    public int TimeoutSeconds { get; init; } = 30;
}

// 사용 - 필수 값만 설정
var config = new DatabaseConfig
{
    ConnectionString = "Server=localhost;",
    DatabaseName = "MyDatabase"
    // MaxPoolSize와 TimeoutSeconds는 기본값 사용
};
```

**Required와 init 결합:**

```csharp
public class ImmutablePerson
{
    public required string FirstName { get; init; }
    public required string LastName { get; init; }
    public int Age { get; init; }
}

// 초기화 시에만 설정 가능
var person = new ImmutablePerson
{
    FirstName = "John",
    LastName = "Doe",
    Age = 30
};

// person.FirstName = "Jane";  // 컴파일 오류! init만 가능
```

**생성자와 함께 사용:**

```csharp
public class Employee
{
    public Employee()
    {
        // 기본 생성자
    }
    
    // SetsRequiredMembers 특성: 이 생성자가 필수 멤버를 설정함을 표시
    [SetsRequiredMembers]
    public Employee(string firstName, string lastName, string employeeId)
    {
        FirstName = firstName;
        LastName = lastName;
        EmployeeId = employeeId;
    }
    
    public required string FirstName { get; set; }
    public required string LastName { get; set; }
    public required string EmployeeId { get; set; }
}

// 두 가지 방식 모두 가능
var emp1 = new Employee
{
    FirstName = "John",
    LastName = "Doe",
    EmployeeId = "E001"
};

var emp2 = new Employee("Jane", "Smith", "E002");
```

**상속 시나리오:**

```csharp
public class Animal
{
    public required string Name { get; set; }
    public int Age { get; set; }
}

public class Dog : Animal
{
    public required string Breed { get; set; }
    public string? FavoriteActivity { get; set; }
}

// 기본 클래스와 파생 클래스의 필수 속성 모두 설정
var dog = new Dog
{
    Name = "Buddy",      // Animal의 필수 속성
    Breed = "Labrador",  // Dog의 필수 속성
    Age = 3,             // 선택적
    FavoriteActivity = "Fetching"  // 선택적
};
```

**모범 사례:**

1. **필수 속성 식별**: 객체가 유효하려면 반드시 필요한 속성에만 `required` 사용
2. **기본값이 있는 속성은 선택적으로**: 의미 있는 기본값이 있다면 required 불필요
3. **null 허용 타입과 구분**: `required string`은 null이 아닌 값이 필요, `string?`은 null 허용
4. **문서화 효과**: `required` 키워드 자체가 API 문서 역할을 함

**Required Properties의 장점:**

1. **컴파일 타임 검증**: 런타임 오류 대신 컴파일 시점에 발견
2. **유연성**: 생성자보다 더 유연한 객체 초기화
3. **가독성**: 객체 초기화 구문이 명확하고 읽기 쉬움
4. **유지보수성**: 필수 속성 변경 시 컴파일러가 모든 사용처를 확인

---

## 마치며

C# 10은 개발자의 생산성과 코드 품질을 크게 향상시키는 기능들을 도입했습니다. Global using과 File-scoped namespace는 불필요한 보일러플레이트를 제거하고, 개선된 람다 식은 함수형 프로그래밍 스타일을 더욱 자연스럽게 만들어줍니다. Record struct는 불변 값 타입의 표현력을 높였으며, Required Properties는 타입 안전성을 강화합니다.

**다음 단계:**

- 27장에서는 C#의 강력한 패턴 매칭 기능을 심층적으로 다룹니다
- 28장에서는 Nullable 참조 타입을 통한 null 안전성을 학습합니다
- 29장에서는 성능과 메모리 최적화 기법을 익힙니다

**실습 과제:**

1. 기존 프로젝트에 Global using 적용하기
2. File-scoped namespace로 마이그레이션하기
3. 도메인 모델에 record struct 활용하기
4. Required properties로 객체 초기화 개선하기

C# 10의 기능들을 실무에 적용하면 코드가 더 간결하고 안전해지며, 유지보수가 쉬워집니다. 이러한 현대적 C# 작성법을 습관화하여 더 나은 소프트웨어를 개발하시기 바랍니다.
