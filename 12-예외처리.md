# 12장. 예외 처리

프로그램을 작성하다 보면 예상치 못한 상황이 발생할 수 있습니다. 파일이 존재하지 않거나, 네트워크 연결이 끊어지거나, 사용자가 잘못된 입력을 제공하는 등 다양한 오류 상황에 직면하게 됩니다. 이러한 오류를 적절히 처리하지 않으면 프로그램이 갑자기 종료되거나 예측할 수 없는 동작을 할 수 있습니다. **예외 처리(Exception Handling)**는 프로그램 실행 중 발생하는 오류를 감지하고 적절하게 대응하여, 프로그램의 안정성과 신뢰성을 높이는 핵심 메커니즘입니다.

C#의 예외 처리 시스템은 구조화된 예외 처리(SEH, Structured Exception Handling) 모델을 따르며, 이는 1990년대 초반 Microsoft가 Windows NT에서 도입한 개념입니다. 이전의 오류 코드 반환 방식에 비해, 예외 처리는 정상적인 프로그램 흐름과 오류 처리 로직을 분리하여 코드의 가독성과 유지보수성을 크게 향상시킵니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#의 예외 처리 메커니즘을 체계적으로 학습하게 됩니다:

- **예외의 개념**: 예외가 무엇이며, 왜 필요한지 이해합니다.

- **try-catch-finally 구조**: 예외를 처리하는 기본 문법과 패턴을 익힙니다.

- **예외 던지기**: `throw` 키워드를 사용하여 예외를 발생시키는 방법을 배웁니다.

- **사용자 정의 예외**: 애플리케이션의 특정 요구사항에 맞는 예외 클래스를 만드는 방법을 학습합니다.

- **예외 필터**: C# 6.0에서 도입된 `when` 키워드를 활용한 조건부 예외 처리를 익힙니다.

---

## 12.1 예외란 무엇인가?

**예외(Exception)**는 프로그램 실행 중에 발생하는 예상치 못한 문제 또는 오류 상황을 나타내는 객체입니다. 예외는 정상적인 프로그램 흐름을 방해하며, 적절히 처리하지 않으면 프로그램이 비정상적으로 종료될 수 있습니다.

### 예외의 필요성

전통적인 프로그래밍에서는 오류를 처리하기 위해 반환 코드(return code)나 전역 오류 변수를 사용했습니다. 예를 들어, C 언어에서는 함수가 성공하면 0을, 실패하면 음수 또는 특정 오류 코드를 반환하는 방식이 일반적이었습니다. 그러나 이 방식은 다음과 같은 문제점이 있습니다:

1. **오류 처리 코드와 정상 로직의 혼재**: 모든 함수 호출 후 반환 코드를 검사해야 하므로 코드가 복잡해집니다.
2. **오류 전파의 어려움**: 여러 단계의 함수 호출을 거쳐 오류를 전달하려면 각 단계에서 오류 코드를 확인하고 전파해야 합니다.
3. **일관성 부족**: 개발자마다 다른 오류 코드 체계를 사용할 수 있어 혼란을 야기합니다.

C#의 예외 처리 메커니즘은 이러한 문제를 해결하기 위해 설계되었습니다:

- **정상 로직과 오류 처리의 분리**: 정상적인 코드 흐름과 오류 처리 코드를 명확히 구분할 수 있습니다.
- **자동 오류 전파**: 예외는 적절한 처리기가 나타날 때까지 호출 스택을 자동으로 따라 올라갑니다.
- **타입 안전성**: 예외는 객체이므로 타입 시스템을 통해 다양한 종류의 오류를 구별할 수 있습니다.

### 예외가 발생하는 상황

다음은 예외가 발생할 수 있는 일반적인 상황들입니다:

**1. 잘못된 사용자 입력:**

```csharp
// 숫자가 아닌 문자열을 정수로 변환하려고 시도
string input = "abc";
int number = int.Parse(input);  // FormatException 발생
```

**2. 존재하지 않는 파일 접근:**

```csharp
// 존재하지 않는 파일을 열려고 시도
string content = File.ReadAllText("없는파일.txt");  // FileNotFoundException 발생
```

**3. 0으로 나누기:**

```csharp
int a = 10;
int b = 0;
int result = a / b;  // DivideByZeroException 발생
```

**4. null 참조 접근:**

```csharp
string text = null;
int length = text.Length;  // NullReferenceException 발생
```

**5. 배열 범위 초과:**

```csharp
int[] numbers = { 1, 2, 3 };
int value = numbers[5];  // IndexOutOfRangeException 발생
```

### 예외 계층 구조

.NET의 모든 예외 클래스는 `System.Exception` 기본 클래스를 상속합니다. 주요 예외 클래스들은 다음과 같이 계층 구조를 이룹니다:

```
System.Exception
├── SystemException
│   ├── ArgumentException
│   │   ├── ArgumentNullException
│   │   └── ArgumentOutOfRangeException
│   ├── ArithmeticException
│   │   ├── DivideByZeroException
│   │   └── OverflowException
│   ├── IndexOutOfRangeException
│   ├── InvalidOperationException
│   ├── NullReferenceException
│   └── ...
└── ApplicationException (사용자 정의 예외의 기본 클래스로 권장되었으나, 현재는 Exception을 직접 상속하는 것이 권장됨)
```

### 예외 객체의 주요 속성

모든 예외 객체는 `Exception` 클래스로부터 다음과 같은 유용한 속성을 상속받습니다:

- **Message**: 예외에 대한 설명 메시지
- **StackTrace**: 예외가 발생한 호출 스택 정보
- **InnerException**: 현재 예외를 발생시킨 원인이 되는 내부 예외
- **Source**: 예외를 발생시킨 애플리케이션 또는 객체의 이름
- **HelpLink**: 예외에 대한 도움말 파일의 URL

**예외 정보 확인 예제:**

```csharp
try
{
    int number = int.Parse("abc");
}
catch (Exception ex)
{
    Console.WriteLine($"예외 타입: {ex.GetType().Name}");
    Console.WriteLine($"메시지: {ex.Message}");
    Console.WriteLine($"스택 추적:\n{ex.StackTrace}");
}

// 출력 예시:
// 예외 타입: FormatException
// 메시지: Input string was not in a correct format.
// 스택 추적:
// at System.Int32.Parse(String s)
// at Program.<Main>$(String[] args) in C:\...\Program.cs:line 3
```

---

## 12.2 try-catch-finally

`try-catch-finally` 구문은 C#에서 예외를 처리하는 핵심 메커니즘입니다. 이 구조는 예외가 발생할 수 있는 코드를 격리하고, 예외가 발생했을 때 적절히 대응하며, 예외 발생 여부와 관계없이 반드시 실행해야 하는 정리 코드를 보장합니다.

### 12.2.1 기본 예외 처리

**기본 구조:**

```csharp
try
{
    // 예외가 발생할 수 있는 코드
}
catch (예외타입 변수명)
{
    // 예외 처리 코드
}
```

**실행 흐름:**

1. `try` 블록 안의 코드가 순차적으로 실행됩니다.
2. 예외가 발생하지 않으면 `catch` 블록은 건너뛰고 계속 진행됩니다.
3. 예외가 발생하면 즉시 해당하는 `catch` 블록으로 제어가 이동합니다.
4. `catch` 블록의 코드가 실행된 후 프로그램은 정상적으로 계속됩니다.

**기본 예제:**

```csharp
Console.Write("첫 번째 숫자를 입력하세요: ");
string input1 = Console.ReadLine();

Console.Write("두 번째 숫자를 입력하세요: ");
string input2 = Console.ReadLine();

try
{
    int num1 = int.Parse(input1);
    int num2 = int.Parse(input2);
    int result = num1 / num2;
    
    Console.WriteLine($"결과: {num1} / {num2} = {result}");
}
catch (FormatException)
{
    Console.WriteLine("오류: 숫자 형식이 올바르지 않습니다.");
}
catch (DivideByZeroException)
{
    Console.WriteLine("오류: 0으로 나눌 수 없습니다.");
}

Console.WriteLine("프로그램이 계속 실행됩니다.");

// 잘못된 입력 예시:
// 첫 번째 숫자를 입력하세요: abc
// 두 번째 숫자를 입력하세요: 5
// 오류: 숫자 형식이 올바르지 않습니다.
// 프로그램이 계속 실행됩니다.
```

**예외 정보 활용:**

```csharp
try
{
    int[] numbers = { 1, 2, 3 };
    Console.WriteLine(numbers[10]);
}
catch (IndexOutOfRangeException ex)
{
    Console.WriteLine("배열 범위를 벗어났습니다.");
    Console.WriteLine($"상세 정보: {ex.Message}");
}

// 출력:
// 배열 범위를 벗어났습니다.
// 상세 정보: Index was outside the bounds of the array.
```

**파일 읽기 예외 처리:**

```csharp
try
{
    string content = File.ReadAllText("data.txt");
    Console.WriteLine($"파일 내용: {content}");
}
catch (FileNotFoundException)
{
    Console.WriteLine("오류: 파일을 찾을 수 없습니다.");
}
catch (UnauthorizedAccessException)
{
    Console.WriteLine("오류: 파일에 접근할 권한이 없습니다.");
}
catch (IOException ex)
{
    Console.WriteLine($"오류: 파일을 읽는 중 문제가 발생했습니다. ({ex.Message})");
}
```

### 12.2.2 여러 catch 블록

하나의 `try` 블록에 여러 개의 `catch` 블록을 연결하여 다양한 유형의 예외를 각각 다르게 처리할 수 있습니다. `catch` 블록은 위에서 아래로 순서대로 평가되며, 첫 번째로 일치하는 예외 타입의 `catch` 블록이 실행됩니다.

**중요한 규칙:**

- 더 구체적인(파생된) 예외 타입을 먼저 배치해야 합니다.
- 더 일반적인(기본) 예외 타입은 나중에 배치합니다.
- 이 순서를 지키지 않으면 컴파일 오류가 발생합니다.

**올바른 순서 예제:**

```csharp
try
{
    Console.Write("숫자를 입력하세요: ");
    string input = Console.ReadLine();
    
    int number = int.Parse(input);
    int result = 100 / number;
    
    Console.WriteLine($"100 / {number} = {result}");
}
catch (FormatException)
{
    // 가장 구체적인 예외
    Console.WriteLine("숫자 형식이 올바르지 않습니다.");
}
catch (DivideByZeroException)
{
    // 구체적인 예외
    Console.WriteLine("0으로 나눌 수 없습니다.");
}
catch (Exception ex)
{
    // 가장 일반적인 예외 (맨 마지막에 배치)
    Console.WriteLine($"예상치 못한 오류가 발생했습니다: {ex.Message}");
}
```

**잘못된 순서 (컴파일 오류):**

```csharp
try
{
    // 코드...
}
catch (Exception ex)
{
    // Exception이 모든 예외의 기본 클래스이므로 먼저 잡으면
    // 아래의 catch 블록에는 절대 도달할 수 없음
    Console.WriteLine("오류 발생");
}
catch (FormatException)  // ❌ 컴파일 오류: Unreachable catch block
{
    Console.WriteLine("형식 오류");
}
```

**Exception 필터링이 없는 catch:**

예외 변수를 선언하지 않고 모든 예외를 잡을 수도 있습니다:

```csharp
try
{
    // 예외 발생 가능 코드
}
catch
{
    // 모든 예외를 잡지만, 예외 객체에 접근할 수 없음
    Console.WriteLine("오류가 발생했습니다.");
}
```

### 12.2.3 finally 블록

`finally` 블록은 예외 발생 여부와 관계없이 **항상 실행**되는 코드 블록입니다. 주로 리소스 정리(파일 닫기, 데이터베이스 연결 해제, 메모리 해제 등)에 사용됩니다.

**기본 구조:**

```csharp
try
{
    // 예외가 발생할 수 있는 코드
}
catch (Exception ex)
{
    // 예외 처리
}
finally
{
    // 항상 실행되는 코드
}
```

**실행 순서:**

1. `try` 블록 실행
2. 예외 발생 시 해당 `catch` 블록 실행 (예외가 없으면 건너뜀)
3. `finally` 블록 실행 (항상)

**finally의 실행 보장:**

- 예외가 발생하지 않아도 실행됩니다.
- 예외가 발생하고 처리되어도 실행됩니다.
- `catch` 블록에서 `return` 문이 있어도 실행됩니다.
- 심지어 `try` 또는 `catch` 블록에서 다른 예외가 발생해도 실행됩니다.

**리소스 정리 예제:**

```csharp
FileStream file = null;

try
{
    Console.WriteLine("파일을 엽니다.");
    file = new FileStream("data.txt", FileMode.Open);
    
    // 파일 작업 수행
    Console.WriteLine("파일 작업 중...");
    
    // 임의로 예외 발생
    throw new Exception("처리 중 오류 발생");
}
catch (Exception ex)
{
    Console.WriteLine($"오류: {ex.Message}");
}
finally
{
    // 예외 발생 여부와 관계없이 파일을 닫음
    if (file != null)
    {
        file.Close();
        Console.WriteLine("파일을 닫았습니다.");
    }
}

Console.WriteLine("프로그램 종료");

// 출력:
// 파일을 엽니다.
// 파일 작업 중...
// 오류: 처리 중 오류 발생
// 파일을 닫았습니다.
// 프로그램 종료
```

**finally와 return:**

```csharp
int Divide(int a, int b)
{
    try
    {
        Console.WriteLine("나눗셈 시도");
        return a / b;
    }
    catch (DivideByZeroException)
    {
        Console.WriteLine("0으로 나눌 수 없습니다.");
        return -1;
    }
    finally
    {
        // return 문이 있어도 finally는 실행됨
        Console.WriteLine("finally 블록 실행");
    }
}

int result = Divide(10, 2);
Console.WriteLine($"결과: {result}");

// 출력:
// 나눗셈 시도
// finally 블록 실행
// 결과: 5
```

**catch 없이 finally만 사용:**

`catch` 블록 없이 `finally`만 사용할 수도 있습니다. 이 경우 예외는 처리되지 않고 상위로 전파되지만, `finally` 블록은 실행됩니다:

```csharp
void ProcessData()
{
    Console.WriteLine("작업 시작");
    
    try
    {
        Console.WriteLine("처리 중...");
        throw new Exception("오류 발생");
    }
    finally
    {
        // 예외가 처리되지 않아도 실행됨
        Console.WriteLine("정리 작업 수행");
    }
    
    // 이 줄은 실행되지 않음 (예외가 전파됨)
    Console.WriteLine("작업 완료");
}

try
{
    ProcessData();
}
catch (Exception ex)
{
    Console.WriteLine($"상위에서 처리: {ex.Message}");
}

// 출력:
// 작업 시작
// 처리 중...
// 정리 작업 수행
// 상위에서 처리: 오류 발생
```

---

## 12.3 예외 던지기 (throw)

`throw` 키워드는 예외를 명시적으로 발생시키는 데 사용됩니다. 예외는 .NET 런타임이 자동으로 발생시키기도 하지만, 개발자가 특정 조건에서 의도적으로 예외를 던질 수도 있습니다.

### throw의 사용 시나리오

1. **입력 검증**: 잘못된 매개변수나 상태를 발견했을 때
2. **비즈니스 규칙 위반**: 애플리케이션의 비즈니스 로직이 위반되었을 때
3. **복구 불가능한 상황**: 프로그램이 계속 실행될 수 없는 상황일 때
4. **예외 재발생**: catch 블록에서 예외를 처리한 후 다시 상위로 전파할 때

### 새 예외 생성 및 던지기

**기본 문법:**

```csharp
throw new 예외타입("오류 메시지");
```

**간단한 예제:**

```csharp
void CheckAge(int age)
{
    if (age < 0)
    {
        throw new ArgumentException("나이는 음수일 수 없습니다.");
    }
    
    if (age < 18)
    {
        throw new InvalidOperationException("성인만 접근할 수 있습니다.");
    }
    
    Console.WriteLine($"접근 허용: {age}세");
}

try
{
    CheckAge(-5);
}
catch (ArgumentException ex)
{
    Console.WriteLine($"인수 오류: {ex.Message}");
}
catch (InvalidOperationException ex)
{
    Console.WriteLine($"작업 오류: {ex.Message}");
}

// 출력:
// 인수 오류: 나이는 음수일 수 없습니다.
```

### 적절한 예외 타입 선택

.NET은 다양한 표준 예외 타입을 제공하며, 상황에 맞는 예외를 선택하는 것이 중요합니다:

**ArgumentException 계열:**

```csharp
void SetName(string name)
{
    if (name == null)
    {
        throw new ArgumentNullException(nameof(name), "이름은 null일 수 없습니다.");
    }
    
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("이름은 비어있을 수 없습니다.", nameof(name));
    }
    
    if (name.Length > 50)
    {
        throw new ArgumentOutOfRangeException(nameof(name), "이름은 50자를 초과할 수 없습니다.");
    }
    
    Console.WriteLine($"이름 설정: {name}");
}
```

**InvalidOperationException:**

```csharp
class BankAccount
{
    private decimal balance = 0;
    
    public void Withdraw(decimal amount)
    {
        if (amount > balance)
        {
            throw new InvalidOperationException($"잔액 부족: 현재 잔액은 {balance}원입니다.");
        }
        
        balance -= amount;
        Console.WriteLine($"{amount}원 출금 완료. 잔액: {balance}원");
    }
}

var account = new BankAccount();

try
{
    account.Withdraw(1000);
}
catch (InvalidOperationException ex)
{
    Console.WriteLine($"오류: {ex.Message}");
}

// 출력:
// 오류: 잔액 부족: 현재 잔액은 0원입니다.
```

### 예외 재발생 (Rethrowing)

`catch` 블록에서 예외를 처리한 후 다시 던질 수 있습니다. 이는 로깅이나 부분적 복구를 수행한 후 상위 호출자에게 예외를 알려야 할 때 유용합니다.

**throw vs throw ex의 차이:**

```csharp
// 방법 1: throw (권장) - 원본 스택 추적 보존
try
{
    int.Parse("abc");
}
catch (Exception ex)
{
    Console.WriteLine("로그 기록");
    throw;  // 원본 예외를 그대로 다시 던짐
}

// 방법 2: throw ex (비권장) - 스택 추적이 여기서부터 시작됨
try
{
    int.Parse("abc");
}
catch (Exception ex)
{
    Console.WriteLine("로그 기록");
    throw ex;  // 새로운 스택 추적이 생성됨
}
```

**실용적인 재발생 예제:**

```csharp
void ProcessFile(string filename)
{
    try
    {
        string content = File.ReadAllText(filename);
        // 파일 처리...
    }
    catch (FileNotFoundException ex)
    {
        // 로그 기록
        Console.WriteLine($"[로그] 파일을 찾을 수 없음: {filename}");
        
        // 예외를 상위로 전파
        throw;
    }
    catch (IOException ex)
    {
        Console.WriteLine($"[로그] I/O 오류 발생: {ex.Message}");
        throw;
    }
}

try
{
    ProcessFile("missing.txt");
}
catch (FileNotFoundException)
{
    Console.WriteLine("상위: 파일이 없습니다. 기본 파일을 사용합니다.");
}

// 출력:
// [로그] 파일을 찾을 수 없음: missing.txt
// 상위: 파일이 없습니다. 기본 파일을 사용합니다.
```

### 조건부 throw 표현식

C# 7.0부터 `throw`를 표현식으로 사용할 수 있어, null 병합 연산자나 조건 연산자와 함께 사용할 수 있습니다:

```csharp
class Person
{
    public string Name { get; }
    
    public Person(string name)
    {
        // name이 null이면 예외를 던짐
        Name = name ?? throw new ArgumentNullException(nameof(name));
    }
}

// 조건 연산자와 함께 사용
int GetValue(bool condition)
{
    return condition ? 100 : throw new InvalidOperationException("조건이 거짓입니다.");
}

try
{
    var person = new Person(null);
}
catch (ArgumentNullException ex)
{
    Console.WriteLine($"오류: {ex.Message}");
}

// 출력:
// 오류: Value cannot be null. (Parameter 'name')
```

---

## 12.4 사용자 정의 예외

표준 예외 타입이 애플리케이션의 특정 오류 상황을 충분히 표현하지 못할 때, 사용자 정의 예외(Custom Exception)를 만들 수 있습니다. 사용자 정의 예외는 `Exception` 클래스를 상속하여 생성하며, 애플리케이션의 도메인에 특화된 의미 있는 예외를 정의할 수 있게 합니다.

### 사용자 정의 예외 생성 규칙

**명명 규칙:**
- 예외 클래스 이름은 `Exception`으로 끝나야 합니다.
- 의미 있고 명확한 이름을 사용합니다 (예: `InsufficientFundsException`, `InvalidUserInputException`).

**권장 구현 패턴:**

```csharp
[Serializable]
public class CustomException : Exception
{
    // 1. 기본 생성자
    public CustomException()
    {
    }
    
    // 2. 메시지를 받는 생성자
    public CustomException(string message) : base(message)
    {
    }
    
    // 3. 메시지와 내부 예외를 받는 생성자
    public CustomException(string message, Exception innerException) 
        : base(message, innerException)
    {
    }
}
```

### 실용적인 사용자 정의 예외

**은행 계좌 예외:**

```csharp
// 잔액 부족 예외
class InsufficientFundsException : Exception
{
    public decimal CurrentBalance { get; }
    public decimal RequestedAmount { get; }
    
    public InsufficientFundsException(decimal currentBalance, decimal requestedAmount)
        : base($"잔액이 부족합니다. 현재: {currentBalance}원, 요청: {requestedAmount}원")
    {
        CurrentBalance = currentBalance;
        RequestedAmount = requestedAmount;
    }
}

// 은행 계좌 클래스
class BankAccount
{
    public decimal Balance { get; private set; }
    
    public BankAccount(decimal initialBalance)
    {
        Balance = initialBalance;
    }
    
    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException("출금 금액은 0보다 커야 합니다.", nameof(amount));
        }
        
        if (amount > Balance)
        {
            throw new InsufficientFundsException(Balance, amount);
        }
        
        Balance -= amount;
        Console.WriteLine($"{amount}원 출금 완료. 잔액: {Balance}원");
    }
}

// 사용 예제
var account = new BankAccount(10000);

try
{
    account.Withdraw(5000);   // 성공
    account.Withdraw(7000);   // 실패
}
catch (InsufficientFundsException ex)
{
    Console.WriteLine($"오류: {ex.Message}");
    Console.WriteLine($"부족한 금액: {ex.RequestedAmount - ex.CurrentBalance}원");
}

// 출력:
// 5000원 출금 완료. 잔액: 5000원
// 오류: 잔액이 부족합니다. 현재: 5000원, 요청: 7000원
// 부족한 금액: 2000원
```

**유효성 검사 예외:**

```csharp
class ValidationException : Exception
{
    public string PropertyName { get; }
    public object InvalidValue { get; }
    
    public ValidationException(string propertyName, object invalidValue, string message)
        : base(message)
    {
        PropertyName = propertyName;
        InvalidValue = invalidValue;
    }
}

class User
{
    private string email;
    
    public string Email
    {
        get => email;
        set
        {
            if (!value.Contains("@"))
            {
                throw new ValidationException(
                    nameof(Email),
                    value,
                    "이메일 주소에 @ 기호가 포함되어야 합니다."
                );
            }
            email = value;
        }
    }
}

var user = new User();

try
{
    user.Email = "invalid-email";
}
catch (ValidationException ex)
{
    Console.WriteLine($"검증 오류: {ex.Message}");
    Console.WriteLine($"속성: {ex.PropertyName}");
    Console.WriteLine($"잘못된 값: {ex.InvalidValue}");
}

// 출력:
// 검증 오류: 이메일 주소에 @ 기호가 포함되어야 합니다.
// 속성: Email
// 잘못된 값: invalid-email
```

**비즈니스 규칙 예외:**

```csharp
class BusinessRuleException : Exception
{
    public string RuleCode { get; }
    
    public BusinessRuleException(string ruleCode, string message) : base(message)
    {
        RuleCode = ruleCode;
    }
}

class OrderProcessor
{
    public void ProcessOrder(int quantity, bool isWeekend)
    {
        if (quantity > 100)
        {
            throw new BusinessRuleException(
                "MAX_QUANTITY",
                "한 번에 최대 100개까지만 주문할 수 있습니다."
            );
        }
        
        if (isWeekend)
        {
            throw new BusinessRuleException(
                "WEEKEND_CLOSED",
                "주말에는 주문을 처리할 수 없습니다."
            );
        }
        
        Console.WriteLine($"{quantity}개 주문이 처리되었습니다.");
    }
}

var processor = new OrderProcessor();

try
{
    processor.ProcessOrder(150, false);
}
catch (BusinessRuleException ex)
{
    Console.WriteLine($"[{ex.RuleCode}] {ex.Message}");
}

// 출력:
// [MAX_QUANTITY] 한 번에 최대 100개까지만 주문할 수 있습니다.
```

---

## 12.5 예외 필터 (Exception Filters)

C# 6.0에서 도입된 **예외 필터(Exception Filters)**는 `when` 키워드를 사용하여 예외를 잡을 때 추가 조건을 지정할 수 있게 해줍니다. 이를 통해 같은 타입의 예외라도 특정 조건을 만족하는 경우에만 처리할 수 있어, 더욱 세밀한 예외 처리가 가능합니다.

### 기본 문법

```csharp
try
{
    // 코드
}
catch (예외타입 변수명) when (조건식)
{
    // 조건이 true일 때만 실행
}
```

조건식은 `bool`을 반환해야 하며, 조건이 `false`이면 해당 `catch` 블록은 건너뛰고 다음 `catch` 블록을 검사합니다.

### 기본 예제

**특정 오류 코드만 처리:**

```csharp
void ProcessData(int code)
{
    if (code < 0)
    {
        throw new ArgumentException($"잘못된 코드: {code}");
    }
}

try
{
    ProcessData(-5);
}
catch (ArgumentException ex) when (ex.Message.Contains("코드: -5"))
{
    Console.WriteLine("특정 오류 코드 -5가 감지되었습니다.");
}
catch (ArgumentException ex)
{
    Console.WriteLine($"일반 인수 오류: {ex.Message}");
}

// 출력:
// 특정 오류 코드 -5가 감지되었습니다.
```

### HTTP 상태 코드 필터링

```csharp
class HttpException : Exception
{
    public int StatusCode { get; }
    
    public HttpException(int statusCode, string message) : base(message)
    {
        StatusCode = statusCode;
    }
}

void MakeHttpRequest(int statusCode)
{
    throw new HttpException(statusCode, $"HTTP 오류 {statusCode}");
}

try
{
    MakeHttpRequest(404);
}
catch (HttpException ex) when (ex.StatusCode == 404)
{
    Console.WriteLine("404 오류: 리소스를 찾을 수 없습니다.");
}
catch (HttpException ex) when (ex.StatusCode >= 500)
{
    Console.WriteLine($"서버 오류 {ex.StatusCode}: 서버에 문제가 있습니다.");
}
catch (HttpException ex)
{
    Console.WriteLine($"HTTP 오류 {ex.StatusCode}: {ex.Message}");
}

// 출력:
// 404 오류: 리소스를 찾을 수 없습니다.
```

### 재시도 로직과 함께 사용

```csharp
int retryCount = 0;
int maxRetries = 3;

while (retryCount < maxRetries)
{
    try
    {
        Console.WriteLine($"시도 {retryCount + 1}");
        
        // 네트워크 작업 시뮬레이션
        Random random = new Random();
        if (random.Next(3) != 0)
        {
            throw new InvalidOperationException("네트워크 오류");
        }
        
        Console.WriteLine("작업 성공!");
        break;
    }
    catch (InvalidOperationException ex) when (retryCount < maxRetries - 1)
    {
        retryCount++;
        Console.WriteLine($"재시도 중... ({ex.Message})");
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"최대 재시도 횟수 초과: {ex.Message}");
        break;
    }
}
```

### 로깅과 예외 필터

예외 필터의 강력한 기능 중 하나는 조건식 내에서 부작용(side effect)을 발생시킬 수 있다는 점입니다. 이를 활용하여 로깅을 수행할 수 있습니다:

```csharp
bool LogException(Exception ex)
{
    Console.WriteLine($"[로그] 예외 발생: {ex.GetType().Name} - {ex.Message}");
    return false;  // false를 반환하여 이 catch 블록을 건너뜀
}

try
{
    throw new InvalidOperationException("작업 실패");
}
catch (Exception ex) when (LogException(ex))
{
    // LogException이 false를 반환하므로 실행되지 않음
}
catch (Exception ex)
{
    Console.WriteLine("예외 처리");
}

// 출력:
// [로그] 예외 발생: InvalidOperationException - 작업 실패
// 예외 처리
```

### 속성 기반 필터링

```csharp
class DatabaseException : Exception
{
    public string TableName { get; }
    public bool IsTransient { get; }
    
    public DatabaseException(string tableName, bool isTransient, string message)
        : base(message)
    {
        TableName = tableName;
        IsTransient = isTransient;
    }
}

try
{
    throw new DatabaseException("Users", true, "연결 시간 초과");
}
catch (DatabaseException ex) when (ex.IsTransient)
{
    Console.WriteLine($"일시적 오류 발생 ({ex.TableName} 테이블). 재시도 가능합니다.");
}
catch (DatabaseException ex)
{
    Console.WriteLine($"영구적 오류 발생 ({ex.TableName} 테이블). 수동 개입이 필요합니다.");
}

// 출력:
// 일시적 오류 발생 (Users 테이블). 재시도 가능합니다.
```

### 복잡한 조건 결합

```csharp
class PaymentException : Exception
{
    public decimal Amount { get; }
    public string PaymentMethod { get; }
    
    public PaymentException(decimal amount, string paymentMethod, string message)
        : base(message)
    {
        Amount = amount;
        PaymentMethod = paymentMethod;
    }
}

try
{
    throw new PaymentException(1500, "신용카드", "결제 거부됨");
}
catch (PaymentException ex) when (ex.Amount < 1000 && ex.PaymentMethod == "신용카드")
{
    Console.WriteLine("소액 신용카드 결제 실패");
}
catch (PaymentException ex) when (ex.Amount >= 1000 && ex.PaymentMethod == "신용카드")
{
    Console.WriteLine($"고액 신용카드 결제 실패: {ex.Amount}원");
    Console.WriteLine("대체 결제 수단을 제안합니다.");
}
catch (PaymentException ex)
{
    Console.WriteLine($"{ex.PaymentMethod} 결제 오류: {ex.Message}");
}

// 출력:
// 고액 신용카드 결제 실패: 1500원
// 대체 결제 수단을 제안합니다.
```

---

## 마무리

이 장에서는 C#의 예외 처리 메커니즘에 대해 학습했습니다. 예외 처리는 견고하고 안정적인 애플리케이션을 만드는 데 필수적인 요소입니다. `try-catch-finally` 구조를 통해 예외를 적절히 처리하고, `throw`를 사용하여 의미 있는 예외를 발생시키며, 사용자 정의 예외로 도메인 특화 오류를 표현하고, 예외 필터로 세밀한 제어를 할 수 있게 되었습니다.

**학습 정리:**

✅ **예외의 개념**: 예외가 무엇이며, 언제 발생하는지 이해했습니다.

✅ **try-catch-finally**: 예외를 처리하는 기본 구조와 리소스 정리 방법을 익혔습니다.

✅ **예외 던지기**: `throw` 키워드를 사용하여 예외를 발생시키고 재발생시키는 방법을 배웠습니다.

✅ **사용자 정의 예외**: 애플리케이션에 특화된 예외 클래스를 만드는 방법을 학습했습니다.

✅ **예외 필터**: `when` 키워드를 활용한 조건부 예외 처리를 익혔습니다.

**모범 사례:**

- 예외는 **예외적인 상황**에서만 사용하고, 일반적인 제어 흐름에는 사용하지 않습니다.
- 가능한 한 **구체적인 예외 타입**을 잡습니다.
- 예외를 잡았다면 **적절히 처리**하거나 **의미 있게 재발생**시킵니다.
- 빈 `catch` 블록은 피하고, 최소한 로깅은 수행합니다.
- `finally` 블록이나 `using` 문을 사용하여 **리소스를 확실히 정리**합니다.

**다음 단계:**

13장에서는 파일 입출력을 다루며, 파일 작업 중 발생할 수 있는 다양한 예외를 어떻게 처리하는지 실전 예제를 통해 학습하게 됩니다. 예외 처리는 파일 I/O, 네트워크 통신, 데이터베이스 작업 등 모든 외부 리소스를 다룰 때 필수적이므로, 이 장에서 배운 내용을 잘 숙지하시기 바랍니다.
