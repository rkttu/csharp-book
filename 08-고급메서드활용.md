# 8장. 고급 메서드 활용

프로그래밍에서 메서드는 단순히 코드를 재사용하는 수단을 넘어, 로직을 추상화하고 표현력을 높이는 강력한 도구입니다. 7장에서 메서드의 기초를 다루었다면, 이 장에서는 C#의 고급 메서드 기능들을 학습하여 더욱 간결하고 표현력 있는 코드를 작성하는 방법을 익히게 됩니다.

람다 식(Lambda Expressions)은 익명 함수를 간결하게 표현하는 현대적인 문법으로, LINQ와 함수형 프로그래밍의 핵심입니다. 확장 메서드(Extension Methods)는 기존 타입에 새로운 메서드를 추가하는 것처럼 보이게 하는 강력한 기능으로, 코드의 가독성을 크게 향상시킵니다. 재귀 함수(Recursive Functions)는 자기 자신을 호출하는 메서드로, 복잡한 문제를 우아하게 해결하는 프로그래밍 기법입니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 다음과 같은 고급 메서드 활용 기법을 학습하게 됩니다:

- **람다 식의 이해와 활용**: 간결한 익명 함수 표현 방식인 람다 식의 문법을 익히고, `Func`와 `Action` 델리게이트를 통해 메서드를 값처럼 다루는 함수형 프로그래밍의 개념을 이해합니다.

- **확장 메서드를 통한 코드 확장성**: 기존 타입을 수정하지 않고도 새로운 기능을 추가하는 확장 메서드의 작성법과 활용 패턴을 학습합니다.

- **재귀 함수의 원리와 적용**: 복잡한 문제를 더 작은 하위 문제로 분할하여 해결하는 재귀적 사고방식을 익히고, 실용적인 재귀 함수 작성법을 배웁니다.

---

## 8.1 람다 식 (Lambda Expressions)

람다 식은 익명 메서드를 간결하게 표현하는 현대적인 문법으로, C# 3.0에서 LINQ와 함께 도입되었습니다. "람다(Lambda)"라는 이름은 1930년대 수학자 알론조 처치(Alonzo Church)가 개발한 람다 계산법(Lambda Calculus)에서 유래했으며, 이는 함수형 프로그래밍의 이론적 기반이 되었습니다.

람다 식은 메서드를 값처럼 다룰 수 있게 해주어, 메서드를 다른 메서드의 인자로 전달하거나 변수에 할당할 수 있게 합니다. 이는 함수형 프로그래밍(Functional Programming)의 핵심 개념인 "일급 함수(First-class Functions)"를 C#에서 구현하는 방법입니다.

**람다 식의 주요 활용 사례:**
- **LINQ 쿼리**: 컬렉션을 필터링, 변환, 정렬할 때
- **이벤트 핸들러**: UI 이벤트 처리를 간결하게 표현할 때
- **비동기 프로그래밍**: 콜백 함수를 간단히 작성할 때
- **함수형 프로그래밍**: 고차 함수(Higher-order Functions)를 활용할 때

### 8.1.1 람다 식 기본 문법

람다 식은 `=>` 연산자(람다 연산자 또는 "goes to" 연산자)를 사용하여 매개변수와 식을 구분합니다. 왼쪽에는 입력 매개변수를, 오른쪽에는 실행할 식이나 문장 블록을 작성합니다.

**기본 구조:**

```
(매개변수) => 식
(매개변수) => { 문장들; return 값; }
```

**람다 식의 역사적 발전:**

람다 식 이전에는 익명 메서드(Anonymous Methods)를 사용했습니다. 다음 예제는 같은 기능을 시대별로 어떻게 표현했는지 보여줍니다:

```csharp
// C# 1.0: 명명된 메서드
int Add(int x, int y)
{
    return x + y;
}

// C# 2.0: 익명 메서드
Func<int, int, int> add1 = delegate(int x, int y)
{
    return x + y;
};

// C# 3.0: 람다 식 (문장 블록)
Func<int, int, int> add2 = (int x, int y) =>
{
    return x + y;
};

// C# 3.0: 람다 식 (식 본문) - 가장 간결
Func<int, int, int> add3 = (x, y) => x + y;

// 사용
Console.WriteLine(add3(5, 3));  // 출력: 8
```

**단순한 람다 식 예제:**

```csharp
// 매개변수가 하나인 람다 식
Func<int, int> square = x => x * x;
Console.WriteLine(square(5));  // 출력: 25

// 매개변수가 두 개인 람다 식
Func<int, int, int> multiply = (a, b) => a * b;
Console.WriteLine(multiply(3, 4));  // 출력: 12

// 매개변수가 없는 람다 식
Func<string> getMessage = () => "Hello, Lambda!";
Console.WriteLine(getMessage());  // 출력: Hello, Lambda!
```

**타입 추론과 명시적 타입:**

C# 컴파일러는 문맥에서 매개변수의 타입을 추론할 수 있지만, 명시적으로 지정할 수도 있습니다:

```csharp
// 타입 추론 (권장)
Func<int, bool> isEven = x => x % 2 == 0;

// 명시적 타입 지정
Func<int, bool> isEven2 = (int x) => x % 2 == 0;

Console.WriteLine(isEven(4));   // 출력: True
Console.WriteLine(isEven(7));   // 출력: False
```

**문장 블록이 있는 람다 식:**

복잡한 로직이 필요한 경우 중괄호를 사용하여 여러 문장을 작성할 수 있습니다. 이 경우 반환값이 있다면 명시적으로 `return` 문을 사용해야 합니다:

```csharp
Func<int, int, string> compareNumbers = (a, b) =>
{
    if (a > b)
        return $"{a}가 더 큽니다";
    else if (a < b)
        return $"{b}가 더 큽니다";
    else
        return "두 수가 같습니다";
};

Console.WriteLine(compareNumbers(10, 5));   // 출력: 10가 더 큽니다
Console.WriteLine(compareNumbers(3, 8));    // 출력: 8가 더 큽니다
Console.WriteLine(compareNumbers(7, 7));    // 출력: 두 수가 같습니다
```

**배열과 리스트에서의 람다 식 활용:**

람다 식은 컬렉션을 다룰 때 가장 빛을 발합니다. LINQ 메서드와 함께 사용하면 매우 강력한 데이터 처리가 가능합니다:

```csharp
// 숫자 리스트
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Where: 짝수만 필터링
var evenNumbers = numbers.Where(n => n % 2 == 0);
Console.WriteLine("짝수: " + string.Join(", ", evenNumbers));
// 출력: 짝수: 2, 4, 6, 8, 10

// Select: 각 숫자를 제곱
var squares = numbers.Select(n => n * n);
Console.WriteLine("제곱: " + string.Join(", ", squares));
// 출력: 제곱: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100

// Where + Select 조합: 홀수만 선택하여 제곱
var oddSquares = numbers.Where(n => n % 2 != 0).Select(n => n * n);
Console.WriteLine("홀수의 제곱: " + string.Join(", ", oddSquares));
// 출력: 홀수의 제곱: 1, 9, 25, 49, 81
```

**문자열 리스트 처리:**

```csharp
List<string> names = new List<string> { "Alice", "Bob", "Charlie", "David", "Eve" };

// 이름 길이가 4자 이상인 것만 필터링
var longNames = names.Where(name => name.Length >= 4);
Console.WriteLine("긴 이름: " + string.Join(", ", longNames));
// 출력: 긴 이름: Alice, Charlie, David

// 모든 이름을 대문자로 변환
var upperNames = names.Select(name => name.ToUpper());
Console.WriteLine("대문자: " + string.Join(", ", upperNames));
// 출력: 대문자: ALICE, BOB, CHARLIE, DAVID, EVE

// 'e'를 포함하는 이름만 선택
var namesWithE = names.Where(name => name.Contains('e', StringComparison.OrdinalIgnoreCase));
Console.WriteLine("'e' 포함: " + string.Join(", ", namesWithE));
// 출력: 'e' 포함: Alice, Charlie, Eve
```

**정렬에서의 람다 식:**

```csharp
List<int> numbers = new List<int> { 5, 2, 8, 1, 9, 3 };

// OrderBy: 오름차순 정렬 (사실 여기서는 람다가 단순히 값 자체를 반환)
var ascending = numbers.OrderBy(n => n);
Console.WriteLine("오름차순: " + string.Join(", ", ascending));
// 출력: 오름차순: 1, 2, 3, 5, 8, 9

// OrderByDescending: 내림차순 정렬
var descending = numbers.OrderByDescending(n => n);
Console.WriteLine("내림차순: " + string.Join(", ", descending));
// 출력: 내림차순: 9, 8, 5, 3, 2, 1

// 복잡한 객체 정렬
var people = new[]
{
    new { Name = "Alice", Age = 30 },
    new { Name = "Bob", Age = 25 },
    new { Name = "Charlie", Age = 35 }
};

var sortedByAge = people.OrderBy(p => p.Age);
foreach (var person in sortedByAge)
{
    Console.WriteLine($"{person.Name}: {person.Age}세");
}
// 출력:
// Bob: 25세
// Alice: 30세
// Charlie: 35세
```

**집계 함수와 람다 식:**

```csharp
List<int> scores = new List<int> { 85, 92, 78, 95, 88 };

// Sum: 합계
int total = scores.Sum(s => s);
Console.WriteLine($"총점: {total}");  // 출력: 총점: 438

// Average: 평균
double average = scores.Average(s => s);
Console.WriteLine($"평균: {average}");  // 출력: 평균: 87.6

// Max, Min: 최대값, 최소값
int maxScore = scores.Max(s => s);
int minScore = scores.Min(s => s);
Console.WriteLine($"최고점: {maxScore}, 최저점: {minScore}");
// 출력: 최고점: 95, 최저점: 78

// Count: 조건을 만족하는 개수
int highScoresCount = scores.Count(s => s >= 90);
Console.WriteLine($"90점 이상: {highScoresCount}개");
// 출력: 90점 이상: 2개
```

### 8.1.2 Func와 Action 델리게이트

델리게이트(Delegate)는 메서드에 대한 참조를 저장하는 타입으로, C#에서 메서드를 일급 객체(first-class citizen)로 다룰 수 있게 해주는 메커니즘입니다. `Func`와 `Action`은 .NET에서 제공하는 제네릭 델리게이트로, 대부분의 상황에서 사용자 정의 델리게이트 없이도 메서드 참조를 다룰 수 있게 해줍니다.

**델리게이트의 역사적 배경:**

델리게이트는 C# 1.0부터 존재했지만, 초기에는 각 시그니처마다 별도의 델리게이트 타입을 선언해야 했습니다. C# 2.0에서 제네릭이 도입되면서 `Func`와 `Action` 같은 범용 델리게이트가 가능해졌고, 이는 코드의 재사용성을 크게 향상시켰습니다.

**Func 델리게이트:**

`Func`는 **반환값이 있는** 메서드를 나타내는 델리게이트입니다. 마지막 타입 매개변수는 반환 타입이고, 그 앞의 타입들은 입력 매개변수입니다.

```csharp
// Func의 기본 형식
// Func<반환타입>                    - 매개변수 없음
// Func<T1, 반환타입>                - 매개변수 1개
// Func<T1, T2, 반환타입>            - 매개변수 2개
// ... 최대 16개의 매개변수까지 지원

// 매개변수 없이 string 반환
Func<string> getGreeting = () => "안녕하세요!";
Console.WriteLine(getGreeting());  // 출력: 안녕하세요!

// int를 받아서 bool 반환
Func<int, bool> isPositive = x => x > 0;
Console.WriteLine(isPositive(5));   // 출력: True
Console.WriteLine(isPositive(-3));  // 출력: False

// 두 int를 받아서 int 반환
Func<int, int, int> add = (a, b) => a + b;
Console.WriteLine(add(10, 20));  // 출력: 30

// string과 int를 받아서 string 반환
Func<string, int, string> repeat = (str, count) =>
{
    string result = "";
    for (int i = 0; i < count; i++)
    {
        result += str;
    }
    return result;
};
Console.WriteLine(repeat("Hello ", 3));  // 출력: Hello Hello Hello
```

**Action 델리게이트:**

`Action`은 **반환값이 없는(void)** 메서드를 나타내는 델리게이트입니다. 반환 타입이 없으므로 모든 타입 매개변수는 입력 매개변수입니다.

```csharp
// Action의 기본 형식
// Action                           - 매개변수 없음
// Action<T1>                       - 매개변수 1개
// Action<T1, T2>                   - 매개변수 2개
// ... 최대 16개의 매개변수까지 지원

// 매개변수 없음
Action greet = () => Console.WriteLine("안녕하세요!");
greet();  // 출력: 안녕하세요!

// string 매개변수 하나
Action<string> printMessage = message => Console.WriteLine($"메시지: {message}");
printMessage("테스트");  // 출력: 메시지: 테스트

// 두 개의 매개변수
Action<string, int> printInfo = (name, age) =>
{
    Console.WriteLine($"이름: {name}");
    Console.WriteLine($"나이: {age}세");
};
printInfo("김철수", 25);
// 출력:
// 이름: 김철수
// 나이: 25세
```

**Func와 Action의 실용적 활용:**

델리게이트를 사용하면 메서드를 매개변수로 전달하거나, 메서드를 동적으로 선택하여 실행할 수 있습니다:

```csharp
// 메서드를 매개변수로 받는 함수
void ProcessNumbers(List<int> numbers, Func<int, int> operation)
{
    foreach (int num in numbers)
    {
        int result = operation(num);
        Console.WriteLine($"{num} -> {result}");
    }
}

List<int> data = new List<int> { 1, 2, 3, 4, 5 };

// 제곱 연산
Console.WriteLine("제곱:");
ProcessNumbers(data, x => x * x);
// 출력:
// 1 -> 1
// 2 -> 4
// 3 -> 9
// 4 -> 16
// 5 -> 25

// 두 배 연산
Console.WriteLine("\n두 배:");
ProcessNumbers(data, x => x * 2);
// 출력:
// 1 -> 2
// 2 -> 4
// 3 -> 6
// 4 -> 8
// 5 -> 10
```

**조건부 실행:**

```csharp
// 사용자 입력에 따라 다른 연산 수행
void Calculate(int a, int b, string operation)
{
    Func<int, int, int> calculator = operation switch
    {
        "+" => (x, y) => x + y,
        "-" => (x, y) => x - y,
        "*" => (x, y) => x * y,
        "/" => (x, y) => x / y,
        _ => (x, y) => 0
    };
    
    int result = calculator(a, b);
    Console.WriteLine($"{a} {operation} {b} = {result}");
}

Calculate(10, 5, "+");  // 출력: 10 + 5 = 15
Calculate(10, 5, "-");  // 출력: 10 - 5 = 5
Calculate(10, 5, "*");  // 출력: 10 * 5 = 50
Calculate(10, 5, "/");  // 출력: 10 / 5 = 2
```

**콜백 패턴:**

델리게이트는 비동기 작업이나 이벤트 처리에서 콜백(callback) 패턴을 구현하는 데 자주 사용됩니다:

```csharp
void DownloadFile(string url, Action<string> onComplete, Action<string> onError)
{
    // 실제로는 비동기 다운로드가 일어남
    Console.WriteLine($"다운로드 중: {url}");
    
    // 성공 시뮬레이션
    if (url.StartsWith("http"))
    {
        onComplete("파일 다운로드 완료!");
    }
    else
    {
        onError("잘못된 URL입니다.");
    }
}

// 사용 예
DownloadFile(
    "https://example.com/file.zip",
    successMessage => Console.WriteLine($"성공: {successMessage}"),
    errorMessage => Console.WriteLine($"오류: {errorMessage}")
);
// 출력:
// 다운로드 중: https://example.com/file.zip
// 성공: 파일 다운로드 완료!
```

**메서드 체이닝과 Fluent API:**

`Func`와 `Action`을 활용하면 유창한(fluent) API 스타일의 코드를 작성할 수 있습니다:

```csharp
class Calculator
{
    private int value;
    
    public Calculator(int initialValue)
    {
        value = initialValue;
    }
    
    public Calculator Apply(Func<int, int> operation)
    {
        value = operation(value);
        return this;
    }
    
    public void Display()
    {
        Console.WriteLine($"결과: {value}");
    }
}

// 메서드 체이닝을 통한 연속 연산
var calc = new Calculator(5);
calc.Apply(x => x * 2)      // 10
    .Apply(x => x + 3)      // 13
    .Apply(x => x * x)      // 169
    .Display();             // 출력: 결과: 169
```

**Predicate 델리게이트:**

`Func<T, bool>`과 동일한 역할을 하는 `Predicate<T>`도 있습니다. 주로 조건 검사에 사용됩니다:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Predicate 사용
Predicate<int> isEven = x => x % 2 == 0;
List<int> evenNumbers = numbers.FindAll(isEven);
Console.WriteLine("짝수: " + string.Join(", ", evenNumbers));
// 출력: 짝수: 2, 4, 6, 8, 10

// Func<int, bool>로도 같은 작업 가능
Func<int, bool> isOdd = x => x % 2 != 0;
var oddNumbers = numbers.Where(isOdd);
Console.WriteLine("홀수: " + string.Join(", ", oddNumbers));
// 출력: 홀수: 1, 3, 5, 7, 9
```

---

## 8.2 확장 메서드 (Extension Methods)

확장 메서드는 기존 타입에 새로운 메서드를 추가하는 것처럼 보이게 하는 C# 3.0의 혁신적인 기능입니다. 실제로는 정적 메서드이지만, 인스턴스 메서드처럼 호출할 수 있어 코드의 가독성과 표현력을 크게 향상시킵니다.

**확장 메서드의 설계 철학:**

확장 메서드는 "개방-폐쇄 원칙(Open-Closed Principle)"을 구현하는 우아한 방법입니다. 기존 클래스의 소스 코드를 수정하지 않고(폐쇄), 새로운 기능을 추가할 수 있어(개방) 코드의 안정성을 유지하면서도 확장성을 제공합니다. 특히 수정할 수 없는 타입(sealed 클래스, 기본 타입, 외부 라이브러리의 타입)에 기능을 추가할 때 매우 유용합니다.

LINQ의 대부분의 메서드(`Where`, `Select`, `OrderBy` 등)가 확장 메서드로 구현되어 있으며, 이는 확장 메서드가 얼마나 강력한 기능인지 보여주는 좋은 예입니다.

**확장 메서드의 정의 규칙:**

1. **정적 클래스**에 정의해야 합니다
2. **정적 메서드**여야 합니다
3. 첫 번째 매개변수에 **`this` 키워드**를 붙여야 합니다
4. 첫 번째 매개변수의 타입이 확장할 대상 타입입니다

**기본 구조:**

```csharp
public static class 확장메서드클래스명
{
    public static 반환타입 메서드명(this 확장할타입 매개변수, 추가매개변수들...)
    {
        // 메서드 구현
    }
}
```

**문자열 확장 메서드 예제:**

```csharp
// 확장 메서드를 담을 정적 클래스
public static class StringExtensions
{
    // 문자열이 특정 길이 이상인지 확인
    public static bool IsLongerThan(this string str, int length)
    {
        return str != null && str.Length > length;
    }
    
    // 문자열을 지정된 횟수만큼 반복
    public static string Repeat(this string str, int count)
    {
        if (str == null || count <= 0)
            return string.Empty;
            
        return string.Concat(Enumerable.Repeat(str, count));
    }
    
    // 문자열의 단어 개수 세기
    public static int WordCount(this string str)
    {
        if (string.IsNullOrWhiteSpace(str))
            return 0;
            
        return str.Split(new[] { ' ', '\t', '\n' }, 
                        StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

// 사용 예제
string text = "Hello";

// 확장 메서드를 인스턴스 메서드처럼 호출
bool isLong = text.IsLongerThan(3);
Console.WriteLine($"'{text}'는 3자보다 길까요? {isLong}");
// 출력: 'Hello'는 3자보다 길까요? True

string repeated = text.Repeat(3);
Console.WriteLine(repeated);
// 출력: HelloHelloHello

string sentence = "This is a sample sentence";
int words = sentence.WordCount();
Console.WriteLine($"단어 개수: {words}");
// 출력: 단어 개수: 5
```

**정수 확장 메서드:**

```csharp
public static class IntExtensions
{
    // 숫자가 짝수인지 확인
    public static bool IsEven(this int number)
    {
        return number % 2 == 0;
    }
    
    // 숫자가 홀수인지 확인
    public static bool IsOdd(this int number)
    {
        return number % 2 != 0;
    }
    
    // 숫자의 팩토리얼 계산
    public static long Factorial(this int number)
    {
        if (number < 0)
            throw new ArgumentException("음수는 팩토리얼을 계산할 수 없습니다.");
        if (number == 0 || number == 1)
            return 1;
            
        long result = 1;
        for (int i = 2; i <= number; i++)
        {
            result *= i;
        }
        return result;
    }
}

// 사용 예제
int num = 5;

Console.WriteLine($"{num}은 짝수? {num.IsEven()}");
Console.WriteLine($"{num}은 홀수? {num.IsOdd()}");
// 출력:
// 5은 짝수? False
// 5은 홀수? True

Console.WriteLine($"{num}! = {num.Factorial()}");
// 출력: 5! = 120
```

**컬렉션 확장 메서드:**

```csharp
public static class CollectionExtensions
{
    // 리스트의 각 요소를 출력
    public static void Print<T>(this IEnumerable<T> collection)
    {
        foreach (var item in collection)
        {
            Console.WriteLine(item);
        }
    }
    
    // 리스트가 비어있거나 null인지 확인
    public static bool IsNullOrEmpty<T>(this IEnumerable<T> collection)
    {
        return collection == null || !collection.Any();
    }
    
    // 리스트의 모든 요소를 구분자로 연결
    public static string JoinString<T>(this IEnumerable<T> collection, string separator)
    {
        return string.Join(separator, collection);
    }
}

// 사용 예제
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

Console.WriteLine("숫자 출력:");
numbers.Print();
// 출력:
// 1
// 2
// 3
// 4
// 5

bool isEmpty = numbers.IsNullOrEmpty();
Console.WriteLine($"리스트가 비어있나요? {isEmpty}");
// 출력: 리스트가 비어있나요? False

string joined = numbers.JoinString(" -> ");
Console.WriteLine(joined);
// 출력: 1 -> 2 -> 3 -> 4 -> 5
```

**확장 메서드 호출 방식:**

확장 메서드는 두 가지 방식으로 호출할 수 있습니다:

```csharp
string text = "Hello";

// 1. 인스턴스 메서드 스타일 (권장)
bool result1 = text.IsLongerThan(3);

// 2. 정적 메서드 스타일
bool result2 = StringExtensions.IsLongerThan(text, 3);

// 두 방식은 완전히 동일한 결과를 생성
Console.WriteLine($"방법 1: {result1}");  // 출력: 방법 1: True
Console.WriteLine($"방법 2: {result2}");  // 출력: 방법 2: True
```

**확장 메서드의 제약과 주의사항:**

1. **우선순위**: 확장 메서드는 인스턴스 메서드보다 우선순위가 낮습니다. 동일한 시그니처의 인스턴스 메서드가 있으면 그것이 호출됩니다.

2. **접근 제한**: 확장 메서드는 `public` 멤버만 접근할 수 있습니다. `private`이나 `protected` 멤버는 접근할 수 없습니다.

3. **네임스페이스**: 확장 메서드를 사용하려면 해당 확장 메서드가 정의된 네임스페이스를 `using`으로 포함해야 합니다.

```csharp
// 확장 메서드 정의 (MyExtensions 네임스페이스)
namespace MyExtensions
{
    public static class IntExtensions
    {
        public static bool IsPositive(this int number)
        {
            return number > 0;
        }
    }
}

// 다른 파일에서 사용
using MyExtensions;  // 이 using이 필요함

int num = 5;
bool positive = num.IsPositive();  // 이제 사용 가능
```

**실용적인 확장 메서드 예제 - 날짜 처리:**

```csharp
public static class DateTimeExtensions
{
    public static bool IsWeekend(this DateTime date)
    {
        return date.DayOfWeek == DayOfWeek.Saturday 
            || date.DayOfWeek == DayOfWeek.Sunday;
    }
    
    public static bool IsWeekday(this DateTime date)
    {
        return !date.IsWeekend();
    }
    
    public static string ToKoreanDateString(this DateTime date)
    {
        string[] dayNames = { "일", "월", "화", "수", "목", "금", "토" };
        return $"{date.Year}년 {date.Month}월 {date.Day}일 ({dayNames[(int)date.DayOfWeek]}요일)";
    }
}

// 사용 예제
DateTime today = DateTime.Now;

Console.WriteLine(today.ToKoreanDateString());
Console.WriteLine($"주말인가요? {today.IsWeekend()}");
Console.WriteLine($"평일인가요? {today.IsWeekday()}");
```

**메서드 체이닝:**

확장 메서드는 메서드 체이닝을 통해 더욱 가독성 높은 코드를 작성할 수 있게 해줍니다:

```csharp
public static class StringChainExtensions
{
    public static string RemoveSpaces(this string str)
    {
        return str.Replace(" ", "");
    }
    
    public static string Capitalize(this string str)
    {
        if (string.IsNullOrEmpty(str))
            return str;
        return char.ToUpper(str[0]) + str.Substring(1).ToLower();
    }
    
    public static string AddQuotes(this string str)
    {
        return $"\"{str}\"";
    }
}

// 메서드 체이닝 사용
string text = "  hello world  ";
string result = text.Trim()
                   .RemoveSpaces()
                   .Capitalize()
                   .AddQuotes();

Console.WriteLine(result);
// 출력: "Helloworld"
```

---

## 8.3 재귀 함수

재귀 함수(Recursive Function)는 자기 자신을 호출하는 함수로, 복잡한 문제를 더 작고 단순한 하위 문제로 분할하여 해결하는 강력한 프로그래밍 기법입니다. 재귀는 "분할 정복(Divide and Conquer)" 알고리즘의 핵심 원리이며, 많은 알고리즘과 자료구조(트리, 그래프 탐색 등)의 자연스러운 표현 방법입니다.

**재귀의 수학적 기반:**

재귀는 수학의 귀납법(Mathematical Induction)과 밀접한 관련이 있습니다. 수학에서 팩토리얼은 다음과 같이 재귀적으로 정의됩니다:
- n! = n × (n-1)!
- 0! = 1 (기저 조건)

이러한 수학적 정의를 프로그래밍 코드로 거의 직접적으로 옮길 수 있다는 점이 재귀의 아름다움입니다.

**재귀 함수의 필수 요소:**

모든 재귀 함수는 다음 두 가지 요소를 반드시 포함해야 합니다:

1. **기저 조건(Base Case)**: 재귀를 멈추는 종료 조건. 이것이 없으면 무한 재귀에 빠져 스택 오버플로우가 발생합니다.
2. **재귀 호출(Recursive Call)**: 문제를 더 작은 하위 문제로 분할하여 자기 자신을 다시 호출하는 부분.

**기본 예제 - 팩토리얼:**

팩토리얼(n!)은 1부터 n까지의 모든 양의 정수를 곱한 값입니다. 예를 들어 5! = 5 × 4 × 3 × 2 × 1 = 120입니다.

```csharp
// 재귀적 팩토리얼
int Factorial(int n)
{
    // 기저 조건: 0! = 1, 1! = 1
    if (n <= 1)
    {
        return 1;
    }
    
    // 재귀 호출: n! = n × (n-1)!
    return n * Factorial(n - 1);
}

// 사용 예제
Console.WriteLine($"5! = {Factorial(5)}");   // 출력: 5! = 120
Console.WriteLine($"10! = {Factorial(10)}"); // 출력: 10! = 3628800

// 재귀 과정 시각화:
// Factorial(5)
//   = 5 * Factorial(4)
//   = 5 * (4 * Factorial(3))
//   = 5 * (4 * (3 * Factorial(2)))
//   = 5 * (4 * (3 * (2 * Factorial(1))))
//   = 5 * (4 * (3 * (2 * 1)))
//   = 5 * (4 * (3 * 2))
//   = 5 * (4 * 6)
//   = 5 * 24
//   = 120
```

**재귀 vs 반복문 비교:**

같은 문제를 재귀와 반복문 두 가지 방식으로 해결할 수 있습니다:

```csharp
// 재귀 방식
int FactorialRecursive(int n)
{
    if (n <= 1)
        return 1;
    return n * FactorialRecursive(n - 1);
}

// 반복문 방식
int FactorialIterative(int n)
{
    int result = 1;
    for (int i = 2; i <= n; i++)
    {
        result *= i;
    }
    return result;
}

// 두 방식 모두 같은 결과
Console.WriteLine(FactorialRecursive(5));  // 출력: 120
Console.WriteLine(FactorialIterative(5));  // 출력: 120
```

**재귀의 장단점:**

**장점:**
- **코드 간결성**: 복잡한 문제를 매우 간결하게 표현할 수 있음
- **자연스러운 표현**: 수학적 정의나 자료구조의 정의를 거의 그대로 코드로 옮길 수 있음
- **분할 정복**: 큰 문제를 작은 문제로 나누는 사고방식을 자연스럽게 구현

**단점:**
- **메모리 사용**: 각 재귀 호출마다 스택 메모리를 사용하여, 깊은 재귀는 스택 오버플로우를 유발할 수 있음
- **성능**: 일반적으로 반복문보다 느리며, 중복 계산이 발생할 수 있음 (메모이제이션으로 해결 가능)
- **디버깅 난이도**: 재귀 흐름을 추적하기 어려울 수 있음

**피보나치 수열:**

피보나치 수열은 재귀의 고전적인 예제입니다. 각 항은 앞의 두 항의 합입니다: 0, 1, 1, 2, 3, 5, 8, 13, 21, ...

```csharp
// 재귀적 피보나치 (비효율적)
int FibonacciRecursive(int n)
{
    // 기저 조건
    if (n <= 1)
        return n;
    
    // 재귀 호출
    return FibonacciRecursive(n - 1) + FibonacciRecursive(n - 2);
}

// 반복문 피보나치 (효율적)
int FibonacciIterative(int n)
{
    if (n <= 1)
        return n;
    
    int prev = 0, curr = 1;
    for (int i = 2; i <= n; i++)
    {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}

// 사용 예제
Console.WriteLine("피보나치 수열 (재귀):");
for (int i = 0; i <= 10; i++)
{
    Console.Write($"{FibonacciRecursive(i)} ");
}
Console.WriteLine();
// 출력: 0 1 1 2 3 5 8 13 21 34 55

Console.WriteLine("\n피보나치 수열 (반복문):");
for (int i = 0; i <= 10; i++)
{
    Console.Write($"{FibonacciIterative(i)} ");
}
Console.WriteLine();
// 출력: 0 1 1 2 3 5 8 13 21 34 55
```

**주의:** 단순 재귀 피보나치는 O(2^n)의 시간 복잡도를 가져 매우 비효율적입니다. 큰 n 값에는 사용하지 않는 것이 좋습니다.

**배열의 합 구하기:**

```csharp
// 재귀로 배열의 합 구하기
int SumArray(int[] array, int index)
{
    // 기저 조건: 배열의 끝에 도달
    if (index >= array.Length)
        return 0;
    
    // 재귀 호출: 현재 요소 + 나머지 배열의 합
    return array[index] + SumArray(array, index + 1);
}

int[] numbers = { 1, 2, 3, 4, 5 };
int total = SumArray(numbers, 0);
Console.WriteLine($"배열의 합: {total}");
// 출력: 배열의 합: 15
```

**문자열 뒤집기:**

```csharp
// 재귀로 문자열 뒤집기
string ReverseString(string str)
{
    // 기저 조건: 빈 문자열이거나 한 글자
    if (str.Length <= 1)
        return str;
    
    // 재귀 호출: 첫 글자를 제외한 나머지를 뒤집고, 첫 글자를 뒤에 추가
    return ReverseString(str.Substring(1)) + str[0];
}

string original = "Hello";
string reversed = ReverseString(original);
Console.WriteLine($"원본: {original}");
Console.WriteLine($"뒤집기: {reversed}");
// 출력:
// 원본: Hello
// 뒤집기: olleH
```

**최대공약수 (유클리드 알고리즘):**

유클리드 알고리즘은 재귀의 우아함을 보여주는 훌륭한 예입니다:

```csharp
// 최대공약수 (GCD) - 재귀
int GCD(int a, int b)
{
    // 기저 조건: b가 0이면 a가 최대공약수
    if (b == 0)
        return a;
    
    // 재귀 호출: GCD(b, a % b)
    return GCD(b, a % b);
}

Console.WriteLine($"GCD(48, 18) = {GCD(48, 18)}");  // 출력: GCD(48, 18) = 6
Console.WriteLine($"GCD(100, 35) = {GCD(100, 35)}"); // 출력: GCD(100, 35) = 5

// 재귀 과정:
// GCD(48, 18)
//   = GCD(18, 48 % 18)
//   = GCD(18, 12)
//   = GCD(12, 18 % 12)
//   = GCD(12, 6)
//   = GCD(6, 12 % 6)
//   = GCD(6, 0)
//   = 6
```

**거듭제곱 계산:**

```csharp
// x의 n제곱을 재귀로 계산
double Power(double x, int n)
{
    // 기저 조건: x^0 = 1
    if (n == 0)
        return 1;
    
    // 음수 지수 처리
    if (n < 0)
        return 1.0 / Power(x, -n);
    
    // 재귀 호출
    return x * Power(x, n - 1);
}

Console.WriteLine($"2^5 = {Power(2, 5)}");    // 출력: 2^5 = 32
Console.WriteLine($"3^4 = {Power(3, 4)}");    // 출력: 3^4 = 81
Console.WriteLine($"2^-3 = {Power(2, -3)}");  // 출력: 2^-3 = 0.125
```

**재귀의 실용적 활용 - 파일 시스템 탐색:**

재귀는 트리 구조(디렉토리, XML, JSON 등)를 다룰 때 자연스러운 해법을 제공합니다:

```csharp
void PrintDirectory(string path, int depth = 0)
{
    try
    {
        // 들여쓰기
        string indent = new string(' ', depth * 2);
        
        // 현재 디렉토리 출력
        string dirName = Path.GetFileName(path);
        Console.WriteLine($"{indent}[폴더] {dirName}");
        
        // 파일들 출력
        foreach (string file in Directory.GetFiles(path))
        {
            string fileName = Path.GetFileName(file);
            Console.WriteLine($"{indent}  - {fileName}");
        }
        
        // 하위 디렉토리를 재귀적으로 탐색
        foreach (string subDir in Directory.GetDirectories(path))
        {
            PrintDirectory(subDir, depth + 1);
        }
    }
    catch (UnauthorizedAccessException)
    {
        // 접근 권한이 없는 디렉토리는 건너뜀
    }
}

// 사용 예제 (주의: 실제 경로로 테스트)
// PrintDirectory(@"C:\MyFolder");
```

**꼬리 재귀 최적화:**

꼬리 재귀(Tail Recursion)는 재귀 호출이 함수의 마지막 연산인 경우를 말합니다. 일부 컴파일러는 이를 반복문으로 최적화할 수 있습니다:

```csharp
// 일반 재귀 (꼬리 재귀 아님)
int FactorialNormal(int n)
{
    if (n <= 1)
        return 1;
    return n * FactorialNormal(n - 1);  // 곱셈 연산이 재귀 호출 후에 수행됨
}

// 꼬리 재귀
int FactorialTail(int n, int accumulator = 1)
{
    if (n <= 1)
        return accumulator;
    return FactorialTail(n - 1, n * accumulator);  // 재귀 호출이 마지막 연산
}

Console.WriteLine(FactorialNormal(5));  // 출력: 120
Console.WriteLine(FactorialTail(5));    // 출력: 120
```

**재귀 사용 시 주의사항:**

1. **항상 기저 조건 확인**: 기저 조건이 없으면 무한 재귀로 인한 스택 오버플로우 발생
2. **재귀 깊이 고려**: C#의 기본 스택 크기는 제한적이므로 너무 깊은 재귀는 피해야 함
3. **성능 고려**: 중복 계산이 많은 경우 메모이제이션이나 반복문 사용 고려
4. **디버깅**: 재귀 호출의 흐름을 추적할 수 있도록 적절한 로깅 추가

```csharp
// 재귀 깊이 제한 예제
int SafeRecursive(int n, int maxDepth = 1000)
{
    if (n <= 1 || maxDepth <= 0)
        return 1;
    return n * SafeRecursive(n - 1, maxDepth - 1);
}
```

---

## 마무리

이 장에서는 C#의 고급 메서드 활용 기법을 학습했습니다. 람다 식을 통해 간결하고 표현력 있는 함수형 코드를 작성하는 방법을 익혔고, `Func`와 `Action` 델리게이트를 사용하여 메서드를 일급 객체로 다루는 방법을 배웠습니다. 확장 메서드를 통해 기존 타입에 새로운 기능을 추가하는 우아한 방법을 이해했으며, 재귀 함수를 활용하여 복잡한 문제를 분할 정복하는 기법을 학습했습니다.

이러한 고급 기법들은 단순히 코드를 짧게 만드는 것을 넘어서, 코드의 의도를 더 명확하게 전달하고 유지보수성을 향상시키는 강력한 도구입니다. 특히 LINQ와 함께 사용될 때 이러한 기법들의 진가가 발휘됩니다.

**학습 정리:**

✅ **람다 식 마스터**: 익명 함수를 간결하게 표현하는 람다 식 문법과 활용법
✅ **델리게이트 이해**: `Func`와 `Action`을 통한 메서드의 일급 객체화
✅ **확장 메서드 활용**: 기존 타입을 확장하는 우아한 방법
✅ **재귀 함수 구현**: 자기 자신을 호출하여 문제를 해결하는 재귀적 사고

**다음 단계:**

9장에서는 객체지향 프로그래밍의 핵심인 클래스와 객체에 대해 학습하게 됩니다. 지금까지 배운 메서드 활용 기법들은 클래스 설계와 결합되어 더욱 강력한 추상화를 가능하게 합니다.

**실습 과제:**

1. 문자열 리스트에서 길이가 5 이상인 단어만 필터링하고 대문자로 변환하는 람다 식 작성
2. DateTime 타입에 한국어 형식으로 날짜를 출력하는 확장 메서드 추가
3. 이진 탐색(Binary Search) 알고리즘을 재귀 함수로 구현
4. 사용자 정의 컬렉션에 LINQ 스타일의 확장 메서드 추가
