# 30장. C# 11 주요 기능

C# 11은 2022년 11월 .NET 7과 함께 출시된 버전으로, 문자열 처리의 개선, 제네릭 프로그래밍의 강화, 그리고 패턴 매칭의 확장을 중심으로 한 주요 릴리스입니다. 이 버전은 개발자의 생산성을 더욱 향상시키고, 코드의 표현력과 성능을 개선하는 데 초점을 맞췄습니다.

**C# 11의 설계 철학:**

C# 11의 개발은 다음과 같은 핵심 원칙을 중심으로 진행되었습니다:

1. **향상된 문자열 처리**: Raw string literals를 통해 복잡한 문자열을 더 쉽게 다룰 수 있게 합니다.
2. **제네릭의 확장**: Generic attributes와 generic math를 통해 제네릭 프로그래밍의 가능성을 확대합니다.
3. **패턴 매칭 강화**: List patterns를 통해 컬렉션에 대한 패턴 매칭을 지원합니다.
4. **타입 안전성**: Required members를 통해 객체 초기화의 안전성을 강화합니다.

## 이 장에서 배울 내용

- **Raw string literals**: 여러 줄의 문자열과 특수 문자를 쉽게 다루는 방법
- **Generic attributes**: 제네릭 타입을 사용할 수 있는 특성
- **List patterns**: 컬렉션의 요소를 패턴 매칭하는 방법
- **Required members**: 필수로 초기화해야 하는 멤버 선언
- **File-local types**: 파일 범위로 제한된 타입 선언
- **기타 개선사항**: Generic math, ref fields, unsigned right-shift 등

---

## 30.1 Raw String Literals (원시 문자열 리터럴)

Raw string literals는 C# 11의 가장 눈에 띄는 기능 중 하나로, 복잡한 문자열(JSON, XML, SQL, 정규식 등)을 이스케이프 없이 직접 작성할 수 있게 합니다.

**문제 상황 - 전통적 접근의 한계:**

기존 C#에서 여러 줄의 JSON이나 SQL을 문자열로 표현하려면 이스케이프 문자나 verbatim string(`@`)을 사용해야 했습니다:

```csharp
// 전통적인 방식 - 이스케이프 필요
string json = "{\"name\":\"홍길동\",\"age\":30}";

// Verbatim string - 여러 줄 가능하지만 따옴표 이스케이프 필요
string sql = @"
SELECT *
FROM Users
WHERE Name = ""홍길동""
";
```

**Raw String Literals의 해결책:**

Raw string literals는 최소 3개의 따옴표(`"""`)로 시작하고 끝나며, 내부의 모든 문자를 그대로 표현합니다:

```csharp
// Raw string literal - 이스케이프 불필요
string json = """
{
    "name": "홍길동",
    "age": 30,
    "address": "서울시 강남구"
}
""";

// SQL 쿼리도 간단하게
string sql = """
SELECT *
FROM Users
WHERE Name = '홍길동'
    AND Age > 20
""";

// 정규식도 명확하게
string regex = """^\d{3}-\d{4}-\d{4}$""";
```

**문자열 보간과 결합:**

Raw string literals는 문자열 보간과도 함께 사용할 수 있습니다:

```csharp
string name = "홍길동";
int age = 30;

string json = $$"""
{
    "name": "{{name}}",
    "age": {{age}},
    "timestamp": "{{DateTime.Now:yyyy-MM-dd}}"
}
""";

Console.WriteLine(json);
```

**주의사항:**
- `$` 기호의 개수만큼 중괄호를 사용해야 합니다 (`$$"""` → `{{}}`)
- 여러 줄 문자열의 들여쓰기는 닫는 따옴표의 위치를 기준으로 결정됩니다

**실전 예제 - API 응답 생성:**

```csharp
// API 응답 JSON 생성
string CreateApiResponse(string status, string message, object data)
{
    string dataJson = System.Text.Json.JsonSerializer.Serialize(data);
    
    return $$"""
    {
        "status": "{{status}}",
        "message": "{{message}}",
        "data": {{dataJson}},
        "timestamp": "{{DateTime.UtcNow:O}}"
    }
    """;
}

var response = CreateApiResponse("success", "데이터 조회 완료", new { id = 1, name = "테스트" });
Console.WriteLine(response);
```

---

## 30.2 Generic Attributes (제네릭 특성)

C# 11 이전에는 특성(Attributes)에 제네릭 타입 매개변수를 직접 사용할 수 없었습니다. C# 11에서는 제네릭 타입을 사용하는 특성을 정의할 수 있게 되었습니다.

**문제 상황:**

```csharp
// C# 10 이전 - 타입 정보를 Type으로 전달해야 함
public class TypedAttribute : Attribute
{
    public TypedAttribute(Type type)
    {
        Type = type;
    }
    
    public Type Type { get; }
}

// 사용 - 타입 안전하지 않음
[Typed(typeof(string))]
public class MyClass { }
```

**Generic Attributes 해결책:**

```csharp
// C# 11 - 제네릭 특성
public class TypedAttribute<T> : Attribute
{
    public Type Type => typeof(T);
}

// 사용 - 타입 안전
[Typed<string>]
public class MyClass { }

[Typed<int>]
public class MyOtherClass { }
```

**실전 예제 - 의존성 주입:**

```csharp
// 서비스 등록 특성
public class RegisterServiceAttribute<TService, TImplementation> : Attribute
    where TImplementation : TService
{
    public Type ServiceType => typeof(TService);
    public Type ImplementationType => typeof(TImplementation);
}

// 사용
public interface IUserService
{
    User GetUser(int id);
}

[RegisterService<IUserService, UserService>]
public class UserService : IUserService
{
    public User GetUser(int id)
    {
        // 구현
        return new User { Id = id, Name = "사용자" };
    }
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
```

---

## 30.3 List Patterns (리스트 패턴)

List patterns는 배열이나 리스트의 요소에 대해 패턴 매칭을 수행할 수 있게 해줍니다. 이는 함수형 프로그래밍 언어의 패턴 매칭과 유사한 기능입니다.

**기본 문법:**

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };

// 첫 번째와 마지막 요소 매칭
if (numbers is [var first, .., var last])
{
    Console.WriteLine($"첫 번째: {first}, 마지막: {last}");
    // 출력: 첫 번째: 1, 마지막: 5
}

// 특정 패턴 매칭
if (numbers is [1, 2, ..])
{
    Console.WriteLine("1, 2로 시작하는 배열");
}

// 정확한 길이 매칭
if (numbers is [_, _, _])
{
    Console.WriteLine("정확히 3개의 요소");
}
else if (numbers is [_, _, _, _, _])
{
    Console.WriteLine("정확히 5개의 요소");
}
```

**실전 예제 - 명령어 파싱:**

```csharp
void ProcessCommand(string[] args)
{
    switch (args)
    {
        case ["help"]:
            ShowHelp();
            break;
            
        case ["create", var name]:
            CreateItem(name);
            break;
            
        case ["delete", var id]:
            DeleteItem(id);
            break;
            
        case ["update", var id, .. var properties]:
            UpdateItem(id, properties);
            break;
            
        case ["list", .. var options]:
            ListItems(options);
            break;
            
        default:
            Console.WriteLine("알 수 없는 명령어");
            break;
    }
}

void ShowHelp() => Console.WriteLine("도움말을 표시합니다.");
void CreateItem(string name) => Console.WriteLine($"'{name}' 생성");
void DeleteItem(string id) => Console.WriteLine($"ID {id} 삭제");
void UpdateItem(string id, string[] properties) 
    => Console.WriteLine($"ID {id} 업데이트: {string.Join(", ", properties)}");
void ListItems(string[] options) 
    => Console.WriteLine($"목록 표시 (옵션: {string.Join(", ", options)})");

// 사용 예
ProcessCommand(new[] { "help" });
ProcessCommand(new[] { "create", "새 항목" });
ProcessCommand(new[] { "update", "123", "name=홍길동", "age=30" });
```

**슬라이스 패턴:**

```csharp
int[] scores = { 95, 87, 92, 78, 88, 91 };

// 첫 3개와 나머지 분리
if (scores is [var s1, var s2, var s3, .. var rest])
{
    Console.WriteLine($"상위 3개: {s1}, {s2}, {s3}");
    Console.WriteLine($"나머지: {string.Join(", ", rest)}");
}

// 중간 요소 건너뛰기
if (scores is [var first, .., var last])
{
    Console.WriteLine($"첫 점수: {first}, 마지막 점수: {last}");
}
```

---

## 30.4 Required Members (필수 멤버)

Required members는 객체 초기화 시 반드시 설정해야 하는 속성이나 필드를 표시할 수 있게 합니다. 이는 컴파일 타임에 검증되어 런타임 오류를 방지합니다.

**문제 상황:**

```csharp
// 기존 방식 - 생성자 오버로드 또는 런타임 검증
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public Person(string name, int age)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
        Age = age;
    }
}

// 또는 초기화 후 검증
public class PersonV2
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public void Validate()
    {
        if (string.IsNullOrEmpty(Name))
            throw new InvalidOperationException("Name은 필수입니다.");
    }
}
```

**Required Members 해결책:**

```csharp
public class Person
{
    public required string Name { get; set; }
    public required int Age { get; set; }
    public string? Email { get; set; }  // 선택적
}

// 컴파일 성공
var person1 = new Person { Name = "홍길동", Age = 30 };

// 컴파일 오류! Name이 설정되지 않음
// var person2 = new Person { Age = 30 };
```

**생성자와 함께 사용:**

```csharp
public class Product
{
    public required string Name { get; set; }
    public required decimal Price { get; set; }
    public string Description { get; set; }
    
    public Product()
    {
        Description = "설명 없음";
    }
}

// Name과 Price는 반드시 설정해야 함
var product = new Product 
{ 
    Name = "노트북", 
    Price = 1500000 
};
```

**SetsRequiredMembers 특성:**

생성자에서 required 멤버를 모두 설정하는 경우, `SetsRequiredMembers` 특성을 사용하여 호출자가 다시 설정하지 않아도 되게 할 수 있습니다:

```csharp
public class User
{
    public required string Username { get; set; }
    public required string Email { get; set; }
    
    [SetsRequiredMembers]
    public User(string username, string email)
    {
        Username = username;
        Email = email;
    }
}

// 생성자 사용 시 required 멤버 설정 불필요
var user = new User("hong", "hong@example.com");
```

---

## 30.5 File-local Types (파일 범위 타입)

`file` 접근 제한자를 사용하여 타입의 가시성을 현재 파일로만 제한할 수 있습니다. 이는 구현 세부사항을 숨기고 네임스페이스 오염을 방지하는 데 유용합니다.

**기본 사용법:**

```csharp
// MyClass.cs
file class Helper
{
    public static string Format(string text)
    {
        return text.ToUpper();
    }
}

public class MyClass
{
    public string Process(string input)
    {
        return Helper.Format(input);  // 같은 파일 내에서만 접근 가능
    }
}
```

**실전 예제 - 파일별 확장 메서드:**

```csharp
// StringExtensions.cs
file static class StringExtensions
{
    public static bool IsValidEmail(this string email)
    {
        return email.Contains("@") && email.Contains(".");
    }
}

public class EmailValidator
{
    public bool Validate(string email)
    {
        // 이 파일에서만 IsValidEmail 확장 메서드 사용 가능
        return email.IsValidEmail();
    }
}
```

---

## 30.6 기타 C# 11 개선사항

### Generic Math Support (제네릭 수학 지원)

제네릭 코드에서 수학 연산을 수행할 수 있게 하는 인터페이스가 추가되었습니다:

```csharp
using System.Numerics;

// 제네릭 수학 함수
T Add<T>(T left, T right) where T : INumber<T>
{
    return left + right;
}

// 다양한 숫자 타입에서 작동
Console.WriteLine(Add(1, 2));           // int
Console.WriteLine(Add(1.5, 2.3));       // double
Console.WriteLine(Add(1.5m, 2.3m));     // decimal
```

### Unsigned Right-shift Operator (부호 없는 오른쪽 시프트 연산자)

`>>>` 연산자를 사용하여 부호 없는 오른쪽 시프트를 수행할 수 있습니다:

```csharp
int value = -8;  // 11111111111111111111111111111000 (2의 보수)

// 기존 >> 연산자 - 부호 비트 유지
int signed = value >> 2;    // -2

// 새로운 >>> 연산자 - 부호 비트를 0으로 채움
int unsigned = value >>> 2;  // 1073741822

Console.WriteLine($"Signed: {signed}, Unsigned: {unsigned}");
```

### Extended nameof Scope (확장된 nameof 범위)

메서드 매개변수 내에서 `nameof`를 사용할 수 있게 되었습니다:

```csharp
public void Process(string input, 
    [CallerArgumentExpression(nameof(input))] string inputExpression = null)
{
    Console.WriteLine($"처리 중: {inputExpression}");
}

var data = "테스트";
Process(data);  // 출력: 처리 중: data
```

### Auto-default Structs (자동 기본값 구조체)

구조체의 생성자에서 모든 필드를 초기화하지 않아도 자동으로 기본값으로 설정됩니다:

```csharp
public struct Point
{
    public double X;
    public double Y;
    
    // Y를 초기화하지 않아도 자동으로 0으로 설정됨
    public Point(double x)
    {
        X = x;
        // Y는 자동으로 0.0
    }
}

var point = new Point(10);
Console.WriteLine($"X: {point.X}, Y: {point.Y}");  // X: 10, Y: 0
```

---

## 30.7 실전 종합 예제

다음은 C# 11의 여러 기능을 활용한 종합 예제입니다:

```csharp
// 사용자 관리 시스템
public class UserManager
{
    public required List<User> Users { get; init; }
    
    public string ExportToJson()
    {
        // Raw string literals 사용
        var users = Users.Select(u => $$"""
            {
                "id": {{u.Id}},
                "name": "{{u.Name}}",
                "email": "{{u.Email}}"
            }
            """);
        
        return $$"""
        {
            "users": [
                {{string.Join(",\n", users)}}
            ],
            "count": {{Users.Count}}
        }
        """;
    }
    
    public void ProcessCommand(string[] args)
    {
        // List patterns 사용
        switch (args)
        {
            case ["add", var name, var email]:
                AddUser(name, email);
                break;
                
            case ["find", var query, .. var filters]:
                FindUsers(query, filters);
                break;
                
            case ["delete", var id]:
                DeleteUser(int.Parse(id));
                break;
                
            default:
                Console.WriteLine("알 수 없는 명령어");
                break;
        }
    }
    
    private void AddUser(string name, string email)
    {
        var user = new User { Id = Users.Count + 1, Name = name, Email = email };
        Users.Add(user);
        Console.WriteLine($"사용자 추가됨: {user.Name}");
    }
    
    private void FindUsers(string query, string[] filters)
    {
        Console.WriteLine($"'{query}' 검색 중... (필터: {string.Join(", ", filters)})");
    }
    
    private void DeleteUser(int id)
    {
        Users.RemoveAll(u => u.Id == id);
        Console.WriteLine($"사용자 {id} 삭제됨");
    }
}

public class User
{
    public required int Id { get; init; }
    public required string Name { get; set; }
    public required string Email { get; set; }
}

// 제네릭 특성 사용
[Validated<User>]
public class UserValidator
{
    public static bool Validate(User user)
    {
        return !string.IsNullOrEmpty(user.Name) && 
               !string.IsNullOrEmpty(user.Email);
    }
}

public class ValidatedAttribute<T> : Attribute
{
    public Type ValidatedType => typeof(T);
}

// 사용 예제
var manager = new UserManager 
{ 
    Users = new List<User>()
};

manager.ProcessCommand(new[] { "add", "홍길동", "hong@example.com" });
manager.ProcessCommand(new[] { "add", "김철수", "kim@example.com" });
manager.ProcessCommand(new[] { "find", "홍", "active", "verified" });

Console.WriteLine(manager.ExportToJson());
```

---

## 30.8 마치며

C# 11은 개발자 경험을 크게 향상시킨 중요한 릴리스입니다. Raw string literals는 복잡한 문자열 처리를 간소화하고, list patterns는 함수형 프로그래밍 스타일을 더욱 자연스럽게 만들며, required members는 타입 안전성을 강화합니다. 

이러한 기능들은 코드의 가독성과 유지보수성을 높이는 동시에, 더 안전하고 표현력 있는 프로그래밍을 가능하게 합니다. C# 11의 기능들을 적극적으로 활용하여 더 나은 코드를 작성하시기 바랍니다.

**학습한 내용 요약:**
- Raw string literals로 복잡한 문자열 처리
- Generic attributes로 타입 안전한 메타데이터
- List patterns로 컬렉션 패턴 매칭
- Required members로 필수 초기화 강제
- File-local types로 캡슐화 강화
- Generic math, unsigned right-shift 등 기타 개선사항

**다음 단계:**
- 실제 프로젝트에 C# 11 기능 적용
- C# 12의 새로운 기능 학습
- 패턴 매칭과 함수형 프로그래밍 더 깊이 탐구

**참고 자료:**
- [C# 11의 새로운 기능](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-11)
- [Raw string literals](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/tokens/raw-string)
- [List patterns](https://learn.microsoft.com/ko-kr/dotnet/csharp/language-reference/operators/patterns#list-patterns)
