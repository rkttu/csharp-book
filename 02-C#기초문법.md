# 2장. C# 기초 문법

프로그래밍 언어를 학습하는 과정은 새로운 외국어를 배우는 것과 매우 유사합니다. 먼저 기본적인 단어와 문법을 익히고, 이를 조합하여 의미 있는 문장을 만들어내는 능력을 키워나가야 합니다. C# 역시 마찬가지입니다. 이 장에서는 C# 프로그래밍의 가장 기초가 되는 문법 요소들을 체계적으로 학습하여, 여러분이 자신의 아이디어를 코드로 표현할 수 있는 탄탄한 기반을 마련하고자 합니다.

1장에서 개발 환경을 성공적으로 구축했다면, 이제 본격적으로 C# 언어의 핵심 구성 요소들을 탐험할 준비가 완료된 것입니다. 변수와 데이터 타입을 통해 정보를 저장하고 관리하는 방법을 배우고, 다양한 연산자를 활용하여 데이터를 처리하며, 콘솔 입출력을 통해 사용자와 상호작용하는 프로그램을 작성하는 능력을 갖추게 될 것입니다. 이러한 기초 문법은 향후 더 복잡한 프로그래밍 개념을 이해하는 데 필수적인 토대가 됩니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 다음과 같은 C# 프로그래밍의 핵심 개념들을 체계적으로 학습하게 됩니다:

- **변수와 데이터 타입의 이해**: 프로그램에서 정보를 저장하고 관리하는 메커니즘을 이해하고, C#이 제공하는 다양한 기본 데이터 타입들의 특성과 활용 방법을 익힙니다. `int`, `string`, `bool`, `double`과 같은 기본 타입부터 시작하여, 타입 추론과 상수 선언에 이르기까지 변수 다루기의 모든 측면을 다룹니다.

- **연산자의 활용**: 데이터를 조작하고 계산을 수행하는 다양한 연산자들을 학습합니다. 산술 연산자를 통한 수학적 계산, 비교 연산자를 통한 값의 비교, 논리 연산자를 통한 조건 판단, 그리고 대입 연산자를 통한 효율적인 값 할당 방법을 익혀, 복잡한 로직을 간결하게 표현하는 능력을 기릅니다.

- **콘솔 입출력의 마스터**: 사용자와 프로그램이 상호작용하는 가장 기본적이면서도 중요한 방법인 콘솔 입출력을 완벽하게 이해합니다. `Console.WriteLine()`을 통한 정보 출력, `Console.ReadLine()`을 통한 사용자 입력 처리, 그리고 현대적인 문자열 보간 기법을 활용한 가독성 높은 출력 방법을 학습합니다.

- **주석을 통한 코드 문서화**: 읽기 쉽고 유지보수가 용이한 코드를 작성하기 위한 주석 작성 기법을 배웁니다. 단일 행 주석, 여러 줄 주석, XML 문서 주석 등 다양한 주석 스타일과 함께, 효과적인 주석 작성의 모범 사례를 익혀 전문적인 코드 작성 습관을 기릅니다.

---

## 2.1 변수와 데이터 타입

프로그래밍의 세계에서 변수(Variable)는 정보를 담는 그릇과 같은 역할을 합니다. 현실 세계에서 우리가 물건을 보관하기 위해 상자에 라벨을 붙이듯이, 프로그램에서는 데이터를 저장하기 위해 메모리 공간에 이름을 부여합니다. 이 이름이 바로 변수입니다. 변수를 사용함으로써 프로그램은 실행 중에 동적으로 값을 저장하고, 필요할 때 읽어오며, 상황에 따라 수정할 수 있는 능력을 갖추게 됩니다.

C#은 **정적 타입 언어(Statically Typed Language)**로 분류됩니다. 이는 변수를 선언하는 시점에 해당 변수가 저장할 수 있는 데이터의 종류(타입)를 명시적으로 지정해야 함을 의미합니다. 이러한 특성은 런타임 오류를 컴파일 시점에 미리 발견할 수 있게 해주어, 더욱 안정적이고 예측 가능한 코드 작성을 가능하게 합니다. Python이나 JavaScript와 같은 동적 타입 언어에서는 변수의 타입이 실행 중에 자동으로 결정되지만, C#에서는 개발자가 명시적으로 타입을 선언함으로써 타입 안정성(Type Safety)을 확보합니다.

### 2.1.1 기본 데이터 타입 (int, string, bool, double)

C#은 다양한 상황에서 사용할 수 있는 풍부한 내장 데이터 타입을 제공합니다. 이 중에서도 가장 기본이 되고 자주 사용되는 네 가지 타입에 대해 상세히 알아보겠습니다. 각 타입은 저장할 수 있는 데이터의 종류와 메모리 사용 방식, 그리고 수행할 수 있는 연산이 다르므로, 상황에 맞는 적절한 타입을 선택하는 것이 중요합니다.

#### int (정수형)

`int`는 Integer(정수)의 약자로, 소수점이 없는 정수를 저장하는 32비트 데이터 타입입니다. .NET의 공통 타입 시스템(Common Type System, CTS)에서는 `System.Int32`로 정의되며, 약 -21억부터 +21억까지의 범위를 표현할 수 있습니다. 일상적인 계수, 인덱스, 수량 등을 나타낼 때 가장 널리 사용되는 타입입니다.

**메모리 구조와 범위:**
- 크기: 32비트 (4바이트)
- 범위: -2,147,483,648 ~ 2,147,483,647
- 부호 있음(Signed): 음수와 양수 모두 표현 가능
- 기본값: 0

정수형은 컴퓨터의 산술 논리 장치(ALU, Arithmetic Logic Unit)에서 가장 효율적으로 처리되는 데이터 타입으로, 연산 속도가 매우 빠릅니다. 이는 CPU의 레지스터 크기와 직접적으로 대응되기 때문입니다.

```csharp
// 정수형 변수 선언과 초기화
int age = 25;
int year = 2024;
int temperature = -5;

Console.WriteLine($"나이: {age}");
Console.WriteLine($"연도: {year}");
Console.WriteLine($"온도: {temperature}도");

// 출력:
// 나이: 25
// 연도: 2024
// 온도: -5도
```

**주요 특징:**
- **정수 전용 표현**: 소수점이 없는 온전한 정수만 저장 가능하며, 소수점 값을 할당하면 자동으로 절삭(truncation)됩니다.
- **명확한 범위**: -2,147,483,648부터 2,147,483,647까지로, 대부분의 일상적인 계수 작업에 충분한 범위를 제공합니다.
- **효율적인 연산**: 사칙연산(`+`, `-`, `*`, `/`, `%`)이 매우 빠르게 처리되며, CPU 레지스터와 직접 매핑됩니다.
- **오버플로우 주의**: 범위를 초과하는 연산 시 오버플로우가 발생하며, 기본적으로는 예외를 발생시키지 않고 값이 순환됩니다 (`checked` 컨텍스트에서는 예외 발생).

**관련 정수 타입 비교:**

| 타입 | 크기 | 범위 | 용도 |
|------|------|------|------|
| `sbyte` | 8비트 | -128 ~ 127 | 매우 작은 정수, 메모리 절약 |
| `byte` | 8비트 | 0 ~ 255 | 부호 없는 작은 정수, 바이너리 데이터 |
| `short` | 16비트 | -32,768 ~ 32,767 | 작은 범위의 정수 |
| `ushort` | 16비트 | 0 ~ 65,535 | 부호 없는 작은 정수 |
| `int` | 32비트 | -2,147,483,648 ~ 2,147,483,647 | 일반적인 정수 (가장 많이 사용) |
| `uint` | 32비트 | 0 ~ 4,294,967,295 | 부호 없는 정수 |
| `long` | 64비트 | ±9,223,372,036,854,775,807 | 매우 큰 정수 |
| `ulong` | 64비트 | 0 ~ 18,446,744,073,709,551,615 | 부호 없는 큰 정수 |

#### string (문자열)

`string`은 텍스트 데이터를 저장하는 참조 타입(Reference Type)입니다. .NET의 공통 타입 시스템에서는 `System.String`으로 정의되며, Unicode 문자의 시퀀스로 구현되어 있어 전 세계 모든 언어의 문자를 표현할 수 있습니다. 사용자 이름, 메시지, 파일 경로 등 프로그램에서 다루는 대부분의 텍스트 정보는 문자열로 표현됩니다.

**문자열의 근본적 특성:**

C#의 문자열은 **불변(Immutable)** 객체입니다. 이는 일단 생성된 문자열 객체의 내용은 절대 변경될 수 없다는 의미입니다. 문자열을 "수정"하는 것처럼 보이는 연산(예: 연결, 치환)은 실제로는 새로운 문자열 객체를 생성하여 반환합니다. 이러한 설계는 다음과 같은 이점을 제공합니다:

1. **스레드 안전성(Thread Safety)**: 여러 스레드가 동시에 같은 문자열을 읽어도 안전합니다.
2. **메모리 최적화**: 동일한 내용의 문자열은 메모리를 공유할 수 있습니다 (String Interning).
3. **예측 가능성**: 함수에 문자열을 전달해도 원본이 변경될 걱정이 없습니다.

단, 빈번한 문자열 조작이 필요한 경우에는 `StringBuilder` 클래스를 사용하는 것이 성능상 유리합니다.

텍스트 데이터를 저장하는 타입입니다. 큰따옴표(`"`)로 감싸서 표현합니다.

```csharp
// 문자열 변수 선언
string name = "김철수";
string greeting = "안녕하세요!";
string empty = "";  // 빈 문자열

Console.WriteLine(name);
Console.WriteLine(greeting);

// 문자열 연결
string fullGreeting = greeting + " " + name + "님";
Console.WriteLine(fullGreeting);

// 출력:
// 김철수
// 안녕하세요!
// 안녕하세요! 김철수님
```

**주요 특징:**
- **전역 문자 지원**: Unicode 표준을 완벽하게 지원하여 한글, 영어, 중국어, 아랍어, 이모지 등 모든 문자를 표현할 수 있습니다.
- **불변성(Immutability)**: 한 번 생성된 문자열의 내용은 변경할 수 없으며, 수정 연산은 새로운 문자열 객체를 생성합니다.
- **참조 타입**: 힙(Heap) 메모리에 저장되며, 변수는 실제 데이터가 아닌 데이터의 주소(참조)를 저장합니다.
- **연산자 오버로딩**: `+` 연산자를 사용한 문자열 연결, `==` 연산자를 사용한 내용 비교가 직관적으로 가능합니다.
- **리터럴 표현**: 큰따옴표(`"`)로 감싸서 표현하며, 작은따옴표(`'`)는 단일 문자(`char`) 타입에 사용됩니다.
- **이스케이프 시퀀스**: `\n`(줄바꿈), `\t`(탭), `\\`(백슬래시), `\"`(큰따옴표) 등 특수 문자를 표현할 수 있습니다.

**문자열 특수 표기법:**

```csharp
// 일반 문자열
string normal = "Hello, World!";

// 이스케이프 시퀀스 사용
string withNewline = "첫 번째 줄\n두 번째 줄";
string withTab = "이름:\t김철수";
string withQuote = "그는 \"안녕\"이라고 말했다.";

// 축자 문자열(Verbatim String) - @ 접두사
string path = @"C:\Users\Username\Documents";  // 백슬래시를 이스케이프할 필요 없음
string multiline = @"첫 번째 줄
두 번째 줄
세 번째 줄";  // 줄바꿈을 그대로 포함

// 보간 문자열(Interpolated String) - $ 접두사
string name = "홍길동";
int age = 30;
string message = $"{name}님의 나이는 {age}세입니다.";
```

#### bool (불린형)

`bool`은 Boolean(불린)의 약자로, 논리적 참(true) 또는 거짓(false) 두 가지 값만을 가질 수 있는 논리 타입입니다. 영국의 수학자 조지 불(George Boole)의 불 대수(Boolean Algebra)에서 유래한 이름으로, 프로그래밍에서 의사결정과 흐름 제어의 핵심적인 역할을 담당합니다.

**논리 타입의 중요성:**

불린 타입은 크기는 작지만(단 1비트의 정보만 표현), 프로그램의 흐름을 제어하는 데 있어 가장 중요한 타입입니다. 모든 조건문(`if`, `while`, `for`)과 논리 연산의 기반이 되며, 프로그램이 상황에 따라 다르게 동작할 수 있도록 만드는 핵심 요소입니다.

**메모리와 표현:**
- 크기: 1바이트 (실제로는 1비트 정보만 필요하지만, 메모리 정렬을 위해 1바이트 할당)
- 값: `true` 또는 `false` (대소문자 구분 필수)
- 기본값: `false`
- .NET 타입: `System.Boolean`

참(true) 또는 거짓(false) 두 가지 값만 가질 수 있는 논리 타입입니다.

```csharp
// 불린형 변수
bool isStudent = true;
bool isRaining = false;
bool hasLicense = true;

Console.WriteLine($"학생입니까? {isStudent}");
Console.WriteLine($"비가 오나요? {isRaining}");

// 조건에 따른 출력
if (isStudent)
{
    Console.WriteLine("학생 할인이 적용됩니다.");
}

// 출력:
// 학생입니까? True
// 비가 오나요? False
// 학생 할인이 적용됩니다.
```

**주요 특징:**
- **이진 값 전용**: `true` 또는 `false`만 가능하며, C/C++와 달리 숫자(0, 1)와 자동 변환되지 않습니다.
- **논리 연산의 기초**: 조건문, 반복문, 논리 연산(`&&`, `||`, `!`)의 핵심 데이터 타입입니다.
- **비교 연산의 결과**: 모든 비교 연산(`==`, `!=`, `>`, `<`, `>=`, `<=`)의 결과는 bool 타입입니다.
- **타입 안전성**: C#에서는 정수를 불린으로 암시적 변환할 수 없어, `if (1)` 같은 코드는 컴파일 오류가 발생합니다.
- **조건 표현식**: 삼항 연산자(`? :`)와 null 병합 연산자(`??`)의 조건부로 사용됩니다.

**불린 값의 생성 방법:**

```csharp
// 직접 리터럴 할당
bool isReady = true;
bool isCompleted = false;

// 비교 연산의 결과
bool isAdult = age >= 18;
bool isPositive = number > 0;
bool isEqual = value1 == value2;

// 논리 연산의 결과
bool canProceed = isReady && !isCompleted;
bool shouldWait = !isReady || isProcessing;

// 메서드 반환값 (관례적으로 Is, Has, Can 등으로 시작)
bool isValid = ValidateInput(input);
bool hasPermission = CheckPermission(user);
bool canAccess = IsAuthorized() && HasValidToken();
```

**불린 명명 규칙:**

불린 변수는 일반적으로 질문에 대한 답변 형태로 명명합니다:
- `is + 형용사`: `isReady`, `isVisible`, `isEmpty`
- `has + 명사`: `hasChildren`, `hasPermission`, `hasError`
- `can + 동사`: `canRead`, `canWrite`, `canDelete`
- `should + 동사`: `shouldUpdate`, `shouldRetry`, `shouldNotify`
- `true` 또는 `false` 값만 가능
- 조건문, 반복문에서 주로 사용
- 비교 연산의 결과값

#### double (실수형)

`double`은 Double-Precision Floating-Point의 약자로, 소수점을 포함하는 실수를 저장하는 64비트 부동소수점(Floating-Point) 타입입니다. IEEE 754 표준을 따르며, 매우 큰 수부터 매우 작은 수까지 넓은 범위의 값을 근사적으로 표현할 수 있습니다.

**부동소수점의 이해:**

컴퓨터에서 실수를 표현하는 방식은 과학적 표기법과 유사합니다. 예를 들어, 숫자 123.45는 1.2345 × 10²로 표현할 수 있습니다. 부동소수점은 이처럼 가수(Mantissa)와 지수(Exponent)를 분리하여 저장함으로써, 제한된 비트 수로 매우 넓은 범위의 수를 표현합니다.

**메모리 구조:**
- 크기: 64비트 (8바이트)
- 정밀도: 약 15-17자리의 10진수
- 범위: ±5.0 × 10⁻³²⁴ ~ ±1.7 × 10³⁰⁸
- 특수 값: `NaN` (Not a Number), `PositiveInfinity`, `NegativeInfinity`
- .NET 타입: `System.Double`

**부동소수점의 한계:**

부동소수점 연산은 본질적으로 근사치이므로, 정확한 값이 아닌 "충분히 가까운" 값을 표현합니다. 이는 다음과 같은 중요한 함의를 가집니다:

```csharp
double a = 0.1 + 0.2;
double b = 0.3;
Console.WriteLine(a == b);  // False! (예상과 다름)
Console.WriteLine(a);        // 0.30000000000000004

// 부동소수점 비교 시에는 오차 범위를 고려해야 함
const double EPSILON = 1e-10;
bool isEqual = Math.Abs(a - b) < EPSILON;
```

이러한 특성 때문에, 금융 계산이나 정확한 10진수 연산이 필요한 경우에는 `decimal` 타입을 사용해야 합니다.

소수점을 포함하는 숫자를 저장하는 64비트 부동소수점 타입입니다.

```csharp
// 실수형 변수
double pi = 3.14159;
double price = 1500.50;
double temperature = 36.5;

Console.WriteLine($"원주율: {pi}");
Console.WriteLine($"가격: {price}원");
Console.WriteLine($"체온: {temperature}도");

// 계산
double radius = 5.0;
double area = pi * radius * radius;
Console.WriteLine($"반지름 {radius}인 원의 넓이: {area}");

// 출력:
// 원주율: 3.14159
// 가격: 1500.5원
// 체온: 36.5도
// 반지름 5인 원의 넓이: 78.53975
```

**주요 특징:**
- **넓은 표현 범위**: 과학적 계산이 필요한 매우 크거나 작은 수를 표현할 수 있습니다.
- **정밀도 한계**: 약 15-17자리의 10진수 정밀도를 가지며, 이를 초과하면 정확도가 떨어집니다.
- **근사치 표현**: 모든 10진 소수를 정확히 표현할 수 없으며, 이진 근사치로 저장됩니다.
- **과학적 표기법**: `1.5e3` (1.5 × 10³ = 1500)과 같은 표기법을 지원합니다.
- **특수 값 지원**: `double.NaN`, `double.PositiveInfinity`, `double.NegativeInfinity`, `double.Epsilon` 등의 특수 값이 정의되어 있습니다.

**실수 타입 비교:**

| 타입 | 크기 | 정밀도 | 범위 | 용도 |
|------|------|--------|------|------|
| `float` | 32비트 | 7자리 | ±1.5 × 10⁻⁴⁵ ~ ±3.4 × 10³⁸ | 단정밀도, 그래픽, 게임 |
| `double` | 64비트 | 15-17자리 | ±5.0 × 10⁻³²⁴ ~ ±1.7 × 10³⁰⁸ | 일반 과학 계산 (기본값) |
| `decimal` | 128비트 | 28-29자리 | ±1.0 × 10⁻²⁸ ~ ±7.9 × 10²⁸ | 금융, 정확한 10진수 계산 |

**사용 가이드:**
- **float**: 메모리가 중요하고 정밀도가 덜 중요한 경우 (3D 그래픽, 대량 데이터)
- **double**: 일반적인 과학/공학 계산, 기본 실수 타입
- **decimal**: 금융 계산, 정확한 10진수가 필요한 경우 (통화, 세금, 이자)

### 2.1.2 var 키워드와 타입 추론

C# 3.0에서 도입된 `var` 키워드는 컴파일러의 타입 추론(Type Inference) 기능을 활용하여 개발자가 명시적으로 타입을 지정하지 않아도 변수를 선언할 수 있게 해줍니다. 이는 코드의 간결성을 높이면서도, C#의 강력한 정적 타입 시스템의 안전성을 그대로 유지하는 현대적인 프로그래밍 패러다임입니다.

**타입 추론의 메커니즘:**

`var`를 사용하면 컴파일러는 할당된 값(또는 표현식)의 타입을 분석하여, 컴파일 시점에 변수의 타입을 자동으로 결정합니다. 이는 단순히 타입 표기를 생략하는 것이 아니라, 컴파일러가 정확한 타입을 추론하여 내부적으로는 명시적 타입 선언과 동일하게 처리합니다. 따라서 런타임 성능에는 전혀 영향이 없으며, 완전히 타입 안전합니다.

```csharp
// 다음 두 선언은 완전히 동일합니다 (컴파일된 코드는 identical)
int number = 42;
var number = 42;  // 컴파일러가 int로 추론

// 복잡한 타입의 경우 가독성이 향상됩니다
Dictionary<string, List<int>> explicitType = new Dictionary<string, List<int>>();
var implicitType = new Dictionary<string, List<int>>();  // 더 간결
```

**타입 추론의 이점:**

1. **코드 간결성**: 긴 타입 이름을 반복하지 않아 코드가 더 읽기 쉬워집니다.
2. **리팩토링 용이성**: 타입을 변경할 때 한 곳만 수정하면 됩니다.
3. **LINQ와의 시너지**: 익명 타입이나 복잡한 쿼리 결과를 다룰 때 필수적입니다.
4. **타입 안전성 유지**: 컴파일 시점에 타입이 결정되므로, 동적 타입 언어와 달리 타입 오류를 미리 발견할 수 있습니다.

`var` 키워드를 사용하면 컴파일러가 할당된 값을 보고 자동으로 변수의 타입을 추론합니다.

```csharp
// var를 사용한 타입 추론
var number = 10;           // int로 추론
var message = "Hello";     // string으로 추론
var isValid = true;        // bool로 추론
var price = 99.99;         // double로 추론

Console.WriteLine($"number의 타입: {number.GetType()}");
Console.WriteLine($"message의 타입: {message.GetType()}");

// 출력:
// number의 타입: System.Int32
// message의 타입: System.String
```

**var 사용 규칙:**
- **지역 변수 전용**: 메서드 내부의 지역 변수에서만 사용 가능하며, 필드, 속성, 매개변수에는 사용할 수 없습니다.
- **즉시 초기화 필수**: 선언과 동시에 값을 할당해야 하며, `var x;`와 같은 선언만으로는 타입을 추론할 수 없습니다.
- **null 리터럴 불가**: `var x = null;`은 타입을 결정할 수 없으므로 컴파일 오류가 발생합니다.
- **컴파일 타임 결정**: 한 번 추론된 타입은 변경할 수 없으며, 다른 타입의 값을 할당하면 오류가 발생합니다.
- **명시성 우선**: 타입이 명확하지 않거나, 가독성을 해칠 우려가 있다면 명시적 타입 선언을 사용하는 것이 좋습니다.

```csharp
// 올바른 사용
var name = "홍길동";

// 잘못된 사용
// var age;              // ❌ 초기화 없이 선언 불가
// var value = null;     // ❌ null로는 타입 추론 불가
```

**언제 var를 사용할까?**

`var` 사용 여부는 종종 논쟁의 대상이 되며, 팀마다 코딩 스타일이 다를 수 있습니다. 다음은 일반적으로 받아들여지는 가이드라인입니다:

**var 사용이 권장되는 경우:**
- 오른쪽 할당문에서 타입이 명확한 경우
  ```csharp
  var customer = new Customer();  // 명확함
  var count = GetItemCount();     // 메서드 이름에서 int임을 유추 가능
  ```
- 익명 타입을 다룰 때 (필수)
  ```csharp
  var person = new { Name = "홍길동", Age = 30 };
  ```
- LINQ 쿼리 결과를 다룰 때
  ```csharp
  var results = from item in items
                where item.Price > 100
                select item;
  ```
- 긴 제네릭 타입을 반복하고 싶지 않을 때
  ```csharp
  var dictionary = new Dictionary<string, List<int>>();
  ```

**명시적 타입이 권장되는 경우:**
- 오른쪽 할당문만으로는 타입이 불분명한 경우
  ```csharp
  int count = GetCount();  // GetCount()의 반환 타입이 명확하지 않을 수 있음
  ```
- 기본 타입을 다룰 때 (의견이 갈림)
  ```csharp
  int age = 25;      // 일부는 이렇게 선호
  var age = 25;      // 일부는 이렇게 선호
  ```
- 인터페이스나 기본 클래스 타입으로 받고 싶을 때
  ```csharp
  IEnumerable<int> numbers = GetNumbers();  // 특정 인터페이스로 받음
  ```

Microsoft의 공식 C# 코딩 규칙은 타입이 명확한 경우 `var` 사용을 권장하며, 타입을 명시하는 것이 가독성에 도움이 될 때는 명시적 타입을 사용하라고 조언합니다.

### 2.1.3 상수 (const)

상수(Constant)는 프로그램 실행 중에 절대 변경되지 않는 값을 저장하는 특별한 종류의 변수입니다. `const` 키워드로 선언되며, 컴파일 타임에 값이 결정되어 IL(Intermediate Language) 코드에 직접 임베딩됩니다. 이는 프로그램의 의미를 명확하게 하고, 실수로 인한 값 변경을 방지하며, 컴파일러 최적화를 가능하게 하는 중요한 프로그래밍 기법입니다.

**상수의 근본적 특성:**

상수는 단순히 "변경되지 않는 변수"가 아닙니다. `const`로 선언된 값은 컴파일 시점에 완전히 해결되어, 실행 파일 내에 리터럴로 대체됩니다. 이는 다음과 같은 중요한 의미를 가집니다:

1. **컴파일 타임 상수**: 값은 컴파일 시점에 알려져야 하며, 런타임에 계산될 수 없습니다.
2. **인라인 최적화**: 상수를 사용하는 모든 곳에서 실제 값으로 직접 대체됩니다.
3. **크로스 어셈블리 주의**: 다른 어셈블리(DLL)에서 상수를 참조하면, 그 어셈블리를 재컴파일하지 않는 한 변경사항이 반영되지 않습니다.

상수는 프로그램 실행 중 값이 변경되지 않는 변수입니다. `const` 키워드를 사용하여 선언합니다.

```csharp
// 상수 선언
const double PI = 3.14159;
const int MAX_STUDENTS = 30;
const string COMPANY_NAME = "ABC Corporation";

Console.WriteLine($"원주율: {PI}");
Console.WriteLine($"최대 학생 수: {MAX_STUDENTS}");
Console.WriteLine($"회사명: {COMPANY_NAME}");

// PI = 3.14;  // ❌ 컴파일 오류: 상수는 값을 변경할 수 없음

// 출력:
// 원주율: 3.14159
// 최대 학생 수: 30
// 회사명: ABC Corporation
```

**상수의 특징:**
- **불변성 보장**: 선언 후 어떤 방법으로도 값을 변경할 수 없으며, 시도 시 컴파일 오류가 발생합니다.
- **컴파일 타임 초기화**: 선언과 동시에 초기화해야 하며, 값은 컴파일 시점에 알려진 리터럴이어야 합니다.
- **컴파일 타임 평가**: 상수 표현식은 컴파일 시점에 평가되므로, 런타임 계산이 없어 성능이 최적화됩니다.
- **정적 특성**: `const` 필드는 암묵적으로 `static`이며, 타입 차원에서 공유됩니다.
- **제한된 타입**: 기본 타입(`int`, `bool`, `double`, `string` 등)과 `enum`, `null` 참조만 `const`로 선언할 수 있습니다.
- **범위 규칙**: 지역 상수(메서드 내부)와 클래스 수준 상수 모두 선언 가능합니다.

**상수 vs 변수:**

```csharp
// 변수 - 값 변경 가능
var count = 10;
count = 20;  // ✅ 가능
count++;     // ✅ 가능

// 상수 - 값 변경 불가
const int MAX_COUNT = 100;
// MAX_COUNT = 200;  // ❌ 컴파일 오류: "상수에 할당할 수 없습니다"
// MAX_COUNT++;      // ❌ 컴파일 오류
```

**상수 vs readonly:**

C#에서는 변경 불가능한 값을 표현하는 두 가지 주요 키워드가 있습니다:

```csharp
// const - 컴파일 타임 상수
public const double PI = 3.14159;  // 값이 코드에 직접 삽입됨

// readonly - 런타임 상수
public readonly DateTime CreatedAt = DateTime.Now;  // 런타임에 초기화

// const는 static이 암시됨
Console.WriteLine(MyClass.PI);  // 타입 이름으로 접근

// readonly는 인스턴스마다 다를 수 있음
var obj1 = new MyClass();  // obj1.CreatedAt
var obj2 = new MyClass();  // obj2.CreatedAt (다른 시간)
```

| 특성 | `const` | `readonly` |
|------|---------|------------|
| 초기화 시점 | 컴파일 타임 | 런타임 (생성자에서 가능) |
| 값 결정 | 리터럴만 가능 | 모든 표현식 가능 |
| 범위 | 암묵적 static | 인스턴스 또는 static |
| 타입 제한 | 기본 타입, string, null | 모든 타입 |
| 성능 | 인라인 대체 (빠름) | 메모리 참조 (약간 느림) |
| 버전 관리 | 재컴파일 필요 | 재컴파일 불필요 |

**상수 명명 규칙:**

C# 커뮤니티에서는 상수 명명에 대해 두 가지 주요 스타일이 사용됩니다:

1. **PascalCase** (Microsoft 공식 가이드라인)
   ```csharp
   public const int MaxValue = 100;
   public const string ApplicationName = "MyApp";
   ```

2. **UPPER_SNAKE_CASE** (C/C++ 스타일, 가독성 강조)
   ```csharp
   public const int MAX_VALUE = 100;
   public const string APPLICATION_NAME = "MyApp";
   ```

Microsoft의 공식 C# 코딩 규칙은 **PascalCase**를 권장하지만, 많은 개발자들은 상수를 일반 변수와 시각적으로 구분하기 위해 **UPPER_SNAKE_CASE**를 선호합니다. 중요한 것은 프로젝트 내에서 일관성을 유지하는 것입니다.

**상수 사용 예제:**

```csharp
// 수학 상수
public const double PI = 3.14159265359;
public const double E = 2.71828182846;

// 설정 값
public const int MAX_LOGIN_ATTEMPTS = 3;
public const int SESSION_TIMEOUT_MINUTES = 30;
public const string DEFAULT_LANGUAGE = "ko-KR";

// 상태 코드
public const int HTTP_OK = 200;
public const int HTTP_NOT_FOUND = 404;
public const int HTTP_SERVER_ERROR = 500;

// 유효성 검증
public const int MIN_PASSWORD_LENGTH = 8;
public const int MAX_USERNAME_LENGTH = 20;

// 상수 표현식 (다른 상수를 사용한 계산)
public const int SECONDS_PER_MINUTE = 60;
public const int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * 60;  // ✅ 컴파일 타임에 계산
public const int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;
```

---

## 2.2 연산자

연산자는 변수나 값에 대해 연산을 수행하는 기호입니다. C#은 다양한 종류의 연산자를 제공합니다.

### 2.2.1 산술 연산자

수학적 계산을 수행하는 연산자입니다.

```csharp
// 산술 연산자
int a = 10;
int b = 3;

Console.WriteLine($"a + b = {a + b}");  // 덧셈: 13
Console.WriteLine($"a - b = {a - b}");  // 뺄셈: 7
Console.WriteLine($"a * b = {a * b}");  // 곱셈: 30
Console.WriteLine($"a / b = {a / b}");  // 나눗셈(몫): 3
Console.WriteLine($"a % b = {a % b}");  // 나머지: 1

// 실수 나눗셈
double x = 10.0;
double y = 3.0;
Console.WriteLine($"x / y = {x / y}");  // 3.3333333333333335
```

**주요 산술 연산자:**

| 연산자 | 의미 | 예제 | 결과 |
|--------|------|------|------|
| `+` | 덧셈 | `5 + 3` | `8` |
| `-` | 뺄셈 | `5 - 3` | `2` |
| `*` | 곱셈 | `5 * 3` | `15` |
| `/` | 나눗셈 | `5 / 3` | `1` (정수), `1.666...` (실수) |
| `%` | 나머지 | `5 % 3` | `2` |

**복합 대입 연산자:**

```csharp
int num = 10;

num += 5;  // num = num + 5;  결과: 15
num -= 3;  // num = num - 3;  결과: 12
num *= 2;  // num = num * 2;  결과: 24
num /= 4;  // num = num / 4;  결과: 6
num %= 4;  // num = num % 4;  결과: 2

Console.WriteLine($"최종 값: {num}");  // 2
```

**증감 연산자:**

```csharp
int count = 5;

count++;  // 후위 증가: count = count + 1
Console.WriteLine(count);  // 6

++count;  // 전위 증가: count = count + 1
Console.WriteLine(count);  // 7

count--;  // 후위 감소: count = count - 1
Console.WriteLine(count);  // 6

--count;  // 전위 감소: count = count - 1
Console.WriteLine(count);  // 5
```

### 2.2.2 비교 연산자

두 값을 비교하여 `true` 또는 `false`를 반환하는 연산자입니다.

```csharp
int x = 10;
int y = 20;

Console.WriteLine($"x == y: {x == y}");  // 같음: False
Console.WriteLine($"x != y: {x != y}");  // 같지 않음: True
Console.WriteLine($"x > y: {x > y}");    // 크다: False
Console.WriteLine($"x < y: {x < y}");    // 작다: True
Console.WriteLine($"x >= y: {x >= y}");  // 크거나 같다: False
Console.WriteLine($"x <= y: {x <= y}");  // 작거나 같다: True
```

**주요 비교 연산자:**

| 연산자 | 의미 | 예제 | 결과 |
|--------|------|------|------|
| `==` | 같다 | `5 == 5` | `true` |
| `!=` | 같지 않다 | `5 != 3` | `true` |
| `>` | 크다 | `5 > 3` | `true` |
| `<` | 작다 | `5 < 3` | `false` |
| `>=` | 크거나 같다 | `5 >= 5` | `true` |
| `<=` | 작거나 같다 | `5 <= 3` | `false` |

**문자열 비교:**

```csharp
string name1 = "Alice";
string name2 = "Bob";
string name3 = "Alice";

Console.WriteLine(name1 == name2);  // False
Console.WriteLine(name1 == name3);  // True
Console.WriteLine(name1 != name2);  // True
```

### 2.2.3 논리 연산자

불린(bool) 값을 대상으로 논리 연산을 수행합니다.

```csharp
bool isStudent = true;
bool hasID = false;

// AND 연산자 (&&): 둘 다 true일 때만 true
Console.WriteLine($"isStudent && hasID: {isStudent && hasID}");  // False

// OR 연산자 (||): 하나라도 true면 true
Console.WriteLine($"isStudent || hasID: {isStudent || hasID}");  // True

// NOT 연산자 (!): 반대 값
Console.WriteLine($"!isStudent: {!isStudent}");  // False
Console.WriteLine($"!hasID: {!hasID}");          // True
```

**주요 논리 연산자:**

| 연산자 | 의미 | 예제 | 결과 |
|--------|------|------|------|
| `&&` | AND (그리고) | `true && false` | `false` |
| `||` | OR (또는) | `true || false` | `true` |
| `!` | NOT (부정) | `!true` | `false` |

**실용 예제:**

```csharp
int age = 20;
bool hasTicket = true;

// 18세 이상이고 티켓이 있으면 입장 가능
bool canEnter = age >= 18 && hasTicket;
Console.WriteLine($"입장 가능: {canEnter}");  // True

// 학생이거나 65세 이상이면 할인
bool isStudent = false;
int customerAge = 70;
bool getDiscount = isStudent || customerAge >= 65;
Console.WriteLine($"할인 적용: {getDiscount}");  // True
```

**단축 평가 (Short-circuit Evaluation):**

```csharp
// && 연산: 왼쪽이 false면 오른쪽은 평가하지 않음
bool result1 = false && SomeMethod();  // SomeMethod() 호출 안 됨

// || 연산: 왼쪽이 true면 오른쪽은 평가하지 않음
bool result2 = true || SomeMethod();   // SomeMethod() 호출 안 됨
```

### 2.2.4 대입 연산자

변수에 값을 할당하는 연산자입니다.

```csharp
// 기본 대입
int x = 10;
string name = "홍길동";

// 복합 대입 연산자
int a = 5;
a += 3;   // a = a + 3;   결과: 8
a -= 2;   // a = a - 2;   결과: 6
a *= 4;   // a = a * 4;   결과: 24
a /= 3;   // a = a / 3;   결과: 8
a %= 5;   // a = a % 5;   결과: 3

Console.WriteLine($"최종 a 값: {a}");
```

**모든 복합 대입 연산자:**

| 연산자 | 동일 표현 | 예제 |
|--------|----------|------|
| `+=` | `x = x + y` | `x += 5` |
| `-=` | `x = x - y` | `x -= 3` |
| `*=` | `x = x * y` | `x *= 2` |
| `/=` | `x = x / y` | `x /= 4` |
| `%=` | `x = x % y` | `x %= 3` |

**연쇄 대입:**

```csharp
int a, b, c;
a = b = c = 10;  // 모든 변수에 10 할당

Console.WriteLine($"a={a}, b={b}, c={c}");  // a=10, b=10, c=10
```

---

## 2.3 콘솔 입출력

콘솔 입출력은 사용자와 프로그램이 상호작용하는 가장 기본적인 방법입니다.

### 2.3.1 Console.WriteLine()

콘솔에 텍스트를 출력하고 자동으로 줄을 바꿉니다.

```csharp
// 기본 출력
Console.WriteLine("Hello, World!");
Console.WriteLine("안녕하세요!");

// 여러 줄 출력
Console.WriteLine("첫 번째 줄");
Console.WriteLine("두 번째 줄");
Console.WriteLine("세 번째 줄");

// 출력:
// Hello, World!
// 안녕하세요!
// 첫 번째 줄
// 두 번째 줄
// 세 번째 줄
```

**변수 출력:**

```csharp
int age = 25;
string name = "김철수";

Console.WriteLine(name);
Console.WriteLine(age);

// 문자열 연결로 출력
Console.WriteLine("이름: " + name);
Console.WriteLine("나이: " + age);

// 출력:
// 김철수
// 25
// 이름: 김철수
// 나이: 25
```

**Console.Write() vs Console.WriteLine():**

```csharp
// WriteLine - 줄바꿈 포함
Console.WriteLine("첫 번째");
Console.WriteLine("두 번째");

// Write - 줄바꿈 없음
Console.Write("첫 번째 ");
Console.Write("두 번째");
Console.WriteLine();  // 수동 줄바꿈

// 출력:
// 첫 번째
// 두 번째
// 첫 번째 두 번째
```

### 2.3.2 Console.ReadLine()

사용자로부터 입력을 받는 메서드입니다. 항상 `string` 타입으로 반환합니다.

```csharp
// 사용자 입력 받기
Console.Write("이름을 입력하세요: ");
string name = Console.ReadLine();

Console.Write("나이를 입력하세요: ");
string ageInput = Console.ReadLine();

Console.WriteLine($"안녕하세요, {name}님!");
Console.WriteLine($"입력하신 나이: {ageInput}");

// 실행 예:
// 이름을 입력하세요: 홍길동
// 나이를 입력하세요: 30
// 안녕하세요, 홍길동님!
// 입력하신 나이: 30
```

**타입 변환:**

`ReadLine()`은 항상 문자열을 반환하므로, 숫자로 사용하려면 변환이 필요합니다.

```csharp
// 문자열을 정수로 변환
Console.Write("숫자를 입력하세요: ");
string input = Console.ReadLine();
int number = int.Parse(input);

Console.WriteLine($"입력한 숫자 + 10 = {number + 10}");

// 더 안전한 변환 (TryParse)
Console.Write("나이를 입력하세요: ");
string ageInput = Console.ReadLine();

if (int.TryParse(ageInput, out int age))
{
    Console.WriteLine($"내년 나이: {age + 1}");
}
else
{
    Console.WriteLine("올바른 숫자를 입력해주세요.");
}
```

**다양한 타입 변환:**

```csharp
// 정수 변환
int num = int.Parse("123");

// 실수 변환
double price = double.Parse("99.99");

// 불린 변환
bool flag = bool.Parse("true");

Console.WriteLine($"숫자: {num}");
Console.WriteLine($"가격: {price}");
Console.WriteLine($"플래그: {flag}");
```

### 2.3.3 문자열 보간 (String Interpolation)

문자열 보간은 문자열 내에 변수나 표현식을 직접 삽입하는 현대적이고 가독성 높은 방법입니다.

```csharp
string name = "이영희";
int age = 28;
string city = "서울";

// 문자열 보간 사용 ($ 기호)
Console.WriteLine($"이름: {name}");
Console.WriteLine($"나이: {age}");
Console.WriteLine($"도시: {city}");

// 복잡한 문장
Console.WriteLine($"{name}님은 {age}살이며, {city}에 거주합니다.");

// 출력:
// 이름: 이영희
// 나이: 28
// 도시: 서울
// 이영희님은 28살이며, 서울에 거주합니다.
```

**표현식 사용:**

```csharp
int a = 10;
int b = 20;

// 중괄호 안에 표현식 사용 가능
Console.WriteLine($"a + b = {a + b}");
Console.WriteLine($"a * b = {a * b}");
Console.WriteLine($"a > b: {a > b}");

// 메서드 호출
string text = "hello";
Console.WriteLine($"대문자: {text.ToUpper()}");

// 출력:
// a + b = 30
// a * b = 200
// a > b: False
// 대문자: HELLO
```

**서식 지정:**

```csharp
double pi = 3.14159265;
int number = 42;

// 소수점 자릿수 지정
Console.WriteLine($"PI (소수점 2자리): {pi:F2}");

// 통화 형식
double price = 1234.56;
Console.WriteLine($"가격: {price:C}");

// 퍼센트 형식
double rate = 0.856;
Console.WriteLine($"비율: {rate:P1}");

// 출력:
// PI (소수점 2자리): 3.14
// 가격: ₩1,234.56
// 비율: 85.6%
```

**기존 방식과 비교:**

```csharp
string name = "김민수";
int age = 25;

// 방법 1: 문자열 연결 (오래된 방식)
Console.WriteLine("이름: " + name + ", 나이: " + age);

// 방법 2: String.Format (중간 방식)
Console.WriteLine(String.Format("이름: {0}, 나이: {1}", name, age));

// 방법 3: 문자열 보간 (현대적 방식, 권장)
Console.WriteLine($"이름: {name}, 나이: {age}");

// 모두 동일한 출력:
// 이름: 김민수, 나이: 25
```

---

## 2.4 주석 작성하기

주석(Comment)은 코드에 설명을 추가하는 방법입니다. 주석은 컴파일러가 무시하므로 프로그램 실행에 영향을 주지 않습니다.

### 단일 행 주석

`//`로 시작하는 한 줄 주석입니다.

```csharp
// 이것은 주석입니다.
Console.WriteLine("Hello");  // 코드 옆에도 주석 가능

// 변수 선언
int age = 25;

// 여러 줄을 주석 처리할 때
// 각 줄마다 // 를 붙입니다.
// 이렇게 말이죠.
```

### 여러 줄 주석

`/*`로 시작해서 `*/`로 끝나는 여러 줄 주석입니다.

```csharp
/*
   이것은 여러 줄 주석입니다.
   여러 줄에 걸쳐 설명을 작성할 수 있습니다.
   코드 블록을 임시로 비활성화할 때도 유용합니다.
*/

Console.WriteLine("Hello");

/*
Console.WriteLine("이 코드는 실행되지 않습니다");
Console.WriteLine("주석 처리되었기 때문입니다");
*/
```

### XML 문서 주석

`///`로 시작하는 문서화 주석으로, 코드의 API 문서를 자동 생성할 때 사용됩니다.

```csharp
/// <summary>
/// 두 정수의 합을 계산합니다.
/// </summary>
/// <param name="a">첫 번째 정수</param>
/// <param name="param name="b">두 번째 정수</param>
/// <returns>두 정수의 합</returns>
int Add(int a, int b)
{
    return a + b;
}
```

### 주석 작성 모범 사례

**좋은 주석:**

```csharp
// 사용자 나이를 검증 (18세 이상만 허용)
if (age >= 18)
{
    Console.WriteLine("입장 가능");
}

// TODO: 추후 이메일 검증 로직 추가 필요
string email = Console.ReadLine();

// HACK: 임시 해결책 - 추후 리팩토링 필요
const int TEMP_LIMIT = 100;
```

**피해야 할 주석:**

```csharp
// 나쁜 예: 코드를 그대로 설명
int x = 10;  // x에 10을 할당

// 나쁜 예: 명백한 내용 반복
Console.WriteLine("Hello");  // Hello 출력

// 좋은 예: 왜 그렇게 했는지 설명
int timeout = 30;  // API 응답 대기 시간 (초단위)
```

### 주석 사용 가이드

1. **코드 자체가 설명이 되도록 작성** - 명확한 변수명과 함수명 사용
2. **"왜"를 설명** - "무엇을" 하는지는 코드가 보여줌, "왜" 하는지를 주석으로 설명
3. **TODO, FIXME, HACK 등의 태그 활용** - 추후 작업이 필요한 부분 표시
4. **오래된 주석 제거** - 코드가 변경되면 관련 주석도 업데이트하거나 제거
5. **과도한 주석 지양** - 코드가 복잡하면 리팩토링 고려

```csharp
// 좋은 주석 예제
var maxRetries = 3;  // 네트워크 불안정을 고려한 재시도 횟수

// 나쁜 주석 예제
var x = 3;  // x는 3입니다
```

---

## 2장 정리 및 요약

이 장에서는 C# 프로그래밍의 기초 문법을 학습했습니다.

### 핵심 개념 정리

1. **변수와 데이터 타입**
   - 기본 타입: `int`, `string`, `bool`, `double`
   - `var` 키워드를 통한 타입 추론
   - `const`를 사용한 상수 선언

2. **연산자**
   - 산술 연산자: `+`, `-`, `*`, `/`, `%`
   - 비교 연산자: `==`, `!=`, `>`, `<`, `>=`, `<=`
   - 논리 연산자: `&&`, `||`, `!`
   - 대입 연산자: `=`, `+=`, `-=`, `*=`, `/=`, `%=`

3. **콘솔 입출력**
   - `Console.WriteLine()`: 출력 후 줄바꿈
   - `Console.ReadLine()`: 사용자 입력 받기
   - 문자열 보간: `$"text {variable}"`

4. **주석**
   - 단일 행: `//`
   - 여러 줄: `/* */`
   - XML 문서: `///`

### 실습 문제

#### 문제 1: 개인 정보 입력 및 출력

사용자로부터 이름, 나이, 도시를 입력받아 출력하는 프로그램을 작성하세요.

```csharp
Console.Write("이름을 입력하세요: ");
var name = Console.ReadLine();

Console.Write("나이를 입력하세요: ");
var ageInput = Console.ReadLine();
var age = int.Parse(ageInput);

Console.Write("거주 도시를 입력하세요: ");
var city = Console.ReadLine();

Console.WriteLine($"\n=== 입력하신 정보 ===");
Console.WriteLine($"이름: {name}");
Console.WriteLine($"나이: {age}세");
Console.WriteLine($"도시: {city}");
```

#### 문제 2: 간단한 계산기

두 숫자를 입력받아 사칙연산 결과를 모두 출력하는 프로그램을 작성하세요.

```csharp
Console.Write("첫 번째 숫자: ");
var num1 = double.Parse(Console.ReadLine());

Console.Write("두 번째 숫자: ");
var num2 = double.Parse(Console.ReadLine());

Console.WriteLine($"\n=== 연산 결과 ===");
Console.WriteLine($"{num1} + {num2} = {num1 + num2}");
Console.WriteLine($"{num1} - {num2} = {num1 - num2}");
Console.WriteLine($"{num1} × {num2} = {num1 * num2}");
Console.WriteLine($"{num1} ÷ {num2} = {num1 / num2}");
```

#### 문제 3: 성인 판별 프로그램

나이를 입력받아 성인인지 미성년자인지 판별하는 프로그램을 작성하세요.

```csharp
Console.Write("나이를 입력하세요: ");
var age = int.Parse(Console.ReadLine());

var isAdult = age >= 18;

Console.WriteLine($"입력 나이: {age}세");
Console.WriteLine($"성인 여부: {isAdult}");

if (isAdult)
{
    Console.WriteLine("성인입니다.");
}
else
{
    Console.WriteLine("미성년자입니다.");
}
```

### 다음 장 예고

3장 "제어문"에서는 프로그램의 흐름을 제어하는 방법을 학습합니다:
- 조건문 (`if`, `else`, `switch`)
- 반복문 (`for`, `while`, `foreach`)
- 분기문 (`break`, `continue`, `return`)

이를 통해 더욱 복잡하고 동적인 프로그램을 작성할 수 있게 됩니다!
