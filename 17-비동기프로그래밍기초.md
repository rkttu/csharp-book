# 17장. 비동기 프로그래밍 기초

현대의 애플리케이션은 사용자 인터페이스의 반응성을 유지하면서 동시에 여러 작업을 수행해야 합니다. 웹 API 호출, 파일 읽기/쓰기, 데이터베이스 쿼리 등의 작업은 완료되는 데 시간이 걸립니다. **비동기 프로그래밍(Asynchronous Programming)**은 이러한 작업이 완료되기를 기다리는 동안 다른 작업을 수행할 수 있게 하여, 프로그램의 효율성과 응답성을 크게 향상시킵니다.

C#의 비동기 프로그래밍은 `async`와 `await` 키워드를 중심으로 설계되어 있으며, 복잡한 비동기 코드를 동기 코드처럼 읽기 쉽게 작성할 수 있습니다. 이 장에서는 비동기 프로그래밍의 기본 개념과 실용적인 사용 방법을 학습합니다.

---

## 17.1 동기 vs 비동기

### 동기 프로그래밍 (Synchronous Programming)

동기 방식에서는 한 작업이 완료될 때까지 다음 작업이 대기합니다. 코드가 순차적으로 실행되며, 각 줄이 완료되어야 다음 줄로 넘어갑니다.

```csharp
// 동기 방식 - 파일 읽기
string content = File.ReadAllText("data.txt");
Console.WriteLine("파일 내용:");
Console.WriteLine(content);
Console.WriteLine("작업 완료");

// 출력:
// 파일 내용:
// (파일의 내용)
// 작업 완료
```

**동기 방식의 문제점:**

```csharp
// 동기 방식으로 여러 파일 읽기
Console.WriteLine("파일 읽기 시작...");

string file1 = File.ReadAllText("file1.txt");  // 완료될 때까지 대기
string file2 = File.ReadAllText("file2.txt");  // 완료될 때까지 대기
string file3 = File.ReadAllText("file3.txt");  // 완료될 때까지 대기

Console.WriteLine("모든 파일 읽기 완료");

// 각 파일을 순차적으로 읽기 때문에 총 시간 = file1 + file2 + file3
```

### 비동기 프로그래밍 (Asynchronous Programming)

비동기 방식에서는 시간이 오래 걸리는 작업을 시작한 후, 완료를 기다리지 않고 다른 작업을 계속 수행할 수 있습니다.

```csharp
// 비동기 방식 - 파일 읽기
string content = await File.ReadAllTextAsync("data.txt");
Console.WriteLine("파일 내용:");
Console.WriteLine(content);
Console.WriteLine("작업 완료");
```

**비동기 방식의 장점:**

```csharp
// 비동기 방식으로 여러 파일 동시에 읽기
Console.WriteLine("파일 읽기 시작...");

Task<string> task1 = File.ReadAllTextAsync("file1.txt");  // 시작하고 계속 진행
Task<string> task2 = File.ReadAllTextAsync("file2.txt");  // 시작하고 계속 진행
Task<string> task3 = File.ReadAllTextAsync("file3.txt");  // 시작하고 계속 진행

// 모든 작업이 완료될 때까지 대기
await Task.WhenAll(task1, task2, task3);

Console.WriteLine("모든 파일 읽기 완료");

// 여러 파일을 동시에 읽기 때문에 총 시간 ≈ max(file1, file2, file3)
```

### 비동기가 필요한 상황

- **I/O 작업**: 파일 읽기/쓰기, 네트워크 통신
- **웹 요청**: HTTP API 호출
- **데이터베이스 쿼리**: 시간이 걸리는 쿼리 실행
- **UI 애플리케이션**: 사용자 인터페이스가 멈추지 않도록 유지

---

## 17.2 async와 await 키워드

C#의 비동기 프로그래밍은 `async`와 `await` 키워드를 중심으로 동작합니다.

### async 키워드

`async` 키워드는 메서드가 비동기 작업을 포함한다는 것을 나타냅니다.

```csharp
async Task ProcessDataAsync()
{
    // 비동기 작업
    await Task.Delay(1000);
    Console.WriteLine("처리 완료");
}
```

**async 메서드의 특징:**
- 메서드 내에서 `await`를 사용할 수 있습니다
- 반환 타입은 `Task`, `Task<T>`, 또는 `void` (이벤트 핸들러만)이어야 합니다
- 메서드 이름은 관례적으로 `Async` 접미사를 붙입니다

### await 키워드

`await` 키워드는 비동기 작업이 완료될 때까지 기다리지만, 스레드를 차단하지 않습니다.

```csharp
async Task DownloadDataAsync()
{
    Console.WriteLine("다운로드 시작...");
    
    // 비동기로 대기 - 스레드는 다른 작업 수행 가능
    await Task.Delay(2000);
    
    Console.WriteLine("다운로드 완료!");
}
```

### 기본 사용 예제

```csharp
// 비동기 메서드 정의
async Task<string> GetGreetingAsync(string name)
{
    // 시뮬레이션: 데이터베이스나 API 호출
    await Task.Delay(1000);
    return $"안녕하세요, {name}님!";
}

// 비동기 메서드 호출
async Task RunAsync()
{
    Console.WriteLine("작업 시작");
    
    string greeting = await GetGreetingAsync("홍길동");
    Console.WriteLine(greeting);
    
    Console.WriteLine("작업 완료");
}

// 출력:
// 작업 시작
// (1초 대기)
// 안녕하세요, 홍길동님!
// 작업 완료
```

### 동기 vs 비동기 비교

```csharp
// 동기 방식
void DownloadSync()
{
    Console.WriteLine("다운로드 시작...");
    Thread.Sleep(2000);  // 스레드 차단
    Console.WriteLine("다운로드 완료!");
}

// 비동기 방식
async Task DownloadAsync()
{
    Console.WriteLine("다운로드 시작...");
    await Task.Delay(2000);  // 스레드 차단 없음
    Console.WriteLine("다운로드 완료!");
}
```

---

## 17.3 Task와 Task<T>

`Task`는 비동기 작업을 나타내는 객체입니다. C#의 비동기 프로그래밍은 Task를 중심으로 동작합니다.

### Task - 값을 반환하지 않는 비동기 작업

`Task`는 반환값이 없는 비동기 작업을 나타냅니다 (void 메서드의 비동기 버전).

```csharp
async Task PrintMessageAsync()
{
    await Task.Delay(1000);
    Console.WriteLine("메시지 출력!");
}

// 호출
await PrintMessageAsync();
```

### Task<T> - 값을 반환하는 비동기 작업

`Task<T>`는 `T` 타입의 값을 반환하는 비동기 작업을 나타냅니다.

```csharp
async Task<int> CalculateAsync(int a, int b)
{
    await Task.Delay(500);
    return a + b;
}

// 호출
int result = await CalculateAsync(10, 20);
Console.WriteLine($"결과: {result}");

// 출력:
// 결과: 30
```

### Task 생성 방법

**1. Task.Run() - CPU 집약적 작업**

```csharp
Task<int> task = Task.Run(() =>
{
    // 시간이 걸리는 계산
    int sum = 0;
    for (int i = 0; i < 1000000; i++)
    {
        sum += i;
    }
    return sum;
});

int result = await task;
Console.WriteLine($"합계: {result}");
```

**2. Task.Delay() - 지연**

```csharp
// 1초 대기
await Task.Delay(1000);

// 지정된 시간만큼 대기
await Task.Delay(TimeSpan.FromSeconds(2));
```

**3. Task.FromResult() - 즉시 완료된 Task**

```csharp
Task<int> GetCachedValue()
{
    int cachedValue = 42;
    return Task.FromResult(cachedValue);
}

int value = await GetCachedValue();
```

### Task의 상태

Task는 다음과 같은 상태를 가질 수 있습니다:

```csharp
Task task = SomeAsyncOperation();

// Task 상태 확인
if (task.IsCompleted)
    Console.WriteLine("작업 완료");

if (task.IsFaulted)
    Console.WriteLine("작업 실패");

if (task.IsCanceled)
    Console.WriteLine("작업 취소됨");
```

---

## 17.4 비동기 메서드 작성하기

비동기 메서드를 올바르게 작성하는 방법을 배웁니다.

### 기본 패턴

```csharp
// 반환값이 없는 비동기 메서드
async Task DoWorkAsync()
{
    await Task.Delay(1000);
    Console.WriteLine("작업 완료");
}

// 반환값이 있는 비동기 메서드
async Task<string> GetDataAsync()
{
    await Task.Delay(1000);
    return "데이터";
}
```

### 실용적인 예제 - 파일 읽기

```csharp
async Task<string> ReadFileAsync(string path)
{
    try
    {
        // 비동기로 파일 읽기
        string content = await File.ReadAllTextAsync(path);
        return content;
    }
    catch (FileNotFoundException)
    {
        Console.WriteLine("파일을 찾을 수 없습니다.");
        return string.Empty;
    }
}

// 사용
string content = await ReadFileAsync("data.txt");
Console.WriteLine(content);
```

### 실용적인 예제 - HTTP 요청

```csharp
async Task<string> DownloadContentAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        try
        {
            string content = await client.GetStringAsync(url);
            return content;
        }
        catch (HttpRequestException ex)
        {
            Console.WriteLine($"다운로드 오류: {ex.Message}");
            return string.Empty;
        }
    }
}

// 사용
string html = await DownloadContentAsync("https://example.com");
Console.WriteLine($"다운로드 크기: {html.Length} 문자");
```

### 여러 비동기 작업 조합

```csharp
async Task<int> GetUserCountAsync()
{
    await Task.Delay(500);
    return 100;
}

async Task<int> GetProductCountAsync()
{
    await Task.Delay(500);
    return 50;
}

async Task<string> GetStatisticsAsync()
{
    // 순차 실행 (총 1초)
    int userCount = await GetUserCountAsync();
    int productCount = await GetProductCountAsync();
    
    return $"사용자: {userCount}, 제품: {productCount}";
}

// 더 나은 방법: 동시 실행
async Task<string> GetStatisticsFastAsync()
{
    // 동시 실행 (총 0.5초)
    Task<int> userTask = GetUserCountAsync();
    Task<int> productTask = GetProductCountAsync();
    
    await Task.WhenAll(userTask, productTask);
    
    return $"사용자: {userTask.Result}, 제품: {productTask.Result}";
}
```

### 비동기 메서드의 반환 타입

**1. Task - 반환값 없음**

```csharp
async Task LogMessageAsync(string message)
{
    await Task.Delay(100);
    Console.WriteLine(message);
}
```

**2. Task<T> - T 타입 반환**

```csharp
async Task<int> AddAsync(int a, int b)
{
    await Task.Delay(100);
    return a + b;
}
```

**3. void - 이벤트 핸들러만 (권장하지 않음)**

```csharp
// 예외 처리가 어려우므로 이벤트 핸들러에서만 사용
async void Button_Click(object sender, EventArgs e)
{
    await DoWorkAsync();
}
```

---

## 17.5 비동기 메서드 호출과 대기

비동기 메서드를 호출하고 결과를 기다리는 다양한 방법을 학습합니다.

### 기본 await 사용

```csharp
async Task RunAsync()
{
    Console.WriteLine("작업 시작");
    
    // 비동기 메서드 호출 및 완료 대기
    await Task.Delay(1000);
    
    Console.WriteLine("작업 완료");
}
```

### 결과값 받기

```csharp
async Task<int> CalculateAsync()
{
    await Task.Delay(500);
    return 42;
}

async Task UseResultAsync()
{
    int result = await CalculateAsync();
    Console.WriteLine($"결과: {result}");
}
```

### 여러 Task 동시에 대기하기

**1. Task.WhenAll - 모든 작업 완료 대기**

```csharp
async Task DownloadAllAsync()
{
    Task task1 = DownloadFileAsync("file1.txt");
    Task task2 = DownloadFileAsync("file2.txt");
    Task task3 = DownloadFileAsync("file3.txt");
    
    // 모든 작업이 완료될 때까지 대기
    await Task.WhenAll(task1, task2, task3);
    
    Console.WriteLine("모든 다운로드 완료!");
}
```

**2. Task.WhenAll - 결과값 수집**

```csharp
async Task<int> GetNumberAsync(int n)
{
    await Task.Delay(100);
    return n * 2;
}

async Task ProcessNumbersAsync()
{
    Task<int>[] tasks = new Task<int>[]
    {
        GetNumberAsync(1),
        GetNumberAsync(2),
        GetNumberAsync(3)
    };
    
    // 모든 작업 완료 후 결과 배열 반환
    int[] results = await Task.WhenAll(tasks);
    
    Console.WriteLine($"결과: {string.Join(", ", results)}");
    // 출력: 결과: 2, 4, 6
}
```

**3. Task.WhenAny - 첫 번째 완료 작업 대기**

```csharp
async Task<string> QueryServerAsync(string serverName, int delay)
{
    await Task.Delay(delay);
    return $"{serverName} 응답";
}

async Task UseFirstResponseAsync()
{
    Task<string> server1 = QueryServerAsync("서버1", 1000);
    Task<string> server2 = QueryServerAsync("서버2", 2000);
    Task<string> server3 = QueryServerAsync("서버3", 1500);
    
    // 가장 먼저 완료되는 작업 대기
    Task<string> firstCompleted = await Task.WhenAny(server1, server2, server3);
    
    string result = await firstCompleted;
    Console.WriteLine($"첫 응답: {result}");
    // 출력: 첫 응답: 서버1 응답
}
```

### 비동기 작업 체이닝

```csharp
async Task<string> Step1Async()
{
    await Task.Delay(500);
    Console.WriteLine("1단계 완료");
    return "데이터1";
}

async Task<string> Step2Async(string input)
{
    await Task.Delay(500);
    Console.WriteLine("2단계 완료");
    return input + " + 데이터2";
}

async Task<string> Step3Async(string input)
{
    await Task.Delay(500);
    Console.WriteLine("3단계 완료");
    return input + " + 데이터3";
}

async Task RunPipelineAsync()
{
    string result1 = await Step1Async();
    string result2 = await Step2Async(result1);
    string result3 = await Step3Async(result2);
    
    Console.WriteLine($"최종 결과: {result3}");
}

// 출력:
// 1단계 완료
// 2단계 완료
// 3단계 완료
// 최종 결과: 데이터1 + 데이터2 + 데이터3
```

### 예외 처리

```csharp
async Task<string> RiskyOperationAsync()
{
    await Task.Delay(500);
    throw new InvalidOperationException("작업 실패!");
}

async Task HandleExceptionAsync()
{
    try
    {
        string result = await RiskyOperationAsync();
        Console.WriteLine(result);
    }
    catch (InvalidOperationException ex)
    {
        Console.WriteLine($"오류 처리: {ex.Message}");
    }
}

// 출력:
// 오류 처리: 작업 실패!
```

### 실전 예제 - 여러 파일 동시 처리

```csharp
async Task ProcessFilesAsync(string[] filePaths)
{
    Console.WriteLine($"{filePaths.Length}개 파일 처리 시작...");
    
    // 모든 파일을 동시에 읽기
    Task<string>[] readTasks = filePaths
        .Select(path => File.ReadAllTextAsync(path))
        .ToArray();
    
    try
    {
        // 모든 읽기 작업 완료 대기
        string[] contents = await Task.WhenAll(readTasks);
        
        // 각 파일 내용 처리
        for (int i = 0; i < filePaths.Length; i++)
        {
            Console.WriteLine($"{filePaths[i]}: {contents[i].Length} 문자");
        }
        
        Console.WriteLine("모든 파일 처리 완료!");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"파일 처리 중 오류: {ex.Message}");
    }
}

// 사용
string[] files = { "file1.txt", "file2.txt", "file3.txt" };
await ProcessFilesAsync(files);
```

---

## 17장 정리

이 장에서는 C#의 비동기 프로그래밍 기초를 학습했습니다.

### 핵심 개념

**1. 동기 vs 비동기**
- 동기: 순차적 실행, 작업 완료까지 대기
- 비동기: 동시 실행 가능, 대기 중에도 다른 작업 수행

**2. async와 await**
- `async`: 메서드가 비동기 작업을 포함함을 표시
- `await`: 비동기 작업 완료를 기다리지만 스레드는 차단하지 않음

**3. Task와 Task<T>**
- `Task`: 반환값이 없는 비동기 작업
- `Task<T>`: T 타입을 반환하는 비동기 작업

**4. 비동기 메서드 작성**
- 반환 타입: `Task` 또는 `Task<T>`
- 메서드 이름: `Async` 접미사 사용 권장
- 예외 처리: try-catch 사용 가능

**5. 비동기 작업 조합**
- `Task.WhenAll`: 모든 작업 완료 대기
- `Task.WhenAny`: 첫 번째 완료 작업 대기
- 동시 실행으로 성능 향상

### 비동기 프로그래밍의 장점

- **응답성 향상**: UI가 멈추지 않음
- **성능 개선**: I/O 대기 중 다른 작업 수행
- **리소스 효율**: 스레드를 차단하지 않음
- **확장성**: 더 많은 동시 요청 처리 가능

### 주의사항

- `async void`는 이벤트 핸들러에서만 사용
- 비동기 메서드는 항상 `await`으로 호출
- 예외 처리를 반드시 포함
- CPU 집약적 작업은 `Task.Run()` 사용

### 실전 활용

비동기 프로그래밍은 다음과 같은 경우에 특히 유용합니다:
- 웹 API 호출
- 파일 I/O
- 데이터베이스 쿼리
- 네트워크 통신
- UI 애플리케이션

### 다음 단계

18장에서는 고급 비동기 패턴을 학습하며, 취소 토큰(CancellationToken), 비동기 스트림(IAsyncEnumerable<T>), ConfigureAwait 등의 고급 주제를 다룹니다.

---

## 실습 예제

### 예제 1: 간단한 비동기 다운로드

```csharp
async Task<string> DownloadPageAsync(string url)
{
    using (HttpClient client = new HttpClient())
    {
        Console.WriteLine($"다운로드 시작: {url}");
        string content = await client.GetStringAsync(url);
        Console.WriteLine($"다운로드 완료: {content.Length} 문자");
        return content;
    }
}

// 사용
string page = await DownloadPageAsync("https://example.com");
```

### 예제 2: 여러 작업 동시 실행

```csharp
async Task<int> ComputeAsync(int value, int delay)
{
    await Task.Delay(delay);
    return value * 2;
}

async Task RunParallelAsync()
{
    var tasks = new[]
    {
        ComputeAsync(1, 1000),
        ComputeAsync(2, 800),
        ComputeAsync(3, 1200)
    };
    
    int[] results = await Task.WhenAll(tasks);
    Console.WriteLine($"결과: {string.Join(", ", results)}");
    // 출력: 결과: 2, 4, 6
}
```

### 예제 3: 파일 처리

```csharp
async Task ProcessLargeFileAsync(string path)
{
    try
    {
        Console.WriteLine("파일 읽기 시작...");
        string content = await File.ReadAllTextAsync(path);
        
        Console.WriteLine("데이터 처리 중...");
        await Task.Delay(1000);  // 처리 시뮬레이션
        
        Console.WriteLine($"처리 완료: {content.Length} 문자");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"오류: {ex.Message}");
    }
}
```

비동기 프로그래밍은 현대 C# 개발의 필수 요소입니다. 이 장에서 배운 기초를 바탕으로 더 복잡한 비동기 패턴을 이해하고 활용할 수 있습니다!
