# 4장. 배열

프로그래밍에서 데이터를 효율적으로 관리하고 처리하는 것은 매우 중요한 과제입니다. 지금까지 우리는 개별 변수를 사용하여 하나의 값을 저장하고 처리하는 방법을 배웠습니다. 하지만 실제 프로그램에서는 동일한 타입의 여러 데이터를 함께 다뤄야 하는 경우가 매우 빈번합니다. 예를 들어, 한 학급 학생들의 성적을 저장하거나, 한 달 동안의 일별 온도 데이터를 관리하거나, 게임에서 여러 플레이어의 점수를 추적해야 할 때, 개별 변수로는 관리가 불가능하거나 극도로 비효율적입니다.

이러한 문제를 해결하기 위해 프로그래밍 언어들은 **배열(Array)**이라는 자료구조를 제공합니다. 배열은 같은 타입의 여러 데이터를 하나의 이름으로 묶어서 순차적으로 저장하고 관리할 수 있는 컬렉션입니다. 배열을 사용하면 수십, 수백, 수천 개의 데이터를 효율적으로 저장하고 접근할 수 있으며, 반복문과 결합하여 강력한 데이터 처리 능력을 발휘합니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#에서 배열을 사용하는 다양한 방법을 체계적으로 학습하게 됩니다:

- **1차원 배열의 마스터**: 배열의 선언, 초기화, 요소 접근 방법을 익히고, `for`와 `foreach` 문을 활용한 배열 순회 기법을 학습합니다. 배열의 기본 개념과 인덱싱의 원리를 명확히 이해합니다.

- **다차원 배열의 이해**: 2차원 배열(행렬 구조)과 가변 배열(Jagged Array)의 특성을 파악하고, 각각의 사용 사례와 장단점을 비교합니다. 테이블 데이터나 게임 맵 등 복잡한 구조의 데이터를 표현하는 방법을 익힙니다.

- **배열 조작 메서드 활용**: `Array` 클래스가 제공하는 정렬, 역순 배치, 검색 등의 유용한 메서드들을 활용하여 배열 데이터를 효율적으로 처리하는 방법을 학습합니다.

---

## 4.1 1차원 배열

1차원 배열은 가장 기본적이고 직관적인 형태의 배열로, 같은 타입의 요소들이 일렬로 나열된 선형 구조를 가집니다. 메모리상에서는 연속된 공간에 데이터가 저장되며, 각 요소는 0부터 시작하는 인덱스(Index)를 통해 빠르게 접근할 수 있습니다. 이러한 특성 덕분에 배열은 O(1) 시간 복잡도로 임의의 요소에 접근할 수 있어, 데이터 처리 성능이 매우 우수합니다.

**배열의 핵심 특징:**

1. **고정 크기**: 한 번 생성된 배열의 크기는 변경할 수 없습니다. 이는 메모리 효율성과 성능을 위한 설계 결정입니다.
2. **동일 타입**: 배열의 모든 요소는 같은 데이터 타입이어야 합니다.
3. **0-기반 인덱싱**: 첫 번째 요소의 인덱스는 0이며, 마지막 요소의 인덱스는 (배열길이 - 1)입니다.
4. **참조 타입**: 배열은 참조 타입으로, 힙(Heap) 메모리에 저장됩니다.

### 4.1.1 배열 선언과 초기화

배열을 사용하기 위해서는 먼저 배열을 선언하고 초기화해야 합니다. C#은 배열 생성을 위한 여러 가지 편리한 구문을 제공하며, 상황에 맞는 적절한 방법을 선택할 수 있습니다.

**기본 선언 구문:**

```csharp
// 방법 1: 크기를 지정하여 배열 생성
int[] numbers = new int[5];  // 5개의 정수를 저장할 수 있는 배열 생성

// 방법 2: 초기값과 함께 배열 생성
int[] scores = new int[] { 85, 92, 78, 95, 88 };

// 방법 3: 타입 추론을 활용한 간결한 초기화
int[] ages = { 25, 30, 22, 28, 35 };

// 방법 4: var 키워드 사용
var temperatures = new double[] { 23.5, 25.0, 22.8, 26.3 };
```

**배열 선언의 세부 사항:**

```csharp
// 배열 타입은 타입명 뒤에 대괄호[]를 붙여 표현
int[] intArray;      // 정수 배열
string[] strArray;   // 문자열 배열
double[] dblArray;   // 실수 배열
bool[] boolArray;    // 불린 배열

// 선언만 하고 초기화하지 않으면 null 상태
int[] uninitArray;
Console.WriteLine(uninitArray == null);  // True

// 배열을 생성하면 기본값으로 초기화됨
int[] defaultInts = new int[3];     // { 0, 0, 0 }
string[] defaultStrs = new string[3]; // { null, null, null }
bool[] defaultBools = new bool[3];  // { false, false, false }
```

**다양한 초기화 방법:**

```csharp
// 명시적 크기 지정
int[] numbers = new int[5];  // 5개 요소를 가진 배열, 모두 0으로 초기화

// 초기값 제공 - 크기는 자동 결정
string[] fruits = new string[] { "사과", "바나나", "오렌지" };  // 크기 3

// 타입 생략 (더 간결한 구문)
string[] colors = { "빨강", "파랑", "초록", "노랑" };  // 권장하는 방식

// 빈 배열 생성
int[] empty = new int[0];  // 또는 Array.Empty<int>()
```

**실전 예제:**

```csharp
// 학생 5명의 점수 저장
int[] scores = { 85, 92, 78, 95, 88 };

Console.WriteLine($"배열의 크기: {scores.Length}");  // 5
Console.WriteLine($"첫 번째 점수: {scores[0]}");     // 85
Console.WriteLine($"마지막 점수: {scores[4]}");       // 88

// 일주일 동안의 최고 온도 기록
double[] weekTemperatures = new double[7];
weekTemperatures[0] = 23.5;  // 월요일
weekTemperatures[1] = 25.0;  // 화요일
weekTemperatures[2] = 22.8;  // 수요일
// ... 나머지 요일들

// 출력:
// 배열의 크기: 5
// 첫 번째 점수: 85
// 마지막 점수: 88
```

**배열 크기와 Length 속성:**

```csharp
int[] numbers = { 10, 20, 30, 40, 50 };

// Length 속성: 배열의 전체 요소 개수
Console.WriteLine($"배열 크기: {numbers.Length}");  // 5

// 유효한 인덱스 범위: 0 ~ (Length - 1)
int firstIndex = 0;
int lastIndex = numbers.Length - 1;  // 4

Console.WriteLine($"첫 인덱스: {firstIndex}, 마지막 인덱스: {lastIndex}");
// 출력: 첫 인덱스: 0, 마지막 인덱스: 4
```

### 4.1.2 배열 요소 접근

배열의 각 요소는 **인덱스(Index)**를 사용하여 접근할 수 있습니다. 인덱스는 대괄호 `[]` 안에 넣어 표기하며, 0부터 시작하여 (배열크기 - 1)까지의 정수 값을 가집니다. 이러한 0-기반 인덱싱(Zero-based Indexing)은 C 언어 계열의 전통을 따르는 것으로, 메모리 주소 계산의 효율성과 관련이 있습니다.

**기본 요소 접근:**

```csharp
string[] fruits = { "사과", "바나나", "오렌지", "포도", "딸기" };

// 읽기(Read)
Console.WriteLine(fruits[0]);  // 사과 (첫 번째 요소)
Console.WriteLine(fruits[2]);  // 오렌지 (세 번째 요소)
Console.WriteLine(fruits[4]);  // 딸기 (마지막 요소)

// 쓰기(Write) - 요소값 변경
fruits[1] = "망고";
Console.WriteLine(fruits[1]);  // 망고 (변경됨)

// 출력:
// 사과
// 오렌지
// 딸기
// 망고
```

**인덱스 범위와 오류:**

```csharp
int[] numbers = { 10, 20, 30 };

// 유효한 인덱스: 0, 1, 2
Console.WriteLine(numbers[0]);  // ✅ 10
Console.WriteLine(numbers[1]);  // ✅ 20
Console.WriteLine(numbers[2]);  // ✅ 30

// 잘못된 인덱스 - 런타임 오류 발생!
// Console.WriteLine(numbers[3]);   // ❌ IndexOutOfRangeException
// Console.WriteLine(numbers[-1]);  // ❌ IndexOutOfRangeException
```

**인덱스 오류(IndexOutOfRangeException):**

배열의 유효 범위를 벗어난 인덱스로 접근하려고 하면 `IndexOutOfRangeException` 런타임 오류가 발생합니다. 이는 C#에서 매우 흔한 오류 중 하나이므로, 항상 인덱스가 0 이상이고 배열 길이보다 작은지 확인해야 합니다.

```csharp
int[] data = { 1, 2, 3, 4, 5 };

// 안전한 접근 방법
int index = 10;
if (index >= 0 && index < data.Length)
{
    Console.WriteLine(data[index]);
}
else
{
    Console.WriteLine($"인덱스 {index}는 유효하지 않습니다.");
}

// 출력: 인덱스 10는 유효하지 않습니다.
```

**동적 인덱스 사용:**

```csharp
int[] scores = { 85, 92, 78, 95, 88 };

// 변수를 인덱스로 사용
int position = 2;
Console.WriteLine($"인덱스 {position}의 값: {scores[position]}");  // 78

// 수식을 인덱스로 사용
int lastIndex = scores.Length - 1;
Console.WriteLine($"마지막 요소: {scores[lastIndex]}");  // 88

// 반복문 안에서 인덱스 사용
for (int i = 0; i < scores.Length; i++)
{
    Console.WriteLine($"scores[{i}] = {scores[i]}");
}

// 출력:
// 인덱스 2의 값: 78
// 마지막 요소: 88
// scores[0] = 85
// scores[1] = 92
// scores[2] = 78
// scores[3] = 95
// scores[4] = 88
```

**C# 8.0 인덱스와 범위 연산자:**

C# 8.0부터는 더욱 편리한 인덱스 접근 방법이 도입되었습니다:

```csharp
int[] numbers = { 10, 20, 30, 40, 50 };

// ^N: 뒤에서 N번째 요소 (^1은 마지막, ^2는 뒤에서 두 번째)
Console.WriteLine(numbers[^1]);   // 50 (마지막 요소)
Console.WriteLine(numbers[^2]);   // 40 (뒤에서 두 번째)
Console.WriteLine(numbers[^5]);   // 10 (뒤에서 다섯 번째 = 첫 번째)

// 범위 연산자 ..: 부분 배열 (슬라이싱)
int[] slice1 = numbers[1..4];     // 인덱스 1, 2, 3 (4는 포함 안 됨)
// slice1 = { 20, 30, 40 }

int[] slice2 = numbers[..3];      // 처음부터 인덱스 2까지
// slice2 = { 10, 20, 30 }

int[] slice3 = numbers[2..];      // 인덱스 2부터 끝까지
// slice3 = { 30, 40, 50 }

int[] all = numbers[..];          // 전체 복사
// all = { 10, 20, 30, 40, 50 }

// 출력:
// 50
// 40
// 10
```

### 4.1.3 배열 순회

배열 순회(Array Traversal)는 배열의 모든 요소를 하나씩 방문하여 처리하는 작업입니다. C#은 배열을 순회하는 여러 가지 방법을 제공하며, 각 방법은 서로 다른 상황에 적합합니다.

**for 문을 사용한 순회:**

`for` 문은 인덱스가 필요하거나 배열을 역순으로 순회해야 할 때 가장 적합합니다.

```csharp
int[] numbers = { 10, 20, 30, 40, 50 };

// 전통적인 for 문 순회
Console.WriteLine("정방향 순회:");
for (int i = 0; i < numbers.Length; i++)
{
    Console.WriteLine($"numbers[{i}] = {numbers[i]}");
}

// 역방향 순회
Console.WriteLine("\n역방향 순회:");
for (int i = numbers.Length - 1; i >= 0; i--)
{
    Console.WriteLine($"numbers[{i}] = {numbers[i]}");
}

// 출력:
// 정방향 순회:
// numbers[0] = 10
// numbers[1] = 20
// numbers[2] = 30
// numbers[3] = 40
// numbers[4] = 50
//
// 역방향 순회:
// numbers[4] = 50
// numbers[3] = 40
// numbers[2] = 30
// numbers[1] = 20
// numbers[0] = 10
```

**foreach 문을 사용한 순회:**

`foreach` 문은 배열의 모든 요소를 순차적으로 읽기만 할 때 가장 간결하고 안전한 방법입니다.

```csharp
string[] fruits = { "사과", "바나나", "오렌지", "포도" };

Console.WriteLine("과일 목록:");
foreach (string fruit in fruits)
{
    Console.WriteLine($"- {fruit}");
}

// 출력:
// 과일 목록:
// - 사과
// - 바나나
// - 오렌지
// - 포도
```

**foreach의 장점과 제약:**

```csharp
int[] scores = { 85, 92, 78, 95, 88 };

// 장점: 간결하고 안전함 (인덱스 오류 없음)
int sum = 0;
foreach (int score in scores)
{
    sum += score;
}
Console.WriteLine($"총점: {sum}");  // 438

// 제약: 요소를 수정할 수 없음 (읽기 전용)
// foreach (int score in scores)
// {
//     score = score + 10;  // ❌ 컴파일 오류: 반복 변수를 수정할 수 없음
// }

// 요소를 수정하려면 for 문 사용
for (int i = 0; i < scores.Length; i++)
{
    scores[i] = scores[i] + 10;  // ✅ 가능
}
```

**실전 예제: 배열의 최대값 찾기:**

```csharp
int[] numbers = { 45, 23, 89, 12, 67, 34, 91, 56 };

// for 문 사용
int max1 = numbers[0];
for (int i = 1; i < numbers.Length; i++)
{
    if (numbers[i] > max1)
    {
        max1 = numbers[i];
    }
}
Console.WriteLine($"최대값 (for): {max1}");  // 91

// foreach 문 사용
int max2 = numbers[0];
foreach (int num in numbers)
{
    if (num > max2)
    {
        max2 = num;
    }
}
Console.WriteLine($"최대값 (foreach): {max2}");  // 91

// 출력:
// 최대값 (for): 91
// 최대값 (foreach): 91
```

**실전 예제: 배열의 평균 계산:**

```csharp
double[] temperatures = { 23.5, 25.0, 22.8, 26.3, 24.7, 23.9, 25.5 };

double sum = 0;
foreach (double temp in temperatures)
{
    sum += temp;
}

double average = sum / temperatures.Length;
Console.WriteLine($"일주일 평균 온도: {average:F1}도");

// 출력: 일주일 평균 온도: 24.5도
```

**while 문을 사용한 순회:**

```csharp
string[] cities = { "서울", "부산", "대구", "인천", "광주" };

int index = 0;
while (index < cities.Length)
{
    Console.WriteLine($"{index + 1}. {cities[index]}");
    index++;
}

// 출력:
// 1. 서울
// 2. 부산
// 3. 대구
// 4. 인천
// 5. 광주
```

---

## 4.2 다차원 배열

지금까지 살펴본 1차원 배열은 데이터를 일렬로 나열하는 선형 구조였습니다. 하지만 실제 프로그래밍에서는 표, 행렬, 게임 보드처럼 2차원 이상의 구조로 데이터를 표현해야 하는 경우가 많습니다. C#은 이러한 필요를 충족시키기 위해 **다차원 배열(Multidimensional Array)**과 **가변 배열(Jagged Array)**이라는 두 가지 방식을 제공합니다.

### 4.2.1 2차원 배열

2차원 배열(Two-Dimensional Array)은 행(Row)과 열(Column)로 구성된 표나 행렬 구조를 표현하는 데 사용됩니다. 수학의 행렬, 엑셀의 스프레드시트, 체스판이나 오목판 같은 게임 보드 등을 코드로 표현할 때 매우 유용합니다.

**2차원 배열의 선언과 초기화:**

```csharp
// 방법 1: 크기를 지정하여 생성
int[,] matrix = new int[3, 4];  // 3행 4열의 2차원 배열

// 방법 2: 초기값과 함께 생성
int[,] scores = new int[,]
{
    { 85, 92, 78 },  // 1행
    { 95, 88, 91 },  // 2행
    { 82, 89, 93 }   // 3행
};

// 방법 3: 간결한 초기화
int[,] grid = {
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
};
```

**2차원 배열의 요소 접근:**

```csharp
int[,] table = {
    { 10, 20, 30 },
    { 40, 50, 60 },
    { 70, 80, 90 }
};

// 요소 읽기: [행, 열]
Console.WriteLine(table[0, 0]);  // 10 (1행 1열)
Console.WriteLine(table[1, 2]);  // 60 (2행 3열)
Console.WriteLine(table[2, 1]);  // 80 (3행 2열)

// 요소 쓰기
table[1, 1] = 55;
Console.WriteLine(table[1, 1]);  // 55 (변경됨)

// 출력:
// 10
// 60
// 80
// 55
```

**2차원 배열의 크기 정보:**

```csharp
int[,] matrix = {
    { 1, 2, 3, 4 },
    { 5, 6, 7, 8 },
    { 9, 10, 11, 12 }
};

// GetLength(차원): 특정 차원의 길이
int rows = matrix.GetLength(0);     // 3 (행의 개수)
int cols = matrix.GetLength(1);     // 4 (열의 개수)

// Length: 전체 요소의 개수
int totalElements = matrix.Length;  // 12 (3 × 4)

Console.WriteLine($"행: {rows}, 열: {cols}, 전체: {totalElements}");

// 출력: 행: 3, 열: 4, 전체: 12
```

**2차원 배열의 순회:**

```csharp
int[,] grid = {
    { 1, 2, 3 },
    { 4, 5, 6 },
    { 7, 8, 9 }
};

// 중첩 for 문을 사용한 순회
Console.WriteLine("2차원 배열 순회:");
for (int i = 0; i < grid.GetLength(0); i++)  // 행 반복
{
    for (int j = 0; j < grid.GetLength(1); j++)  // 열 반복
    {
        Console.Write($"{grid[i, j],3}");
    }
    Console.WriteLine();
}

// 출력:
// 2차원 배열 순회:
//   1  2  3
//   4  5  6
//   7  8  9
```

**foreach를 사용한 2차원 배열 순회:**

```csharp
int[,] numbers = {
    { 10, 20 },
    { 30, 40 },
    { 50, 60 }
};

// foreach는 모든 요소를 1차원처럼 순회
int sum = 0;
foreach (int num in numbers)
{
    sum += num;
    Console.Write($"{num} ");
}
Console.WriteLine($"\n합계: {sum}");

// 출력:
// 10 20 30 40 50 60
// 합계: 210
```

**실전 예제: 학생 성적 관리:**

```csharp
// 3명의 학생, 4개의 과목 점수
int[,] studentScores = {
    { 85, 92, 78, 88 },  // 학생 1
    { 90, 85, 95, 92 },  // 학생 2
    { 78, 88, 82, 85 }   // 학생 3
};

string[] subjects = { "국어", "영어", "수학", "과학" };

// 각 학생의 평균 계산
for (int i = 0; i < studentScores.GetLength(0); i++)
{
    int sum = 0;
    for (int j = 0; j < studentScores.GetLength(1); j++)
    {
        sum += studentScores[i, j];
    }
    double average = (double)sum / studentScores.GetLength(1);
    Console.WriteLine($"학생 {i + 1}의 평균: {average:F1}점");
}

// 출력:
// 학생 1의 평균: 85.8점
// 학생 2의 평균: 90.5점
// 학생 3의 평균: 83.2점
```

### 4.2.2 가변 배열 (Jagged Array)

가변 배열(Jagged Array), 또는 톱니 배열은 **배열의 배열**입니다. 2차원 배열과 달리, 각 행이 서로 다른 길이를 가질 수 있어 메모리를 효율적으로 사용할 수 있습니다. "Jagged"라는 이름은 각 행의 길이가 달라 배열의 모양이 톱니처럼 들쭉날쭉하다는 의미에서 유래했습니다.

**2차원 배열 vs 가변 배열:**

```csharp
// 2차원 배열: 모든 행이 같은 길이
int[,] rectangular = new int[3, 4];  // 3행, 각 행은 4개 요소

// 가변 배열: 각 행이 다른 길이를 가질 수 있음
int[][] jagged = new int[3][];  // 3개의 행, 각 행의 길이는 아직 미정
jagged[0] = new int[2];   // 첫 번째 행: 2개 요소
jagged[1] = new int[4];   // 두 번째 행: 4개 요소
jagged[2] = new int[3];   // 세 번째 행: 3개 요소
```

**가변 배열의 선언과 초기화:**

```csharp
// 방법 1: 단계적 생성
int[][] triangle = new int[3][];
triangle[0] = new int[] { 1 };
triangle[1] = new int[] { 2, 3 };
triangle[2] = new int[] { 4, 5, 6 };

// 방법 2: 초기값과 함께 생성
int[][] numbers = new int[][]
{
    new int[] { 1, 2, 3 },
    new int[] { 4, 5 },
    new int[] { 6, 7, 8, 9 }
};

// 방법 3: 간결한 초기화
int[][] data = {
    new[] { 10, 20 },
    new[] { 30, 40, 50 },
    new[] { 60 }
};
```

**가변 배열의 요소 접근:**

```csharp
int[][] jagged = {
    new[] { 1, 2, 3 },
    new[] { 4, 5 },
    new[] { 6, 7, 8, 9 }
};

// 요소 접근: [행][열]
Console.WriteLine(jagged[0][0]);  // 1
Console.WriteLine(jagged[1][1]);  // 5
Console.WriteLine(jagged[2][3]);  // 9

// 각 행의 길이가 다름
Console.WriteLine($"1행 길이: {jagged[0].Length}");  // 3
Console.WriteLine($"2행 길이: {jagged[1].Length}");  // 2
Console.WriteLine($"3행 길이: {jagged[2].Length}");  // 4

// 출력:
// 1
// 5
// 9
// 1행 길이: 3
// 2행 길이: 2
// 3행 길이: 4
```

**가변 배열의 순회:**

```csharp
int[][] pyramid = {
    new[] { 1 },
    new[] { 2, 3 },
    new[] { 4, 5, 6 },
    new[] { 7, 8, 9, 10 }
};

Console.WriteLine("피라미드 구조:");
for (int i = 0; i < pyramid.Length; i++)
{
    for (int j = 0; j < pyramid[i].Length; j++)
    {
        Console.Write($"{pyramid[i][j]} ");
    }
    Console.WriteLine();
}

// 출력:
// 피라미드 구조:
// 1
// 2 3
// 4 5 6
// 7 8 9 10
```

**foreach를 사용한 가변 배열 순회:**

```csharp
string[][] teams = {
    new[] { "김철수", "이영희" },
    new[] { "박민수", "최지혜", "정다은" },
    new[] { "홍길동" }
};

int teamNumber = 1;
foreach (string[] team in teams)
{
    Console.WriteLine($"팀 {teamNumber}:");
    foreach (string member in team)
    {
        Console.WriteLine($"  - {member}");
    }
    teamNumber++;
}

// 출력:
// 팀 1:
//   - 김철수
//   - 이영희
// 팀 2:
//   - 박민수
//   - 최지혜
//   - 정다은
// 팀 3:
//   - 홍길동
```

**가변 배열 vs 2차원 배열 비교:**

```csharp
// 2차원 배열의 특징:
// - 직사각형 구조 (모든 행이 같은 길이)
// - 메모리 상에 연속적으로 배치
// - 문법: [,]
int[,] rect = new int[3, 4];

// 가변 배열의 특징:
// - 각 행이 독립적인 배열 (길이가 다를 수 있음)
// - 메모리 효율적 (필요한 만큼만 할당)
// - 문법: [][]
int[][] jagg = new int[3][];
```

**실전 예제: 월별 일수 표현:**

```csharp
// 각 월의 일수 (2월은 28일로 가정)
int[][] monthDays = {
    new int[31],  // 1월: 31일
    new int[28],  // 2월: 28일
    new int[31],  // 3월: 31일
    new int[30],  // 4월: 30일
    new int[31],  // 5월: 31일
    new int[30],  // 6월: 30일
    new int[31],  // 7월: 31일
    new int[31],  // 8월: 31일
    new int[30],  // 9월: 30일
    new int[31],  // 10월: 31일
    new int[30],  // 11월: 30일
    new int[31]   // 12월: 31일
};

// 각 월의 일수 출력
for (int i = 0; i < monthDays.Length; i++)
{
    Console.WriteLine($"{i + 1}월: {monthDays[i].Length}일");
}

// 출력:
// 1월: 31일
// 2월: 28일
// 3월: 31일
// ...
```

---

## 4.3 배열 관련 메서드

C#의 `Array` 클래스는 배열을 효과적으로 다루기 위한 다양한 정적 메서드를 제공합니다. 이러한 메서드들을 활용하면 정렬, 검색, 복사, 역순 배치 등의 일반적인 배열 조작을 간단하고 효율적으로 수행할 수 있습니다.

### 4.3.1 Array.Sort()

`Array.Sort()` 메서드는 배열의 요소를 오름차순으로 정렬합니다. 이 메서드는 원본 배열을 직접 수정하며, 대부분의 기본 타입에 대해 동작합니다.

**기본 사용법:**

```csharp
int[] numbers = { 45, 23, 89, 12, 67, 34 };

Console.WriteLine("정렬 전:");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

Array.Sort(numbers);

Console.WriteLine("\n정렬 후:");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

// 출력:
// 정렬 전:
// 45 23 89 12 67 34
// 정렬 후:
// 12 23 34 45 67 89
```

**문자열 배열 정렬:**

```csharp
string[] names = { "최지혜", "김철수", "박민수", "이영희" };

Array.Sort(names);

Console.WriteLine("이름 정렬 (가나다순):");
foreach (string name in names)
{
    Console.WriteLine(name);
}

// 출력:
// 이름 정렬 (가나다순):
// 김철수
// 박민수
// 이영희
// 최지혜
```

**부분 정렬:**

```csharp
int[] data = { 50, 30, 70, 10, 90, 20 };

// 인덱스 1부터 3개 요소만 정렬
Array.Sort(data, 1, 3);

Console.WriteLine("부분 정렬 결과:");
foreach (int num in data)
{
    Console.Write($"{num} ");
}

// 출력:
// 부분 정렬 결과:
// 50 10 30 70 90 20
```

**내림차순 정렬:**

```csharp
int[] scores = { 85, 92, 78, 95, 88 };

// 오름차순 정렬 후 역순 배치
Array.Sort(scores);
Array.Reverse(scores);

Console.WriteLine("내림차순 정렬:");
foreach (int score in scores)
{
    Console.Write($"{score} ");
}

// 출력:
// 내림차순 정렬:
// 95 92 88 85 78
```

**실전 예제: 성적 순위 매기기:**

```csharp
string[] students = { "김철수", "이영희", "박민수", "최지혜" };
int[] scores = { 85, 95, 78, 92 };

// 점수와 이름을 함께 정렬하기 위해 Array.Sort의 두 배열 버전 사용
Array.Sort(scores, students);

Console.WriteLine("성적 순위 (낮은 순):");
for (int i = 0; i < students.Length; i++)
{
    Console.WriteLine($"{i + 1}등: {students[i]} ({scores[i]}점)");
}

// 내림차순으로 보려면 역순 배치
Array.Reverse(scores);
Array.Reverse(students);

Console.WriteLine("\n성적 순위 (높은 순):");
for (int i = 0; i < students.Length; i++)
{
    Console.WriteLine($"{i + 1}등: {students[i]} ({scores[i]}점)");
}

// 출력:
// 성적 순위 (낮은 순):
// 1등: 박민수 (78점)
// 2등: 김철수 (85점)
// 3등: 최지혜 (92점)
// 4등: 이영희 (95점)
//
// 성적 순위 (높은 순):
// 1등: 이영희 (95점)
// 2등: 최지혜 (92점)
// 3등: 김철수 (85점)
// 4등: 박민수 (78점)
```

### 4.3.2 Array.Reverse()

`Array.Reverse()` 메서드는 배열의 요소 순서를 역순으로 뒤집습니다. 이 메서드 역시 원본 배열을 직접 수정합니다.

**기본 사용법:**

```csharp
int[] numbers = { 1, 2, 3, 4, 5 };

Console.WriteLine("원본 배열:");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

Array.Reverse(numbers);

Console.WriteLine("\n역순 배열:");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

// 출력:
// 원본 배열:
// 1 2 3 4 5
// 역순 배열:
// 5 4 3 2 1
```

**문자열 배열 역순:**

```csharp
string[] days = { "월요일", "화요일", "수요일", "목요일", "금요일" };

Array.Reverse(days);

Console.WriteLine("역순 요일:");
foreach (string day in days)
{
    Console.WriteLine(day);
}

// 출력:
// 역순 요일:
// 금요일
// 목요일
// 수요일
// 화요일
// 월요일
```

**부분 역순:**

```csharp
int[] data = { 10, 20, 30, 40, 50, 60 };

// 인덱스 1부터 3개 요소만 역순
Array.Reverse(data, 1, 3);

Console.WriteLine("부분 역순 결과:");
foreach (int num in data)
{
    Console.Write($"{num} ");
}

// 출력:
// 부분 역순 결과:
// 10 40 30 20 50 60
```

**실전 예제: 카운트다운:**

```csharp
int[] countdown = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

Array.Reverse(countdown);

Console.WriteLine("발사 카운트다운:");
foreach (int num in countdown)
{
    Console.Write($"{num}... ");
}
Console.WriteLine("발사!");

// 출력:
// 발사 카운트다운:
// 10... 9... 8... 7... 6... 5... 4... 3... 2... 1... 발사!
```

### 4.3.3 Array.IndexOf()

`Array.IndexOf()` 메서드는 배열에서 특정 값을 검색하여 그 값이 처음 나타나는 위치의 인덱스를 반환합니다. 값을 찾지 못하면 -1을 반환합니다.

**기본 사용법:**

```csharp
int[] numbers = { 10, 20, 30, 40, 50, 30, 60 };

int index1 = Array.IndexOf(numbers, 30);
Console.WriteLine($"30의 인덱스: {index1}");  // 2 (첫 번째 30의 위치)

int index2 = Array.IndexOf(numbers, 100);
Console.WriteLine($"100의 인덱스: {index2}");  // -1 (없음)

// 출력:
// 30의 인덱스: 2
// 100의 인덱스: -1
```

**문자열 검색:**

```csharp
string[] fruits = { "사과", "바나나", "오렌지", "포도", "딸기" };

int index = Array.IndexOf(fruits, "오렌지");

if (index != -1)
{
    Console.WriteLine($"오렌지는 인덱스 {index}에 있습니다.");
}
else
{
    Console.WriteLine("오렌지를 찾을 수 없습니다.");
}

// 출력: 오렌지는 인덱스 2에 있습니다.
```

**특정 위치부터 검색:**

```csharp
int[] data = { 5, 10, 15, 10, 20, 10, 25 };

// 처음부터 검색
int first = Array.IndexOf(data, 10);
Console.WriteLine($"첫 번째 10: 인덱스 {first}");  // 1

// 인덱스 2부터 검색
int second = Array.IndexOf(data, 10, 2);
Console.WriteLine($"두 번째 10: 인덱스 {second}");  // 3

// 인덱스 4부터 검색
int third = Array.IndexOf(data, 10, 4);
Console.WriteLine($"세 번째 10: 인덱스 {third}");  // 5

// 출력:
// 첫 번째 10: 인덱스 1
// 두 번째 10: 인덱스 3
// 세 번째 10: 인덱스 5
```

**Array.LastIndexOf() - 마지막 위치 찾기:**

```csharp
int[] numbers = { 10, 20, 30, 20, 40, 20, 50 };

int firstIndex = Array.IndexOf(numbers, 20);
int lastIndex = Array.LastIndexOf(numbers, 20);

Console.WriteLine($"20의 첫 번째 위치: {firstIndex}");  // 1
Console.WriteLine($"20의 마지막 위치: {lastIndex}");    // 5

// 출력:
// 20의 첫 번째 위치: 1
// 20의 마지막 위치: 5
```

**실전 예제: 학생 검색:**

```csharp
string[] students = { "김철수", "이영희", "박민수", "최지혜", "정다은" };
int[] scores = { 85, 92, 78, 95, 88 };

Console.Write("검색할 학생 이름: ");
string searchName = Console.ReadLine();

int index = Array.IndexOf(students, searchName);

if (index != -1)
{
    Console.WriteLine($"{searchName}님의 점수: {scores[index]}점");
}
else
{
    Console.WriteLine($"{searchName}님을 찾을 수 없습니다.");
}

// 실행 예:
// 검색할 학생 이름: 최지혜
// 최지혜님의 점수: 95점
```

**기타 유용한 Array 메서드:**

```csharp
int[] numbers = { 5, 2, 8, 1, 9, 3 };

// Array.Clear() - 배열의 요소를 기본값으로 초기화
Array.Clear(numbers, 0, 3);  // 처음 3개 요소를 0으로
// numbers = { 0, 0, 0, 1, 9, 3 }

// Array.Copy() - 배열 복사
int[] copy = new int[6];
Array.Copy(numbers, copy, numbers.Length);

// Array.Exists() - 조건을 만족하는 요소가 있는지 확인
bool hasLargeNumber = Array.Exists(numbers, n => n > 5);
Console.WriteLine($"5보다 큰 수 존재: {hasLargeNumber}");  // True

// Array.Find() - 조건을 만족하는 첫 번째 요소 찾기
int firstOdd = Array.Find(numbers, n => n % 2 == 1);
Console.WriteLine($"첫 번째 홀수: {firstOdd}");  // 1

// Array.FindAll() - 조건을 만족하는 모든 요소 찾기
int[] evenNumbers = Array.FindAll(numbers, n => n % 2 == 0);
Console.WriteLine("짝수들:");
foreach (int num in evenNumbers)
{
    Console.Write($"{num} ");
}
```

---

## 마무리

이 장에서는 C# 프로그래밍에서 매우 중요한 자료구조인 배열에 대해 깊이 있게 학습했습니다. 배열은 같은 타입의 여러 데이터를 효율적으로 저장하고 관리할 수 있게 해주는 핵심 도구입니다.

**학습 정리:**

✅ **1차원 배열**: 배열의 선언, 초기화, 요소 접근, 순회 방법을 익혔습니다.
✅ **다차원 배열**: 2차원 배열과 가변 배열의 차이점을 이해하고 활용법을 배웠습니다.
✅ **배열 메서드**: `Array.Sort()`, `Array.Reverse()`, `Array.IndexOf()` 등 유용한 메서드들을 학습했습니다.

**핵심 포인트:**

- 배열은 고정 크기의 자료구조로, 생성 후 크기 변경이 불가능합니다.
- 인덱스는 0부터 시작하며, 유효 범위를 벗어나면 `IndexOutOfRangeException`이 발생합니다.
- `for` 문은 인덱스가 필요할 때, `foreach` 문은 모든 요소를 순회할 때 적합합니다.
- 2차원 배열 `[,]`은 직사각형 구조, 가변 배열 `[][]`은 각 행의 길이가 다를 수 있습니다.
- `Array` 클래스의 정적 메서드들을 활용하면 배열 조작이 훨씬 편리합니다.

**다음 단계:**

5장에서는 배열보다 더욱 유연하고 강력한 **컬렉션(Collection)**에 대해 학습하게 됩니다. `List<T>`, `Dictionary<TKey, TValue>` 등의 제네릭 컬렉션을 통해 동적인 크기 조정, 키-값 쌍 저장, 효율적인 검색 등 더 고급 기능들을 다루게 될 것입니다. 배열은 컬렉션을 이해하는 데 필수적인 기초이므로, 이번 장에서 배운 내용을 충분히 연습하여 완전히 자신의 것으로 만드세요!
