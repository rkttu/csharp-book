# 33장. C# 14 프리뷰 기능

C# 14는 .NET 10과 함께 출시될 예정인 차세대 C# 버전으로, 현재 프리뷰 단계에 있습니다. 이 장에서는 C# 14에서 도입될 것으로 예상되는 주요 기능들을 살펴봅니다. **주의**: 이 기능들은 아직 최종 확정되지 않았으며, 정식 출시 시 변경될 수 있습니다.

**C# 14의 예상 설계 방향:**

1. **확장성(Extensibility)**: Extensions 기능으로 타입 확장의 새로운 패러다임 제공
2. **타입 안전성(Type Safety)**: Discriminated unions로 더 안전한 상태 표현
3. **성능(Performance)**: 지속적인 성능 최적화와 메모리 효율성 개선
4. **개발자 경험(Developer Experience)**: 더 직관적이고 표현력 있는 문법

## 이 장에서 다룰 내용

> **중요 고지사항**: 
> 이 장의 내용은 C# 14 프리뷰 버전을 기반으로 작성되었습니다. 실제 출시 버전에서는 기능이 추가, 변경 또는 제거될 수 있습니다. 프로덕션 코드에 사용하기 전에 반드시 최신 공식 문서를 확인하시기 바랍니다.

- **Field keyword**: 속성 접근자에서 백킹 필드 직접 접근
- **Extensions**: 확장 메서드를 넘어선 타입 확장 메커니즘
- **Discriminated unions** (예상): 타입 안전한 합 타입
- **패턴 매칭 개선**: 더 강력하고 표현력 있는 패턴
- **성능 최적화**: 추가적인 성능 개선사항

---

## 33.1 Field Keyword (필드 키워드)

`field` 키워드는 속성의 접근자 내에서 자동으로 생성되는 백킹 필드에 직접 접근할 수 있게 해주는 기능입니다.

**전통적인 방식:**

```csharp
// 명시적 백킹 필드
public class Person
{
    private string _name;
    
    public string Name
    {
        get => _name;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("이름은 필수입니다");
            _name = value.Trim();
        }
    }
}
```

**field 키워드 사용 (C# 14 프리뷰):**

```csharp
// field 키워드로 백킹 필드 자동 접근
public class Person
{
    public string Name
    {
        get => field;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("이름은 필수입니다");
            field = value.Trim();
        }
    }
}

// 사용
var person = new Person { Name = "  홍길동  " };
Console.WriteLine($"이름: '{person.Name}'");  // 이름: '홍길동'
```

**실전 예제 - 유효성 검사:**

```csharp
public class Product
{
    public string Name
    {
        get => field;
        set => field = string.IsNullOrWhiteSpace(value) 
            ? throw new ArgumentException("제품명은 필수입니다") 
            : value;
    }
    
    public decimal Price
    {
        get => field;
        set => field = value >= 0 
            ? value 
            : throw new ArgumentException("가격은 0 이상이어야 합니다");
    }
    
    public int Stock
    {
        get => field;
        set
        {
            if (value < 0)
                throw new ArgumentException("재고는 음수일 수 없습니다");
            
            if (field != value)
            {
                field = value;
                Console.WriteLine($"{Name}의 재고가 {value}로 변경되었습니다");
            }
        }
    }
}

// 사용
var product = new Product 
{ 
    Name = "노트북", 
    Price = 1500000, 
    Stock = 10 
};

product.Stock = 5;  // 재고 변경 알림
// product.Price = -100;  // 예외 발생!
```

**지연 초기화:**

```csharp
public class DataLoader
{
    private bool _isInitialized;
    
    public string Data
    {
        get
        {
            if (!_isInitialized)
            {
                field = LoadExpensiveData();
                _isInitialized = true;
            }
            return field;
        }
    }
    
    private string LoadExpensiveData()
    {
        Console.WriteLine("데이터 로딩 중...");
        System.Threading.Thread.Sleep(1000);
        return "비싼 데이터";
    }
}

// 처음 접근 시에만 로딩
var loader = new DataLoader();
Console.WriteLine(loader.Data);  // 데이터 로딩 중...
Console.WriteLine(loader.Data);  // 캐시된 데이터 사용
```

---

## 33.2 Extensions (확장 타입)

Extensions는 기존의 확장 메서드를 넘어서, 타입에 속성, 이벤트, 심지어 인터페이스 구현까지 추가할 수 있는 새로운 메커니즘입니다. (주의: 이 기능은 아직 설계 단계이며 변경될 수 있습니다)

**개념적 예제:**

```csharp
// 확장 타입 정의 (예상 문법)
public extension StringExtensions for string
{
    // 확장 속성
    public bool IsValidEmail => this.Contains("@") && this.Contains(".");
    
    // 확장 메서드
    public string Truncate(int maxLength)
    {
        return this.Length <= maxLength 
            ? this 
            : this.Substring(0, maxLength) + "...";
    }
    
    // 계산 속성
    public int WordCount => this.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
}

// 사용
string email = "user@example.com";
Console.WriteLine(email.IsValidEmail);  // True

string text = "이것은 긴 텍스트입니다";
Console.WriteLine(text.Truncate(5));  // 이것은 긴...
Console.WriteLine(text.WordCount);  // 4
```

**확장 인터페이스 구현 (개념):**

```csharp
// 기존 타입에 인터페이스 구현 추가
public interface IValidatable
{
    bool IsValid();
}

public extension PersonExtension for Person : IValidatable
{
    public bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(this.Name) && this.Age > 0;
    }
}

// 사용
Person person = new Person { Name = "홍길동", Age = 30 };
if (person is IValidatable validatable)
{
    Console.WriteLine($"유효성: {validatable.IsValid()}");
}
```

**참고**: Extensions 기능은 아직 C# 언어 설계 팀에서 논의 중이며, 최종 문법과 동작은 변경될 수 있습니다.

---

## 33.3 Discriminated Unions (판별된 합 타입)

Discriminated unions (또는 sum types)는 여러 타입 중 하나를 안전하게 표현할 수 있는 기능입니다. F#이나 Rust 같은 언어에서 이미 제공하는 기능으로, C# 14에서도 도입이 논의되고 있습니다.

**현재 방식의 한계:**

```csharp
// C# 12까지 - 상속과 패턴 매칭으로 흉내
public abstract record Result
{
    public record Success(string Value) : Result;
    public record Error(string Message) : Result;
}

Result ProcessData()
{
    if (Random.Shared.Next(2) == 0)
        return new Result.Success("성공!");
    return new Result.Error("실패!");
}

// 사용
var result = ProcessData();
string message = result switch
{
    Result.Success s => $"성공: {s.Value}",
    Result.Error e => $"오류: {e.Message}",
    _ => "알 수 없음"
};
```

**예상되는 Discriminated Union 문법:**

```csharp
// C# 14 예상 문법 (아직 확정되지 않음)
public union Result<T>
{
    Success(T value),
    Error(string message)
}

// 또는
public enum Result<T>
{
    case Success(T value);
    case Error(string message);
}

// 사용
Result<string> ProcessData()
{
    if (Random.Shared.Next(2) == 0)
        return Result.Success("데이터 처리 완료");
    return Result.Error("처리 실패");
}

// 패턴 매칭
var result = ProcessData();
string message = result switch
{
    Success(var value) => $"성공: {value}",
    Error(var msg) => $"오류: {msg}"
};
```

**실전 예제 (현재 패턴으로 구현):**

```csharp
// 현재 C#으로 구현 가능한 방식
public abstract record Option<T>
{
    public record Some(T Value) : Option<T>;
    public record None : Option<T>;
}

public static class OptionExtensions
{
    public static Option<T> ToOption<T>(this T? value) where T : class
    {
        return value is null ? new Option<T>.None() : new Option<T>.Some(value);
    }
    
    public static TResult Match<T, TResult>(
        this Option<T> option,
        Func<T, TResult> some,
        Func<TResult> none)
    {
        return option switch
        {
            Option<T>.Some s => some(s.Value),
            Option<T>.None => none(),
            _ => throw new InvalidOperationException()
        };
    }
}

// 사용 예제
Option<string> FindUser(int id)
{
    return id > 0 
        ? new Option<string>.Some($"사용자 {id}") 
        : new Option<string>.None();
}

var user = FindUser(1);
string message = user.Match(
    some: name => $"찾음: {name}",
    none: () => "사용자를 찾을 수 없습니다"
);

Console.WriteLine(message);
```

---

## 33.4 패턴 매칭 개선

C# 14에서는 패턴 매칭이 더욱 강화될 것으로 예상됩니다.

**예상되는 개선사항:**

```csharp
// 더 강력한 리스트 패턴
int[] numbers = { 1, 2, 3, 4, 5 };

// 조건부 패턴 (예상)
if (numbers is [var first, .. var middle, var last] when first > 0)
{
    Console.WriteLine($"첫 번째: {first}, 마지막: {last}");
    Console.WriteLine($"중간: {string.Join(", ", middle)}");
}

// 중첩 패턴 개선
record Person(string Name, Address Address);
record Address(string City, string Country);

Person person = new("홍길동", new Address("서울", "한국"));

// 더 간결한 중첩 패턴
if (person is { Address.City: "서울", Address.Country: var country })
{
    Console.WriteLine($"서울, {country}에 거주");
}
```

**실전 예제 - 복잡한 데이터 처리:**

```csharp
record Order(int Id, string Status, decimal Amount, Customer Customer);
record Customer(string Name, string Tier);

void ProcessOrder(Order order)
{
    string result = order switch
    {
        // 복잡한 중첩 패턴
        { Status: "pending", Amount: > 1000000, Customer.Tier: "VIP" } 
            => "VIP 대형 주문 우선 처리",
        
        { Status: "pending", Amount: > 100000 } 
            => "대형 주문 처리",
        
        { Status: "pending", Customer.Tier: "VIP" } 
            => "VIP 주문 처리",
        
        { Status: "cancelled" } 
            => "취소된 주문",
        
        _ => "일반 처리"
    };
    
    Console.WriteLine($"주문 {order.Id}: {result}");
}

// 사용
var orders = new[]
{
    new Order(1, "pending", 1500000, new Customer("홍길동", "VIP")),
    new Order(2, "pending", 50000, new Customer("김철수", "Regular")),
    new Order(3, "cancelled", 100000, new Customer("이영희", "VIP"))
};

foreach (var order in orders)
{
    ProcessOrder(order);
}
```

---

## 33.5 성능 최적화

C# 14는 계속해서 성능과 메모리 효율성을 개선할 것으로 예상됩니다.

**예상되는 개선 영역:**

1. **더 나은 인라이닝**: 컴파일러가 더 많은 메서드를 인라이닝하여 성능 향상
2. **개선된 구조체 처리**: 구조체 복사 최소화
3. **SIMD 최적화**: 벡터화된 연산 개선
4. **메모리 할당 감소**: 더 많은 상황에서 스택 할당 활용

**현재 사용 가능한 고성능 패턴:**

```csharp
using System.Runtime.CompilerServices;
using System.Runtime.Intrinsics;

// 고성능 벡터 연산
[MethodImpl(MethodImplOptions.AggressiveInlining)]
static void MultiplyArrays(Span<int> a, Span<int> b, Span<int> result)
{
    for (int i = 0; i < a.Length; i++)
    {
        result[i] = a[i] * b[i];
    }
}

// SIMD 벡터 사용
static void MultiplyArraysSimd(Span<int> a, Span<int> b, Span<int> result)
{
    int vectorSize = Vector<int>.Count;
    int i = 0;
    
    // 벡터화된 처리
    for (; i <= a.Length - vectorSize; i += vectorSize)
    {
        var va = new Vector<int>(a.Slice(i, vectorSize));
        var vb = new Vector<int>(b.Slice(i, vectorSize));
        (va * vb).CopyTo(result.Slice(i, vectorSize));
    }
    
    // 나머지 요소 처리
    for (; i < a.Length; i++)
    {
        result[i] = a[i] * b[i];
    }
}

// 성능 비교
using System.Diagnostics;

int size = 1000000;
int[] a = new int[size];
int[] b = new int[size];
int[] result = new int[size];

// 배열 초기화
for (int i = 0; i < size; i++)
{
    a[i] = i;
    b[i] = i * 2;
}

var sw = Stopwatch.StartNew();
MultiplyArrays(a, b, result);
Console.WriteLine($"일반: {sw.ElapsedMilliseconds}ms");

sw.Restart();
MultiplyArraysSimd(a, b, result);
Console.WriteLine($"SIMD: {sw.ElapsedMilliseconds}ms");
```

---

## 33.6 기타 예상 기능

### 더 나은 타입 추론

```csharp
// 더 스마트한 타입 추론 (예상)
var numbers = [1, 2, 3];  // List<int>로 추론
var mixed = [1, "text", 3.14];  // 공통 타입으로 추론?

// 람다 타입 추론 개선
var multiply = (x, y) => x * y;  // 제네릭 함수로 추론?
```

### UTF-8 문자열 개선

```csharp
// UTF-8 문자열 리터럴 개선 (예상)
ReadOnlySpan<byte> utf8String = "Hello"u8;
string text = "안녕하세요"u8.ToString();
```

### 개선된 nullable 분석

```csharp
// 더 스마트한 null 체크
string? GetValue() => Random.Shared.Next(2) == 0 ? "value" : null;

string value = GetValue();
if (value is not null)
{
    // C# 14: 컴파일러가 더 정확히 null이 아님을 인식
    ProcessNonNull(value);
}

void ProcessNonNull(string nonNullValue)
{
    Console.WriteLine(nonNullValue.Length);
}
```

---

## 33.7 실전 종합 예제

```csharp
// C# 14 프리뷰 기능을 활용한 예제
public class UserService
{
    public string Name
    {
        get => field;
        set => field = string.IsNullOrWhiteSpace(value)
            ? throw new ArgumentException("이름 필수")
            : value.Trim();
    }
    
    // Option 타입으로 안전한 반환
    public Option<User> FindUser(int id)
    {
        return id > 0 
            ? new Option<User>.Some(new User { Id = id, Name = $"사용자{id}" })
            : new Option<User>.None();
    }
    
    // 패턴 매칭으로 처리
    public string ProcessUser(int id)
    {
        return FindUser(id) switch
        {
            Option<User>.Some { Value: var user } => $"찾음: {user.Name}",
            Option<User>.None => "사용자 없음",
            _ => "오류"
        };
    }
}

public class User
{
    public int Id { get; set; }
    public string Name { get; set; } = "";
}

// 사용
var service = new UserService { Name = "UserService" };
Console.WriteLine(service.ProcessUser(1));  // 찾음: 사용자1
Console.WriteLine(service.ProcessUser(-1)); // 사용자 없음
```

---

## 33.8 마치며

C# 14는 언어를 더욱 강력하고 표현력 있게 만들 것으로 기대됩니다. field 키워드는 속성을 더 간결하게 만들고, extensions는 타입 확장의 새로운 가능성을 열며, discriminated unions는 타입 안전성을 크게 향상시킬 것입니다.

**중요 사항:**
- 이 장의 내용은 프리뷰 기능을 기반으로 합니다
- 실제 출시 시 변경될 수 있습니다
- 프로덕션 코드에서는 안정 버전 사용을 권장합니다
- 최신 정보는 공식 C# 문서를 참조하세요

**학습 요약:**
- field 키워드로 간결한 속성 정의
- Extensions로 타입 확장 메커니즘 개선
- Discriminated unions로 타입 안전성 강화
- 패턴 매칭과 성능의 지속적인 개선

**다음 단계:**
- C# 14 프리뷰 버전 실험
- .NET 10 프리뷰 기능 탐색
- 커뮤니티 피드백 참여
- 최신 C# 디자인 노트 팔로우

**참고 자료:**
- [C# 언어 디자인 노트](https://github.com/dotnet/csharplang)
- [.NET 블로그](https://devblogs.microsoft.com/dotnet/)
- [C# 프리뷰 기능](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/)

**면책 조항**: 이 장에서 설명한 C# 14 기능들은 현재 프리뷰 상태이거나 계획 단계에 있습니다. Microsoft는 피드백과 실제 사용 경험을 바탕으로 이러한 기능을 변경, 개선 또는 제거할 수 있습니다. 프로덕션 환경에서 사용하기 전에 반드시 공식 릴리스 노트와 문서를 확인하시기 바랍니다.
