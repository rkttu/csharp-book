# 7장. 메서드 기초

프로그래밍에서 메서드(Method)는 특정 작업을 수행하는 코드의 묶음입니다. 메서드를 사용하면 코드를 재사용할 수 있고, 프로그램의 구조를 논리적으로 구성할 수 있으며, 복잡한 문제를 작은 단위로 나누어 해결할 수 있습니다. 지금까지 우리는 `Console.WriteLine()`, `Console.ReadLine()`과 같은 미리 정의된 메서드들을 사용해왔습니다. 이제는 직접 메서드를 정의하고 활용하는 방법을 배울 차례입니다.

메서드의 개념은 수학의 함수(Function)와 매우 유사합니다. 수학에서 f(x) = x + 1이라는 함수는 입력값 x를 받아 x에 1을 더한 결과를 반환합니다. 프로그래밍의 메서드도 마찬가지로 입력(매개변수)을 받아 특정 작업을 수행하고, 필요에 따라 결과(반환값)를 돌려줍니다. 이러한 구조는 코드의 중복을 줄이고, 각 기능을 독립적으로 테스트하고 관리할 수 있게 해줍니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#에서 메서드를 정의하고 활용하는 다양한 방법을 학습하게 됩니다:

- **메서드 정의와 호출**: 메서드의 기본 구조를 이해하고, 메서드를 정의하여 호출하는 방법을 익힙니다.

- **매개변수와 반환값**: 메서드에 데이터를 전달하고 결과를 받는 방법을 배우며, 값 타입과 참조 타입의 차이, `ref`와 `out` 키워드의 활용을 이해합니다.

- **메서드 오버로딩**: 같은 이름의 메서드를 매개변수를 다르게 하여 여러 버전으로 정의하는 방법을 학습합니다.

- **선택적 매개변수와 명명된 인수**: 유연한 메서드 호출을 가능하게 하는 현대적인 C# 기능을 익힙니다.

- **로컬 함수**: 메서드 내부에 정의되는 지역 함수의 개념과 활용 방법을 배웁니다.

---

## 7.1 메서드 정의와 호출

메서드는 특정 작업을 수행하는 코드 블록으로, 필요할 때마다 이름을 통해 호출할 수 있습니다. 메서드를 사용하면 같은 코드를 반복해서 작성하지 않아도 되므로, 코드의 재사용성과 유지보수성이 크게 향상됩니다.

**메서드의 기본 구조:**

```csharp
반환타입 메서드이름(매개변수목록)
{
    // 메서드가 수행할 코드
    return 반환값;  // 반환타입이 void가 아닌 경우
}
```

**가장 간단한 메서드:**

```csharp
// 반환값이 없고 매개변수도 없는 메서드
void SayHello()
{
    Console.WriteLine("안녕하세요!");
}

// 메서드 호출
SayHello();
SayHello();

// 출력:
// 안녕하세요!
// 안녕하세요!
```

**반환값이 있는 메서드:**

```csharp
// 정수를 반환하는 메서드
int GetNumber()
{
    return 42;
}

// 메서드 호출 및 반환값 사용
int result = GetNumber();
Console.WriteLine($"결과: {result}");

// 출력:
// 결과: 42
```

**실용 예제 - 인사 메서드:**

```csharp
void Greet()
{
    Console.WriteLine("환영합니다!");
    Console.WriteLine("C# 프로그래밍을 시작합니다.");
}

// 프로그램 시작
Console.WriteLine("프로그램 시작");
Greet();
Console.WriteLine("프로그램 종료");

// 출력:
// 프로그램 시작
// 환영합니다!
// C# 프로그래밍을 시작합니다.
// 프로그램 종료
```

**메서드를 사용하는 이유:**

1. **코드 재사용**: 같은 코드를 여러 번 작성하지 않고 메서드 호출로 대체
2. **가독성 향상**: 복잡한 코드를 의미 있는 이름의 메서드로 분리
3. **유지보수 용이**: 기능 수정 시 메서드 하나만 수정하면 모든 호출 지점에 반영
4. **테스트 편의성**: 각 메서드를 독립적으로 테스트 가능

**메서드 명명 규칙:**

C#에서 메서드 이름은 **PascalCase**를 사용합니다. 첫 글자와 각 단어의 첫 글자를 대문자로 작성합니다.

```csharp
// 좋은 예
void CalculateTotal()
void SendEmail()
void ValidateUserInput()

// 나쁜 예
void calculate_total()    // ❌ snake_case는 C#에서 사용하지 않음
void sendemail()          // ❌ 단어 구분이 없어 읽기 어려움
void Validate_User_Input() // ❌ 혼합 스타일
```

---

## 7.2 매개변수와 반환값

메서드는 외부로부터 데이터를 입력받아 처리할 수 있습니다. 이때 입력받는 데이터를 **매개변수(Parameter)** 또는 **인수(Argument)**라고 하며, 처리 결과를 돌려주는 것을 **반환값(Return Value)**이라고 합니다.

**매개변수가 있는 메서드:**

```csharp
// 이름을 매개변수로 받는 메서드
void Greet(string name)
{
    Console.WriteLine($"안녕하세요, {name}님!");
}

// 메서드 호출 - 인수 전달
Greet("홍길동");
Greet("김철수");

// 출력:
// 안녕하세요, 홍길동님!
// 안녕하세요, 김철수님!
```

**여러 개의 매개변수:**

```csharp
// 두 개의 정수를 받아 더하는 메서드
int Add(int a, int b)
{
    return a + b;
}

// 메서드 호출
int result1 = Add(10, 20);
int result2 = Add(5, 15);

Console.WriteLine($"10 + 20 = {result1}");
Console.WriteLine($"5 + 15 = {result2}");

// 출력:
// 10 + 20 = 30
// 5 + 15 = 20
```

**매개변수와 인수의 차이:**

- **매개변수(Parameter)**: 메서드 정의에서 선언하는 변수
- **인수(Argument)**: 메서드를 호출할 때 전달하는 실제 값

```csharp
// a, b는 매개변수
int Multiply(int a, int b)
{
    return a * b;
}

// 5, 3은 인수
int result = Multiply(5, 3);
```

### 7.2.1 값 타입 매개변수

값 타입(Value Type) 매개변수는 데이터의 복사본이 메서드로 전달됩니다. 따라서 메서드 내부에서 매개변수를 변경해도 원본 값은 영향을 받지 않습니다. `int`, `double`, `bool`, `struct` 등이 값 타입에 해당합니다.

**값 타입의 동작:**

```csharp
void ChangeNumber(int number)
{
    number = 100;  // 복사본을 변경
    Console.WriteLine($"메서드 내부: {number}");
}

int original = 10;
Console.WriteLine($"호출 전: {original}");
ChangeNumber(original);
Console.WriteLine($"호출 후: {original}");

// 출력:
// 호출 전: 10
// 메서드 내부: 100
// 호출 후: 10  (원본은 변경되지 않음)
```

**값 타입 매개변수의 특징:**

1. **복사본 전달**: 원본 데이터의 복사본이 생성되어 전달됩니다.
2. **안전성**: 메서드가 원본 데이터를 변경할 수 없어 안전합니다.
3. **메모리**: 작은 데이터에 적합하며, 큰 구조체는 성능에 영향을 줄 수 있습니다.

**실용 예제 - 계산 메서드:**

```csharp
double CalculateCircleArea(double radius)
{
    const double PI = 3.14159;
    return PI * radius * radius;
}

double r = 5.0;
double area = CalculateCircleArea(r);
Console.WriteLine($"반지름 {r}인 원의 넓이: {area:F2}");

// 출력:
// 반지름 5인 원의 넓이: 78.54
```

### 7.2.2 참조 타입 매개변수

참조 타입(Reference Type) 매개변수는 데이터가 저장된 메모리 위치(참조)가 전달됩니다. 따라서 메서드 내부에서 객체의 내용을 변경하면 원본에도 영향을 미칩니다. `string`, `array`, `class` 등이 참조 타입에 해당합니다.

**참조 타입의 동작 - 배열:**

```csharp
void ModifyArray(int[] numbers)
{
    numbers[0] = 999;  // 원본 배열을 변경
}

int[] myArray = { 1, 2, 3 };
Console.WriteLine($"변경 전: {myArray[0]}");
ModifyArray(myArray);
Console.WriteLine($"변경 후: {myArray[0]}");

// 출력:
// 변경 전: 1
// 변경 후: 999  (원본이 변경됨)
```

**참조 타입의 특수성 - 문자열:**

문자열은 참조 타입이지만 **불변(Immutable)** 객체입니다. 따라서 메서드 내에서 문자열을 "변경"하면 실제로는 새로운 문자열 객체가 생성됩니다.

```csharp
void ChangeString(string text)
{
    text = "변경된 문자열";  // 새로운 문자열 객체 생성
    Console.WriteLine($"메서드 내부: {text}");
}

string original = "원본 문자열";
Console.WriteLine($"호출 전: {original}");
ChangeString(original);
Console.WriteLine($"호출 후: {original}");

// 출력:
// 호출 전: 원본 문자열
// 메서드 내부: 변경된 문자열
// 호출 후: 원본 문자열  (원본은 변경되지 않음)
```

**참조 타입 매개변수의 특징:**

1. **참조 전달**: 메모리 주소가 전달되므로 큰 객체도 효율적으로 전달됩니다.
2. **원본 수정 가능**: 객체의 내용을 변경하면 원본에 반영됩니다.
3. **null 가능**: 참조 타입은 null 값을 가질 수 있어 주의가 필요합니다.

**실용 예제 - 배열 처리:**

```csharp
void FillArray(int[] array, int value)
{
    for (int i = 0; i < array.Length; i++)
    {
        array[i] = value;
    }
}

int[] numbers = new int[5];
FillArray(numbers, 7);

Console.Write("배열 내용: ");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

// 출력:
// 배열 내용: 7 7 7 7 7
```

### 7.2.3 ref와 out 키워드

C#은 매개변수 전달 방식을 명시적으로 제어할 수 있는 `ref`와 `out` 키워드를 제공합니다. 이들은 값 타입을 참조로 전달하거나, 메서드에서 여러 값을 반환해야 할 때 유용합니다.

**ref 키워드:**

`ref` 키워드는 변수를 참조로 전달합니다. 메서드 내에서 변경한 내용이 원본에 반영됩니다. `ref`를 사용하려면 변수가 **반드시 초기화**되어 있어야 합니다.

```csharp
void Increment(ref int number)
{
    number++;
}

int count = 10;
Console.WriteLine($"호출 전: {count}");
Increment(ref count);  // ref 키워드를 호출 시에도 명시
Console.WriteLine($"호출 후: {count}");

// 출력:
// 호출 전: 10
// 호출 후: 11  (원본이 변경됨)
```

**ref의 특징:**

- 매개변수는 메서드 호출 전에 초기화되어야 함
- 메서드 정의와 호출 시 모두 `ref` 키워드 필요
- 메서드 내에서 값을 읽고 쓰기 모두 가능

**out 키워드:**

`out` 키워드도 참조로 전달하지만, 메서드 내에서 **반드시 값을 할당**해야 합니다. 메서드가 여러 값을 반환해야 할 때 유용합니다.

```csharp
void Divide(int dividend, int divisor, out int quotient, out int remainder)
{
    quotient = dividend / divisor;
    remainder = dividend % divisor;
}

int a = 17;
int b = 5;
Divide(a, b, out int q, out int r);  // out 변수는 호출 시 선언 가능

Console.WriteLine($"{a} ÷ {b} = {q} 나머지 {r}");

// 출력:
// 17 ÷ 5 = 3 나머지 2
```

**out의 특징:**

- 매개변수는 메서드 호출 전에 초기화되지 않아도 됨
- 메서드 내에서 반드시 값을 할당해야 함
- 메서드 정의와 호출 시 모두 `out` 키워드 필요
- C# 7.0부터 호출 시 변수 선언 가능 (`out int result`)

**ref와 out 비교:**

```csharp
// ref - 초기화 필수, 읽기/쓰기 가능
void UseRef(ref int value)
{
    Console.WriteLine($"받은 값: {value}");  // 읽기 가능
    value = value * 2;  // 쓰기 가능
}

int x = 5;
UseRef(ref x);

// out - 초기화 불필요, 반드시 할당해야 함
void UseOut(out int value)
{
    // Console.WriteLine(value);  // ❌ 할당 전에는 읽을 수 없음
    value = 10;  // 반드시 할당
}

UseOut(out int y);  // 초기화하지 않아도 됨
```

**실용 예제 - 문자열 파싱:**

```csharp
void TryParseNumber(string input, out bool success, out int result)
{
    success = int.TryParse(input, out result);
}

string userInput = "123";
TryParseNumber(userInput, out bool isValid, out int number);

if (isValid)
{
    Console.WriteLine($"변환 성공: {number}");
}
else
{
    Console.WriteLine("변환 실패");
}

// 출력:
// 변환 성공: 123
```

---

## 7.3 메서드 오버로딩

메서드 오버로딩(Method Overloading)은 같은 이름의 메서드를 매개변수의 개수나 타입을 다르게 하여 여러 버전으로 정의하는 것입니다. 이를 통해 비슷한 기능을 하는 메서드들을 하나의 이름으로 통일할 수 있어 코드의 일관성과 가독성이 향상됩니다.

**기본 개념:**

```csharp
// 매개변수 개수가 다른 오버로딩
void Print(string message)
{
    Console.WriteLine(message);
}

void Print(string message, int count)
{
    for (int i = 0; i < count; i++)
    {
        Console.WriteLine(message);
    }
}

// 사용
Print("안녕하세요");           // 첫 번째 메서드 호출
Print("반갑습니다", 3);        // 두 번째 메서드 호출

// 출력:
// 안녕하세요
// 반갑습니다
// 반갑습니다
// 반갑습니다
```

**매개변수 타입이 다른 오버로딩:**

```csharp
int Add(int a, int b)
{
    return a + b;
}

double Add(double a, double b)
{
    return a + b;
}

string Add(string a, string b)
{
    return a + b;
}

// 사용
Console.WriteLine(Add(5, 3));           // 8 (int 버전)
Console.WriteLine(Add(2.5, 3.7));       // 6.2 (double 버전)
Console.WriteLine(Add("Hello, ", "World!"));  // Hello, World! (string 버전)
```

**오버로딩 규칙:**

1. **메서드 시그니처**: 메서드 이름, 매개변수의 개수, 매개변수의 타입, 매개변수의 순서로 구분
2. **반환 타입 불가**: 반환 타입만 다르게 해서는 오버로딩할 수 없음
3. **매개변수 이름 불가**: 매개변수 이름만 다르게 해서는 오버로딩할 수 없음

```csharp
// ✅ 올바른 오버로딩 - 매개변수 타입이 다름
int Calculate(int a, int b)
{
    return a + b;
}

double Calculate(double a, double b)
{
    return a + b;
}

// ❌ 잘못된 오버로딩 - 반환 타입만 다름 (컴파일 오류)
// int Process(int x)
// {
//     return x * 2;
// }
// 
// double Process(int x)  // ❌ 에러: 반환 타입만 다름
// {
//     return x * 2.0;
// }

// ❌ 잘못된 오버로딩 - 매개변수 이름만 다름 (컴파일 오류)
// void Method(int a)
// {
// }
// 
// void Method(int b)  // ❌ 에러: 매개변수 이름만 다름
// {
// }
```

**실용 예제 - 다양한 형태의 로그 출력:**

```csharp
void Log(string message)
{
    Console.WriteLine($"[INFO] {message}");
}

void Log(string message, string level)
{
    Console.WriteLine($"[{level}] {message}");
}

void Log(string message, string level, DateTime timestamp)
{
    Console.WriteLine($"[{timestamp:yyyy-MM-dd HH:mm:ss}] [{level}] {message}");
}

// 사용
Log("애플리케이션 시작");
Log("데이터베이스 연결 성공", "SUCCESS");
Log("파일 처리 완료", "INFO", DateTime.Now);

// 출력:
// [INFO] 애플리케이션 시작
// [SUCCESS] 데이터베이스 연결 성공
// [2024-01-15 14:30:25] [INFO] 파일 처리 완료
```

**C# 표준 라이브러리의 오버로딩 예:**

C#의 많은 내장 메서드들이 오버로딩을 사용합니다:

```csharp
// Console.WriteLine의 다양한 오버로드
Console.WriteLine();                    // 빈 줄 출력
Console.WriteLine("문자열");            // 문자열 출력
Console.WriteLine(123);                 // 정수 출력
Console.WriteLine(3.14);                // 실수 출력
Console.WriteLine(true);                // 불린 출력

// String.Substring의 오버로드
string text = "Hello, World!";
string part1 = text.Substring(7);       // "World!" (시작 인덱스만)
string part2 = text.Substring(0, 5);    // "Hello" (시작 인덱스와 길이)
```

---

## 7.4 선택적 매개변수와 명명된 인수

C# 4.0에서 도입된 선택적 매개변수(Optional Parameters)와 명명된 인수(Named Arguments)는 메서드 호출을 더욱 유연하고 가독성 있게 만들어주는 기능입니다.

### 선택적 매개변수 (Optional Parameters)

선택적 매개변수는 기본값을 가지는 매개변수로, 호출 시 값을 생략할 수 있습니다.

```csharp
void Greet(string name, string greeting = "안녕하세요")
{
    Console.WriteLine($"{greeting}, {name}님!");
}

// 다양한 호출 방법
Greet("홍길동");                    // 기본 인사말 사용
Greet("김철수", "반갑습니다");      // 사용자 정의 인사말

// 출력:
// 안녕하세요, 홍길동님!
// 반갑습니다, 김철수님!
```

**여러 개의 선택적 매개변수:**

```csharp
void CreateUser(string name, int age = 0, string city = "서울", bool isActive = true)
{
    Console.WriteLine($"이름: {name}");
    Console.WriteLine($"나이: {age}");
    Console.WriteLine($"도시: {city}");
    Console.WriteLine($"활성: {isActive}");
}

// 다양한 호출
CreateUser("이영희");
CreateUser("박민수", 30);
CreateUser("최지훈", 25, "부산");

// 출력:
// 이름: 이영희
// 나이: 0
// 도시: 서울
// 활성: True
// 
// 이름: 박민수
// 나이: 30
// 도시: 서울
// 활성: True
// 
// 이름: 최지훈
// 나이: 25
// 도시: 부산
// 활성: True
```

**선택적 매개변수 규칙:**

1. 선택적 매개변수는 필수 매개변수 뒤에 위치해야 함
2. 기본값은 컴파일 타임 상수여야 함
3. `ref`, `out` 매개변수는 선택적으로 만들 수 없음

```csharp
// ✅ 올바른 순서
void Method1(int required, string optional = "default")
{
}

// ❌ 잘못된 순서
// void Method2(string optional = "default", int required)  // 컴파일 오류
// {
// }
```

### 명명된 인수 (Named Arguments)

명명된 인수는 매개변수 이름을 명시하여 값을 전달하는 방식입니다. 순서에 관계없이 인수를 전달할 수 있으며, 코드의 가독성이 향상됩니다.

```csharp
void SetupConnection(string server, int port, string username, string password)
{
    Console.WriteLine($"서버: {server}:{port}");
    Console.WriteLine($"사용자: {username}");
}

// 명명된 인수 사용
SetupConnection(
    server: "localhost",
    port: 8080,
    username: "admin",
    password: "1234"
);

// 순서를 바꿔도 됨
SetupConnection(
    username: "admin",
    password: "1234",
    server: "localhost",
    port: 8080
);
```

**선택적 매개변수와 명명된 인수의 결합:**

```csharp
void SendEmail(string to, string subject, string body = "", bool isHtml = false, int priority = 1)
{
    Console.WriteLine($"받는사람: {to}");
    Console.WriteLine($"제목: {subject}");
    Console.WriteLine($"내용: {body}");
    Console.WriteLine($"HTML: {isHtml}");
    Console.WriteLine($"우선순위: {priority}");
}

// 중간 매개변수만 지정하기
SendEmail(
    to: "user@example.com",
    subject: "안내",
    isHtml: true,      // body는 기본값, isHtml만 지정
    priority: 5
);

// 출력:
// 받는사람: user@example.com
// 제목: 안내
// 내용: 
// HTML: True
// 우선순위: 5
```

**실용 예제 - 로그 메서드:**

```csharp
void WriteLog(
    string message,
    string level = "INFO",
    bool includeTimestamp = true,
    bool includeLineBreak = true)
{
    if (includeTimestamp)
    {
        Console.Write($"[{DateTime.Now:HH:mm:ss}] ");
    }
    
    Console.Write($"[{level}] {message}");
    
    if (includeLineBreak)
    {
        Console.WriteLine();
    }
}

// 다양한 사용
WriteLog("애플리케이션 시작");
WriteLog("경고 메시지", level: "WARNING");
WriteLog("에러 발생", level: "ERROR", includeTimestamp: false);

// 출력:
// [14:30:15] [INFO] 애플리케이션 시작
// [14:30:15] [WARNING] 경고 메시지
// [ERROR] 에러 발생
```

**명명된 인수의 장점:**

1. **가독성**: 매개변수의 의미가 명확해짐
2. **유연성**: 순서에 관계없이 인수 전달 가능
3. **선택성**: 원하는 매개변수만 지정 가능

---

## 7.5 로컬 함수 (Local Functions)

로컬 함수는 C# 7.0에서 도입된 기능으로, 메서드 내부에 정의되는 지역 함수입니다. 특정 메서드에서만 사용되는 헬퍼 함수를 정의할 때 유용하며, 코드의 응집도를 높이고 외부에 노출되지 않아야 하는 로직을 캡슐화할 수 있습니다.

**기본 구조:**

```csharp
void OuterMethod()
{
    Console.WriteLine("외부 메서드 시작");
    
    // 로컬 함수 정의
    void InnerFunction()
    {
        Console.WriteLine("로컬 함수 실행");
    }
    
    // 로컬 함수 호출
    InnerFunction();
    InnerFunction();
    
    Console.WriteLine("외부 메서드 종료");
}

OuterMethod();

// 출력:
// 외부 메서드 시작
// 로컬 함수 실행
// 로컬 함수 실행
// 외부 메서드 종료
```

**로컬 함수의 특징:**

1. **범위**: 정의된 메서드 내부에서만 호출 가능
2. **접근**: 외부 메서드의 지역 변수와 매개변수에 접근 가능
3. **재귀**: 로컬 함수도 재귀 호출이 가능

**외부 변수 접근:**

```csharp
void ProcessData(int[] numbers)
{
    int sum = 0;
    
    // 로컬 함수는 외부 변수에 접근 가능
    void AddToSum(int value)
    {
        sum += value;  // 외부 변수 sum에 접근
    }
    
    foreach (int num in numbers)
    {
        AddToSum(num);
    }
    
    Console.WriteLine($"합계: {sum}");
}

ProcessData(new int[] { 1, 2, 3, 4, 5 });

// 출력:
// 합계: 15
```

**반환값이 있는 로컬 함수:**

```csharp
void CalculateStatistics(int[] numbers)
{
    // 평균을 계산하는 로컬 함수
    double GetAverage()
    {
        double sum = 0;
        foreach (int num in numbers)
        {
            sum += num;
        }
        return sum / numbers.Length;
    }
    
    // 최댓값을 찾는 로컬 함수
    int GetMax()
    {
        int max = numbers[0];
        foreach (int num in numbers)
        {
            if (num > max)
            {
                max = num;
            }
        }
        return max;
    }
    
    Console.WriteLine($"평균: {GetAverage():F2}");
    Console.WriteLine($"최댓값: {GetMax()}");
}

CalculateStatistics(new int[] { 5, 12, 8, 20, 3 });

// 출력:
// 평균: 9.60
// 최댓값: 20
```

**재귀 로컬 함수:**

```csharp
void PrintFactorial(int n)
{
    // 팩토리얼을 계산하는 재귀 로컬 함수
    long Factorial(int number)
    {
        if (number <= 1)
        {
            return 1;
        }
        return number * Factorial(number - 1);
    }
    
    Console.WriteLine($"{n}! = {Factorial(n)}");
}

PrintFactorial(5);
PrintFactorial(7);

// 출력:
// 5! = 120
// 7! = 5040
```

**로컬 함수 vs 람다식:**

로컬 함수는 람다식과 비슷해 보일 수 있지만 몇 가지 중요한 차이가 있습니다:

```csharp
void CompareLocalFunctionAndLambda()
{
    // 로컬 함수
    int LocalAdd(int a, int b)
    {
        return a + b;
    }
    
    // 람다식
    Func<int, int, int> lambdaAdd = (a, b) => a + b;
    
    Console.WriteLine($"로컬 함수: {LocalAdd(5, 3)}");
    Console.WriteLine($"람다식: {lambdaAdd(5, 3)}");
}
```

**로컬 함수의 장점:**

| 특성 | 로컬 함수 | 람다식 |
|------|----------|--------|
| 재귀 | 쉽게 가능 | 복잡함 |
| 성능 | 약간 더 효율적 | 델리게이트 생성 |
| 제네릭 | 지원 | 제한적 |
| 가독성 | 명확한 메서드 형태 | 간결한 표현 |

**실용 예제 - 유효성 검증:**

```csharp
bool ValidateUser(string username, string email, int age)
{
    // 사용자명 검증 로컬 함수
    bool IsValidUsername()
    {
        return !string.IsNullOrWhiteSpace(username) && username.Length >= 3;
    }
    
    // 이메일 검증 로컬 함수
    bool IsValidEmail()
    {
        return !string.IsNullOrWhiteSpace(email) && email.Contains("@");
    }
    
    // 나이 검증 로컬 함수
    bool IsValidAge()
    {
        return age >= 0 && age <= 150;
    }
    
    // 모든 검증 수행
    if (!IsValidUsername())
    {
        Console.WriteLine("사용자명이 유효하지 않습니다.");
        return false;
    }
    
    if (!IsValidEmail())
    {
        Console.WriteLine("이메일이 유효하지 않습니다.");
        return false;
    }
    
    if (!IsValidAge())
    {
        Console.WriteLine("나이가 유효하지 않습니다.");
        return false;
    }
    
    Console.WriteLine("모든 검증 통과!");
    return true;
}

// 테스트
ValidateUser("홍길동", "hong@example.com", 25);
ValidateUser("김", "invalid-email", 30);

// 출력:
// 모든 검증 통과!
// 사용자명이 유효하지 않습니다.
```

**언제 로컬 함수를 사용할까:**

1. **헬퍼 함수**: 특정 메서드에서만 사용되는 보조 함수
2. **반복 제거**: 같은 로직이 메서드 내에서 여러 번 반복될 때
3. **가독성**: 복잡한 메서드를 논리적 단위로 분리할 때
4. **캡슐화**: 외부에 노출할 필요 없는 로직을 숨길 때

---

## 7장 정리 및 요약

이 장에서는 C#에서 메서드를 정의하고 활용하는 다양한 방법을 학습했습니다.

### 핵심 개념 정리

1. **메서드 정의와 호출**
   - 메서드는 특정 작업을 수행하는 코드의 묶음
   - 코드 재사용성과 유지보수성 향상
   - 반환 타입, 메서드 이름, 매개변수로 구성

2. **매개변수와 반환값**
   - 값 타입: 복사본 전달, 원본 변경 안 됨
   - 참조 타입: 참조 전달, 원본 변경 가능 (불변 타입 제외)
   - `ref`: 초기화 필수, 양방향 전달
   - `out`: 초기화 불필요, 메서드에서 반드시 할당

3. **메서드 오버로딩**
   - 같은 이름, 다른 매개변수로 여러 버전 정의
   - 매개변수의 개수, 타입, 순서로 구분
   - 반환 타입만 다른 것은 오버로딩 불가

4. **선택적 매개변수와 명명된 인수**
   - 선택적 매개변수: 기본값을 가지는 매개변수
   - 명명된 인수: 매개변수 이름으로 값 전달
   - 코드의 유연성과 가독성 향상

5. **로컬 함수**
   - 메서드 내부에 정의되는 지역 함수
   - 외부 변수 접근 가능
   - 헬퍼 함수, 캡슐화에 유용

### 실습 문제

#### 문제 1: 기본 계산 메서드

네 가지 사칙연산을 수행하는 메서드를 작성하세요.

```csharp
int Add(int a, int b)
{
    return a + b;
}

int Subtract(int a, int b)
{
    return a - b;
}

int Multiply(int a, int b)
{
    return a * b;
}

double Divide(int a, int b)
{
    if (b == 0)
    {
        Console.WriteLine("0으로 나눌 수 없습니다.");
        return 0;
    }
    return (double)a / b;
}

// 테스트
Console.WriteLine($"10 + 5 = {Add(10, 5)}");
Console.WriteLine($"10 - 5 = {Subtract(10, 5)}");
Console.WriteLine($"10 × 5 = {Multiply(10, 5)}");
Console.WriteLine($"10 ÷ 5 = {Divide(10, 5)}");
```

#### 문제 2: 배열 처리 메서드

배열의 합계와 평균을 계산하는 메서드를 작성하세요.

```csharp
void PrintArrayStatistics(int[] numbers)
{
    // 합계를 계산하는 로컬 함수
    int GetSum()
    {
        int sum = 0;
        foreach (int num in numbers)
        {
            sum += num;
        }
        return sum;
    }
    
    // 평균을 계산하는 로컬 함수
    double GetAverage()
    {
        return (double)GetSum() / numbers.Length;
    }
    
    Console.WriteLine($"합계: {GetSum()}");
    Console.WriteLine($"평균: {GetAverage():F2}");
}

// 테스트
int[] scores = { 85, 90, 78, 92, 88 };
PrintArrayStatistics(scores);

// 출력:
// 합계: 433
// 평균: 86.60
```

#### 문제 3: 오버로딩을 사용한 출력 메서드

다양한 형태로 메시지를 출력하는 오버로드된 메서드를 작성하세요.

```csharp
void PrintMessage(string message)
{
    Console.WriteLine(message);
}

void PrintMessage(string message, int count)
{
    for (int i = 0; i < count; i++)
    {
        Console.WriteLine($"{i + 1}. {message}");
    }
}

void PrintMessage(string message, char border)
{
    string line = new string(border, message.Length + 4);
    Console.WriteLine(line);
    Console.WriteLine($"{border} {message} {border}");
    Console.WriteLine(line);
}

// 테스트
PrintMessage("안녕하세요");
Console.WriteLine();

PrintMessage("C# 학습", 3);
Console.WriteLine();

PrintMessage("중요 공지", '*');

// 출력:
// 안녕하세요
// 
// 1. C# 학습
// 2. C# 학습
// 3. C# 학습
// 
// **********
// * 중요 공지 *
// **********
```

#### 문제 4: ref/out 키워드 활용

두 변수의 값을 교환하는 메서드와 최대/최소값을 찾는 메서드를 작성하세요.

```csharp
void Swap(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

void FindMinMax(int[] numbers, out int min, out int max)
{
    min = numbers[0];
    max = numbers[0];
    
    foreach (int num in numbers)
    {
        if (num < min) min = num;
        if (num > max) max = num;
    }
}

// 테스트
int x = 10, y = 20;
Console.WriteLine($"교환 전: x={x}, y={y}");
Swap(ref x, ref y);
Console.WriteLine($"교환 후: x={x}, y={y}");

Console.WriteLine();

int[] values = { 15, 3, 27, 8, 42, 19 };
FindMinMax(values, out int minimum, out int maximum);
Console.WriteLine($"최솟값: {minimum}");
Console.WriteLine($"최댓값: {maximum}");

// 출력:
// 교환 전: x=10, y=20
// 교환 후: x=20, y=10
// 
// 최솟값: 3
// 최댓값: 42
```

### 다음 장 예고

8장 "고급 메서드 활용"에서는 메서드를 더욱 강력하게 활용하는 방법을 학습합니다:
- 람다 식 (Lambda Expressions)
- Func와 Action 델리게이트
- 확장 메서드 (Extension Methods)
- 재귀 함수 (Recursive Functions)

이를 통해 함수형 프로그래밍의 개념을 이해하고, 더욱 표현력 있는 코드를 작성할 수 있게 됩니다!
