# 7장. 메서드 기초

프로그래밍에서 메서드(Method)는 특정 작업을 수행하는 코드의 묶음으로, 현대 소프트웨어 공학의 핵심 개념 중 하나인 **모듈화(Modularity)**와 **추상화(Abstraction)**를 구현하는 가장 기본적인 단위입니다. 메서드를 사용하면 코드를 재사용할 수 있고, 프로그램의 구조를 논리적으로 구성할 수 있으며, 복잡한 문제를 작은 단위로 나누어 해결할 수 있습니다. 지금까지 우리는 `Console.WriteLine()`, `Console.ReadLine()`과 같은 .NET Framework에서 미리 정의된 메서드들을 사용해왔습니다. 이제는 직접 메서드를 정의하고 활용하는 방법을 배울 차례입니다.

**메서드의 역사적 배경과 진화:**

메서드(또는 함수, 서브루틴)의 개념은 1940년대 후반 컴퓨터 과학의 초기 단계부터 존재했습니다. 1949년 존 마우클리(John Mauchly)가 Short Code에서 서브루틴 개념을 처음 도입했으며, 1951년 데이비드 휠러(David Wheeler)가 EDSAC 컴퓨터를 위해 서브루틴 라이브러리를 개발하면서 재사용 가능한 코드 블록의 중요성이 입증되었습니다.

C#에서 메서드라는 용어를 사용하는 것은 객체지향 프로그래밍(OOP)의 맥락에서 비롯됩니다. 전통적인 절차적 프로그래밍 언어(C, Pascal 등)에서는 "함수(Function)"와 "프로시저(Procedure)"로 구분했지만, 객체지향 언어에서는 클래스나 구조체에 속한 함수를 "메서드"라고 부릅니다. 이는 Smalltalk에서 유래한 용어로, 객체에 메시지를 보내면 해당 메서드가 실행된다는 메시지 전달 패러다임을 반영합니다.

**수학적 기초와 프로그래밍의 함수:**

메서드의 개념은 수학의 함수(Function)와 매우 유사하면서도 중요한 차이점이 있습니다. 수학에서 f(x) = x + 1이라는 함수는 입력값 x를 받아 x에 1을 더한 결과를 반환하는 **순수 함수(Pure Function)**입니다. 순수 함수는 같은 입력에 대해 항상 같은 출력을 생성하며, 외부 상태를 변경하지 않는 **참조 투명성(Referential Transparency)**을 가집니다.

반면 프로그래밍의 메서드는 더 넓은 개념으로, 순수 함수뿐만 아니라 **부작용(Side Effects)**을 가질 수 있습니다. 콘솔에 출력하거나, 파일을 수정하거나, 데이터베이스를 업데이트하는 등의 동작은 모두 부작용에 해당합니다. C#의 메서드는 입력(매개변수)을 받아 특정 작업을 수행하고, 필요에 따라 결과(반환값)를 돌려주며, 동시에 프로그램의 상태를 변경할 수 있는 강력한 추상화 메커니즘입니다.

이러한 구조는 **관심사의 분리(Separation of Concerns)**라는 소프트웨어 공학 원칙을 구현하여, 코드의 중복을 줄이고 각 기능을 독립적으로 테스트하고 관리할 수 있게 해줍니다. 1972년 데이비드 파르나스(David Parnas)가 제안한 정보 은닉(Information Hiding) 원칙과도 직접적으로 연결되며, 현대적인 소프트웨어 아키텍처의 토대를 이룹니다.

## 이 장에서 배울 내용

이 장을 통해 독자 여러분은 C#에서 메서드를 정의하고 활용하는 다양한 방법을 학습하게 됩니다:

- **메서드 정의와 호출**: 메서드의 기본 구조를 이해하고, 메서드를 정의하여 호출하는 방법을 익힙니다.

- **매개변수와 반환값**: 메서드에 데이터를 전달하고 결과를 받는 방법을 배우며, 값 타입과 참조 타입의 차이, `ref`와 `out` 키워드의 활용을 이해합니다.

- **메서드 오버로딩**: 같은 이름의 메서드를 매개변수를 다르게 하여 여러 버전으로 정의하는 방법을 학습합니다.

- **선택적 매개변수와 명명된 인수**: 유연한 메서드 호출을 가능하게 하는 현대적인 C# 기능을 익힙니다.

- **로컬 함수**: 메서드 내부에 정의되는 지역 함수의 개념과 활용 방법을 배웁니다.

---

## 7.1 메서드 정의와 호출

메서드는 특정 작업을 수행하는 코드 블록으로, 필요할 때마다 이름을 통해 호출(invocation)할 수 있습니다. 메서드를 사용하면 같은 코드를 반복해서 작성하지 않아도 되므로, 코드의 재사용성과 유지보수성이 크게 향상됩니다. 이는 소프트웨어 공학의 핵심 원칙인 **DRY(Don't Repeat Yourself)** 원칙을 실천하는 가장 기본적인 방법입니다.

**메서드 시그니처(Method Signature)의 이해:**

메서드의 기본 구조를 이해하기 전에, 먼저 메서드 시그니처라는 중요한 개념을 알아야 합니다. 메서드 시그니처는 메서드를 고유하게 식별하는 정보로, 메서드 이름과 매개변수의 타입 및 순서로 구성됩니다(반환 타입은 시그니처에 포함되지 않습니다). 이는 나중에 배울 메서드 오버로딩(Method Overloading)의 기초가 되는 개념으로, 컴파일러가 어떤 메서드를 호출해야 할지 결정하는 근거가 됩니다.

**메서드의 기본 구조(Anatomy of a Method):**

```csharp
[접근제한자] 반환타입 메서드이름(매개변수목록)
{
    // 메서드 본문(Method Body)
    // 메서드가 수행할 코드
    return 반환값;  // 반환타입이 void가 아닌 경우
}
```

각 구성 요소를 자세히 살펴보겠습니다:

1. **접근 제한자(Access Modifier)**: `public`, `private`, `protected`, `internal` 등으로 메서드의 가시성을 제어합니다. File-based App에서는 생략 가능하며, 기본값으로 처리됩니다.

2. **반환 타입(Return Type)**: 메서드가 반환하는 값의 데이터 타입입니다. 반환값이 없으면 `void`를 사용합니다. 이는 Pascal의 프로시저 개념을 반영한 것으로, 부작용만 수행하고 값을 반환하지 않는 메서드를 명시적으로 나타냅니다.

3. **메서드 이름**: 메서드를 식별하고 호출하는 데 사용됩니다. C#의 명명 규칙에 따라 PascalCase를 사용합니다.

4. **매개변수 목록(Parameter List)**: 메서드가 받을 입력값을 정의합니다. 괄호 안에 쉼표로 구분하여 나열하며, 매개변수가 없으면 빈 괄호 `()`를 사용합니다.

5. **메서드 본문**: 중괄호 `{}` 안에 실제 실행될 코드를 작성합니다. 이는 **코드 블록(Code Block)** 또는 **복합문(Compound Statement)**이라고도 합니다.

**가장 간단한 메서드:**

```csharp
// 반환값이 없고 매개변수도 없는 메서드
void SayHello()
{
    Console.WriteLine("안녕하세요!");
}

// 메서드 호출
SayHello();
SayHello();

// 출력:
// 안녕하세요!
// 안녕하세요!
```

**반환값이 있는 메서드:**

```csharp
// 정수를 반환하는 메서드
int GetNumber()
{
    return 42;
}

// 메서드 호출 및 반환값 사용
int result = GetNumber();
Console.WriteLine($"결과: {result}");

// 출력:
// 결과: 42
```

**실용 예제 - 인사 메서드:**

```csharp
void Greet()
{
    Console.WriteLine("환영합니다!");
    Console.WriteLine("C# 프로그래밍을 시작합니다.");
}

// 프로그램 시작
Console.WriteLine("프로그램 시작");
Greet();
Console.WriteLine("프로그램 종료");

// 출력:
// 프로그램 시작
// 환영합니다!
// C# 프로그래밍을 시작합니다.
// 프로그램 종료
```

**메서드를 사용하는 이유와 소프트웨어 공학 원칙:**

1. **코드 재사용(Code Reuse)**: 같은 코드를 여러 번 작성하지 않고 메서드 호출로 대체합니다. 이는 1968년 더글라스 맥일로이(Douglas McIlroy)가 제안한 **컴포넌트 기반 개발(Component-Based Development)**의 기초가 됩니다.

2. **가독성 향상(Improved Readability)**: 복잡한 코드를 의미 있는 이름의 메서드로 분리하면, 코드가 **자기 문서화(Self-Documenting)**됩니다. 로버트 마틴(Robert C. Martin)의 "Clean Code"에서 강조하는 "코드는 산문처럼 읽혀야 한다"는 원칙을 실천하는 방법입니다.

3. **유지보수 용이성(Maintainability)**: 기능 수정 시 메서드 하나만 수정하면 모든 호출 지점에 자동으로 반영됩니다. 이는 **단일 책임 원칙(Single Responsibility Principle, SRP)**과 직접적으로 연결되며, SOLID 원칙의 첫 번째 원칙입니다.

4. **테스트 편의성(Testability)**: 각 메서드를 독립적으로 테스트할 수 있어, **단위 테스트(Unit Testing)**의 기본 단위가 됩니다. 켄트 벡(Kent Beck)의 테스트 주도 개발(TDD) 방법론에서 핵심적인 역할을 합니다.

5. **추상화(Abstraction)**: 복잡한 구현 세부사항을 숨기고 인터페이스만 노출하여, 사용자가 "어떻게(How)"보다 "무엇을(What)"에 집중할 수 있게 합니다.

6. **디버깅 효율성**: 문제가 발생했을 때 특정 메서드로 범위를 좁혀 원인을 찾을 수 있어, 디버깅 시간이 단축됩니다.

**메서드 명명 규칙과 컨벤션:**

C#에서 메서드 이름은 **PascalCase**(파스칼 표기법)를 사용합니다. 이는 1970년대 닉러스 비르트(Niklaus Wirth)가 개발한 Pascal 언어에서 유래한 명명 방식으로, 각 단어의 첫 글자를 대문자로 작성합니다. Microsoft의 C# 코딩 규칙(Framework Design Guidelines)에서 공식적으로 권장하는 방식입니다.

```csharp
// ✅ 좋은 예 - 동사로 시작하는 명확한 이름
void CalculateTotal()        // 총계 계산
void SendEmail()             // 이메일 전송
void ValidateUserInput()     // 사용자 입력 검증
bool IsValidEmail()          // 불린 반환은 Is, Has, Can 등으로 시작
int GetUserAge()             // Get으로 시작하는 조회 메서드

// ❌ 나쁜 예
void calculate_total()       // snake_case는 Python, Ruby 스타일
void sendemail()             // 단어 구분이 없어 읽기 어려움
void Validate_User_Input()   // 혼합 스타일 (SCREAMING_SNAKE_CASE는 상수용)
void DoStuff()               // 모호한 이름
void Process()               // 무엇을 처리하는지 불명확
```

**메서드 명명의 모범 사례:**

1. **동사로 시작**: 메서드는 동작을 나타내므로 동사(Calculate, Send, Validate, Get, Set)로 시작합니다.
2. **명확성**: 메서드가 하는 일을 정확히 나타내야 합니다. `DoWork()` 대신 `ProcessPayment()`처럼 구체적으로 작성합니다.
3. **일관성**: 프로젝트 전체에서 유사한 기능에 일관된 명명 패턴을 사용합니다.
4. **길이**: 너무 짧지도, 너무 길지도 않게. 일반적으로 2-4단어가 적절합니다.
5. **약어 피하기**: `PrcUsrInpt()` 대신 `ProcessUserInput()`처럼 전체 단어를 사용합니다.

---

## 7.2 매개변수와 반환값

메서드는 외부로부터 데이터를 입력받아 처리할 수 있습니다. 이때 입력받는 데이터를 **매개변수(Parameter)** 또는 **인수(Argument)**라고 하며, 처리 결과를 돌려주는 것을 **반환값(Return Value)**이라고 합니다. 이러한 메커니즘은 프로그래밍 언어 이론에서 **함수 적용(Function Application)**과 **값 전달(Value Passing)**의 개념을 구현한 것입니다.

**매개변수와 인수의 명확한 구분:**

프로그래밍에서 매개변수(Parameter)와 인수(Argument)는 종종 혼용되지만, 엄밀히 구분하면 다음과 같습니다:

- **매개변수(Parameter, Formal Parameter)**: 메서드 정의에서 선언하는 **형식 매개변수**입니다. 메서드의 시그니처를 구성하며, 메서드가 어떤 종류의 데이터를 받을지 명시합니다.
- **인수(Argument, Actual Parameter)**: 메서드를 호출할 때 전달하는 **실제 인수** 또는 **실제 매개변수**입니다. 매개변수에 바인딩되는 구체적인 값입니다.

이 구분은 1960년대 알골(ALGOL) 언어 설계 시 확립된 개념으로, 현대의 모든 프로그래밍 언어에서 유지되고 있습니다.

```csharp
// a, b는 매개변수(Parameter) - 메서드 정의 시
int Multiply(int a, int b)
{
    return a * b;
}

// 5, 3은 인수(Argument) - 메서드 호출 시
int result = Multiply(5, 3);
```

**값 전달 방식의 이론적 배경:**

프로그래밍 언어는 매개변수를 전달하는 다양한 방식을 제공하며, 각각은 서로 다른 의미론(semantics)을 가집니다:

1. **값에 의한 전달(Pass by Value)**: 매개변수의 복사본이 전달됩니다. C, Java의 기본 타입, C#의 값 타입이 이에 해당합니다.

2. **참조에 의한 전달(Pass by Reference)**: 매개변수의 메모리 주소가 전달됩니다. C++의 참조, C#의 `ref`/`out` 키워드가 이를 명시적으로 구현합니다.

3. **공유에 의한 전달(Pass by Sharing, Call by Sharing)**: 참조 타입 객체의 참조가 값으로 전달됩니다. Java의 객체, C#의 참조 타입이 이 방식을 사용하며, "값에 의한 참조 전달"이라고도 합니다.

C#은 이 세 가지 방식을 모두 지원하며, 타입 시스템과 키워드를 통해 명시적으로 제어할 수 있습니다. 이는 C#이 **안전성(Safety)**과 **성능(Performance)**, **표현력(Expressiveness)**의 균형을 추구하는 언어임을 보여줍니다.

**매개변수가 있는 메서드:**

```csharp
// 이름을 매개변수로 받는 메서드
void Greet(string name)
{
    Console.WriteLine($"안녕하세요, {name}님!");
}

// 메서드 호출 - 인수 전달
Greet("홍길동");
Greet("김철수");

// 출력:
// 안녕하세요, 홍길동님!
// 안녕하세요, 김철수님!
```

**여러 개의 매개변수:**

```csharp
// 두 개의 정수를 받아 더하는 메서드
int Add(int a, int b)
{
    return a + b;
}

// 메서드 호출
int result1 = Add(10, 20);
int result2 = Add(5, 15);

Console.WriteLine($"10 + 20 = {result1}");
Console.WriteLine($"5 + 15 = {result2}");

// 출력:
// 10 + 20 = 30
// 5 + 15 = 20
```

**매개변수와 인수의 차이:**

- **매개변수(Parameter)**: 메서드 정의에서 선언하는 변수
- **인수(Argument)**: 메서드를 호출할 때 전달하는 실제 값

```csharp
// a, b는 매개변수
int Multiply(int a, int b)
{
    return a * b;
}

// 5, 3은 인수
int result = Multiply(5, 3);
```

### 7.2.1 값 타입 매개변수

값 타입(Value Type) 매개변수는 데이터의 **완전한 복사본**이 메서드로 전달됩니다. 따라서 메서드 내부에서 매개변수를 변경해도 원본 값은 영향을 받지 않습니다. `int`, `double`, `bool`, `struct`, `enum` 등이 값 타입에 해당합니다. 이는 컴퓨터 과학에서 **값 의미론(Value Semantics)**이라고 부르는 개념을 구현한 것입니다.

**메모리 관점에서의 값 타입 전달:**

값 타입이 메서드에 전달될 때, 실제로 무슨 일이 일어나는지 메모리 관점에서 이해하는 것이 중요합니다. 값 타입 변수는 **스택(Stack) 메모리**에 저장되며, 메서드 호출 시 새로운 스택 프레임(Stack Frame)이 생성됩니다. 이 스택 프레임 내에 원본 데이터의 비트 단위 복사본이 만들어지므로, 원본과 복사본은 완전히 독립적인 메모리 공간을 차지합니다.

이러한 설계는 **데이터 안전성(Data Safety)**과 **캡슐화(Encapsulation)**를 보장하지만, 큰 구조체의 경우 복사 비용이 증가할 수 있습니다. 이것이 바로 C# 컴파일러가 큰 구조체에 대해 경고를 표시하는 이유이며, 이런 경우 `in` 키워드나 `ref readonly`를 사용하여 성능을 최적화할 수 있습니다.

**값 타입의 동작:**

```csharp
void ChangeNumber(int number)
{
    number = 100;  // 복사본을 변경 (스택의 다른 메모리 위치)
    Console.WriteLine($"메서드 내부: {number}");
}

int original = 10;
Console.WriteLine($"호출 전: {original}");
ChangeNumber(original);  // original의 복사본이 전달됨
Console.WriteLine($"호출 후: {original}");

// 출력:
// 호출 전: 10
// 메서드 내부: 100
// 호출 후: 10  (원본은 변경되지 않음)
```

**값 타입 매개변수의 특징과 의미:**

1. **복사본 전달(Copy Semantics)**: 원본 데이터의 비트 단위 복사본이 생성되어 전달됩니다. 이는 C++의 복사 생성자(Copy Constructor) 개념과 유사하지만, C#에서는 암묵적으로 처리됩니다.

2. **안전성(Safety)**: 메서드가 원본 데이터를 변경할 수 없어 **부작용(Side Effects)**으로부터 안전합니다. 이는 함수형 프로그래밍의 **불변성(Immutability)** 개념과 연결됩니다.

3. **메모리와 성능**: 작은 데이터(일반적으로 16바이트 이하)에 적합하며, 큰 구조체는 복사 비용으로 인해 성능에 영향을 줄 수 있습니다. .NET의 성능 가이드라인에서는 구조체가 16바이트를 초과하면 `readonly ref` 전달을 권장합니다.

4. **스택 할당**: 값 타입은 스택에 할당되므로 가비지 컬렉션(Garbage Collection)의 부담이 없고, 메서드가 반환되면 자동으로 메모리가 해제됩니다. 이는 **결정론적 메모리 관리(Deterministic Memory Management)**의 한 형태입니다.

**실용 예제 - 기하학 계산 메서드:**

```csharp
double CalculateCircleArea(double radius)
{
    const double PI = 3.14159;
    return PI * radius * radius;
}

double r = 5.0;
double area = CalculateCircleArea(r);
Console.WriteLine($"반지름 {r}인 원의 넓이: {area:F2}");

// 출력:
// 반지름 5인 원의 넓이: 78.54
```

**구조체 매개변수의 주의사항:**

```csharp
struct Point
{
    public int X;
    public int Y;
}

void MovePoint(Point p)
{
    p.X += 10;  // 복사본을 수정
    p.Y += 10;
}

Point original = new Point { X = 5, Y = 5 };
Console.WriteLine($"이동 전: ({original.X}, {original.Y})");
MovePoint(original);  // 구조체 전체가 복사됨
Console.WriteLine($"이동 후: ({original.X}, {original.Y})");  // 변경 안 됨

// 출력:
// 이동 전: (5, 5)
// 이동 후: (5, 5)  // 원본은 그대로
```

### 7.2.2 참조 타입 매개변수

참조 타입(Reference Type) 매개변수는 데이터가 저장된 메모리 위치의 **참조(Reference)**가 전달됩니다. 더 정확히 말하면, 참조 자체가 값으로 복사되어 전달되는 것입니다(이를 "참조의 값 복사" 또는 "공유에 의한 전달"이라고 합니다). 따라서 메서드 내부에서 객체의 **내용**을 변경하면 원본에도 영향을 미칩니다. `string`, `array`, `class`, `interface`, `delegate` 등이 참조 타입에 해당합니다.

**참조 의미론(Reference Semantics)의 이해:**

참조 타입 변수는 실제 데이터가 아니라 **힙(Heap) 메모리**에 있는 객체를 가리키는 주소(또는 핸들)를 저장합니다. 메서드에 참조 타입을 전달하면, 이 주소 값이 복사되어 전달됩니다. 결과적으로 원본 변수와 매개변수 모두 같은 객체를 가리키게 되므로, 한쪽에서 객체를 수정하면 다른 쪽에서도 변경사항이 보입니다.

이는 C 언어의 포인터와 유사하지만, C#은 **관리되는 참조(Managed Reference)**를 사용하여 포인터 산술 연산이나 잘못된 메모리 접근을 원천적으로 차단합니다. 이를 통해 메모리 안정성을 확보하면서도 효율적인 데이터 공유가 가능합니다.

**중요한 개념적 차이:**

- **값 타입**: 변수 자체가 데이터를 직접 포함합니다 (스택에 인라인 저장).
- **참조 타입**: 변수는 데이터를 가리키는 참조를 포함합니다 (힙의 객체를 가리킴).

**참조 타입의 동작 - 배열:**

```csharp
void ModifyArray(int[] numbers)
{
    numbers[0] = 999;  // 원본 배열의 내용을 변경
    // numbers 매개변수와 myArray 변수 모두 같은 배열 객체를 가리킴
}

int[] myArray = { 1, 2, 3 };
Console.WriteLine($"변경 전: {myArray[0]}");
ModifyArray(myArray);  // 배열의 참조(주소)가 복사되어 전달됨
Console.WriteLine($"변경 후: {myArray[0]}");

// 출력:
// 변경 전: 1
// 변경 후: 999  (원본이 변경됨)
```

**메모리 다이어그램으로 이해하기:**

```
[호출 전]
myArray(스택) ---> [1, 2, 3] (힙)

[메서드 호출 시]
myArray(스택) ---> [1, 2, 3] (힙)
                    ^
numbers(스택) ------+ (같은 객체를 가리킴)

[numbers[0] = 999 실행 후]
myArray(스택) ---> [999, 2, 3] (힙)
                    ^
numbers(스택) ------+
```

**참조 타입의 특수성 - 문자열의 불변성:**

문자열(`string`)은 참조 타입이지만 **불변(Immutable)** 객체입니다. 이는 .NET의 독특한 설계 결정으로, 1995년 Java가 도입한 개념을 C#도 채택했습니다. 따라서 메서드 내에서 문자열을 "변경"하면 실제로는 새로운 문자열 객체가 생성되며, 매개변수는 이 새 객체를 가리키게 되지만 원본 변수는 여전히 기존 객체를 가리킵니다.

**문자열 불변성의 이유:**

1. **스레드 안정성(Thread Safety)**: 여러 스레드가 동시에 같은 문자열을 읽어도 안전합니다.
2. **보안(Security)**: 문자열을 키로 사용할 때 예측 가능성이 보장됩니다.
3. **최적화(Optimization)**: 문자열 인터닝(String Interning)을 통해 메모리를 절약할 수 있습니다.
4. **해시 코드 안정성**: Dictionary 등의 키로 사용할 때 해시 값이 변하지 않습니다.

```csharp
void ChangeString(string text)
{
    text = "변경된 문자열";  // 새로운 문자열 객체 생성
    // text는 이제 새 객체를 가리키지만, 호출자의 original은 여전히 기존 객체를 가리킴
    Console.WriteLine($"메서드 내부: {text}");
}

string original = "원본 문자열";
Console.WriteLine($"호출 전: {original}");
ChangeString(original);  // original의 참조가 복사되어 전달됨
Console.WriteLine($"호출 후: {original}");

// 출력:
// 호출 전: 원본 문자열
// 메서드 내부: 변경된 문자열
// 호출 후: 원본 문자열  (원본은 변경되지 않음!)
```

**참조 타입 매개변수의 특징:**

1. **효율적인 전달**: 큰 객체도 참조(일반적으로 4~8바이트)만 복사되므로 효율적입니다. 1MB 크기의 배열을 전달해도 8바이트의 참조만 복사됩니다.

2. **공유 가능성**: 같은 객체를 여러 메서드가 공유할 수 있어, 대용량 데이터 구조를 다룰 때 유리합니다.

3. **원본 수정 가능**: 객체의 내용(멤버, 요소 등)을 변경하면 원본에 반영됩니다. 이는 **참조 투명성(Referential Transparency)**을 깨뜨리므로 주의가 필요합니다.

4. **null 가능성**: 참조 타입은 `null` 값을 가질 수 있으므로, 메서드 내에서 null 체크가 필요할 수 있습니다(C# 8.0 이후 Nullable Reference Types로 개선).

5. **가비지 컬렉션**: 힙에 할당되므로 자동 가비지 컬렉션의 대상이 됩니다.

**실용 예제 - 배열 처리:**

```csharp
void FillArray(int[] array, int value)
{
    for (int i = 0; i < array.Length; i++)
    {
        array[i] = value;  // 원본 배열의 요소를 변경
    }
}

int[] numbers = new int[5];
FillArray(numbers, 7);

Console.Write("배열 내용: ");
foreach (int num in numbers)
{
    Console.Write($"{num} ");
}

// 출력:
// 배열 내용: 7 7 7 7 7
```

**참조 재할당과 내용 변경의 차이:**

```csharp
void ModifyReference(int[] arr)
{
    arr[0] = 100;           // ✅ 내용 변경 - 원본에 영향
    arr = new int[] { 1 };  // ❌ 참조 재할당 - 원본에 영향 없음
                            // arr은 이제 새 배열을 가리키지만, 호출자의 변수는 여전히 원래 배열을 가리킴
}

int[] original = { 1, 2, 3 };
ModifyReference(original);
Console.WriteLine(original[0]);  // 100 출력 (첫 번째 변경은 유효)
Console.WriteLine(original.Length);  // 3 출력 (두 번째 변경은 무효)
```

### 7.2.3 ref와 out 키워드

C#은 매개변수 전달 방식을 명시적으로 제어할 수 있는 `ref`와 `out` 키워드를 제공합니다. 이들은 값 타입을 참조로 전달하거나, 메서드에서 여러 값을 반환해야 할 때 유용합니다.

**ref 키워드:**

`ref` 키워드는 변수를 참조로 전달합니다. 메서드 내에서 변경한 내용이 원본에 반영됩니다. `ref`를 사용하려면 변수가 **반드시 초기화**되어 있어야 합니다.

```csharp
void Increment(ref int number)
{
    number++;
}

int count = 10;
Console.WriteLine($"호출 전: {count}");
Increment(ref count);  // ref 키워드를 호출 시에도 명시
Console.WriteLine($"호출 후: {count}");

// 출력:
// 호출 전: 10
// 호출 후: 11  (원본이 변경됨)
```

**ref의 특징:**

- 매개변수는 메서드 호출 전에 초기화되어야 함
- 메서드 정의와 호출 시 모두 `ref` 키워드 필요
- 메서드 내에서 값을 읽고 쓰기 모두 가능

**out 키워드:**

`out` 키워드도 참조로 전달하지만, 메서드 내에서 **반드시 값을 할당**해야 합니다. 메서드가 여러 값을 반환해야 할 때 유용합니다.

```csharp
void Divide(int dividend, int divisor, out int quotient, out int remainder)
{
    quotient = dividend / divisor;
    remainder = dividend % divisor;
}

int a = 17;
int b = 5;
Divide(a, b, out int q, out int r);  // out 변수는 호출 시 선언 가능

Console.WriteLine($"{a} ÷ {b} = {q} 나머지 {r}");

// 출력:
// 17 ÷ 5 = 3 나머지 2
```

**out의 특징:**

- 매개변수는 메서드 호출 전에 초기화되지 않아도 됨
- 메서드 내에서 반드시 값을 할당해야 함
- 메서드 정의와 호출 시 모두 `out` 키워드 필요
- C# 7.0부터 호출 시 변수 선언 가능 (`out int result`)

**ref와 out 비교:**

```csharp
// ref - 초기화 필수, 읽기/쓰기 가능
void UseRef(ref int value)
{
    Console.WriteLine($"받은 값: {value}");  // 읽기 가능
    value = value * 2;  // 쓰기 가능
}

int x = 5;
UseRef(ref x);

// out - 초기화 불필요, 반드시 할당해야 함
void UseOut(out int value)
{
    // Console.WriteLine(value);  // ❌ 할당 전에는 읽을 수 없음
    value = 10;  // 반드시 할당
}

UseOut(out int y);  // 초기화하지 않아도 됨
```

**실용 예제 - 문자열 파싱:**

```csharp
void TryParseNumber(string input, out bool success, out int result)
{
    success = int.TryParse(input, out result);
}

string userInput = "123";
TryParseNumber(userInput, out bool isValid, out int number);

if (isValid)
{
    Console.WriteLine($"변환 성공: {number}");
}
else
{
    Console.WriteLine("변환 실패");
}

// 출력:
// 변환 성공: 123
```

---

## 7.3 메서드 오버로딩

메서드 오버로딩(Method Overloading)은 같은 이름의 메서드를 매개변수의 개수나 타입을 다르게 하여 여러 버전으로 정의하는 것입니다. 이를 통해 비슷한 기능을 하는 메서드들을 하나의 이름으로 통일할 수 있어 코드의 일관성과 가독성이 향상됩니다.

**기본 개념:**

```csharp
// 매개변수 개수가 다른 오버로딩
void Print(string message)
{
    Console.WriteLine(message);
}

void Print(string message, int count)
{
    for (int i = 0; i < count; i++)
    {
        Console.WriteLine(message);
    }
}

// 사용
Print("안녕하세요");           // 첫 번째 메서드 호출
Print("반갑습니다", 3);        // 두 번째 메서드 호출

// 출력:
// 안녕하세요
// 반갑습니다
// 반갑습니다
// 반갑습니다
```

**매개변수 타입이 다른 오버로딩:**

```csharp
int Add(int a, int b)
{
    return a + b;
}

double Add(double a, double b)
{
    return a + b;
}

string Add(string a, string b)
{
    return a + b;
}

// 사용
Console.WriteLine(Add(5, 3));           // 8 (int 버전)
Console.WriteLine(Add(2.5, 3.7));       // 6.2 (double 버전)
Console.WriteLine(Add("Hello, ", "World!"));  // Hello, World! (string 버전)
```

**오버로딩 규칙:**

1. **메서드 시그니처**: 메서드 이름, 매개변수의 개수, 매개변수의 타입, 매개변수의 순서로 구분
2. **반환 타입 불가**: 반환 타입만 다르게 해서는 오버로딩할 수 없음
3. **매개변수 이름 불가**: 매개변수 이름만 다르게 해서는 오버로딩할 수 없음

```csharp
// ✅ 올바른 오버로딩 - 매개변수 타입이 다름
int Calculate(int a, int b)
{
    return a + b;
}

double Calculate(double a, double b)
{
    return a + b;
}

// ❌ 잘못된 오버로딩 - 반환 타입만 다름 (컴파일 오류)
// int Process(int x)
// {
//     return x * 2;
// }
// 
// double Process(int x)  // ❌ 에러: 반환 타입만 다름
// {
//     return x * 2.0;
// }

// ❌ 잘못된 오버로딩 - 매개변수 이름만 다름 (컴파일 오류)
// void Method(int a)
// {
// }
// 
// void Method(int b)  // ❌ 에러: 매개변수 이름만 다름
// {
// }
```

**실용 예제 - 다양한 형태의 로그 출력:**

```csharp
void Log(string message)
{
    Console.WriteLine($"[INFO] {message}");
}

void Log(string message, string level)
{
    Console.WriteLine($"[{level}] {message}");
}

void Log(string message, string level, DateTime timestamp)
{
    Console.WriteLine($"[{timestamp:yyyy-MM-dd HH:mm:ss}] [{level}] {message}");
}

// 사용
Log("애플리케이션 시작");
Log("데이터베이스 연결 성공", "SUCCESS");
Log("파일 처리 완료", "INFO", DateTime.Now);

// 출력:
// [INFO] 애플리케이션 시작
// [SUCCESS] 데이터베이스 연결 성공
// [2024-01-15 14:30:25] [INFO] 파일 처리 완료
```

**C# 표준 라이브러리의 오버로딩 예:**

C#의 많은 내장 메서드들이 오버로딩을 사용합니다:

```csharp
// Console.WriteLine의 다양한 오버로드
Console.WriteLine();                    // 빈 줄 출력
Console.WriteLine("문자열");            // 문자열 출력
Console.WriteLine(123);                 // 정수 출력
Console.WriteLine(3.14);                // 실수 출력
Console.WriteLine(true);                // 불린 출력

// String.Substring의 오버로드
string text = "Hello, World!";
string part1 = text.Substring(7);       // "World!" (시작 인덱스만)
string part2 = text.Substring(0, 5);    // "Hello" (시작 인덱스와 길이)
```

---

## 7.4 선택적 매개변수와 명명된 인수

C# 4.0에서 도입된 선택적 매개변수(Optional Parameters)와 명명된 인수(Named Arguments)는 메서드 호출을 더욱 유연하고 가독성 있게 만들어주는 기능입니다.

### 선택적 매개변수 (Optional Parameters)

선택적 매개변수는 기본값을 가지는 매개변수로, 호출 시 값을 생략할 수 있습니다.

```csharp
void Greet(string name, string greeting = "안녕하세요")
{
    Console.WriteLine($"{greeting}, {name}님!");
}

// 다양한 호출 방법
Greet("홍길동");                    // 기본 인사말 사용
Greet("김철수", "반갑습니다");      // 사용자 정의 인사말

// 출력:
// 안녕하세요, 홍길동님!
// 반갑습니다, 김철수님!
```

**여러 개의 선택적 매개변수:**

```csharp
void CreateUser(string name, int age = 0, string city = "서울", bool isActive = true)
{
    Console.WriteLine($"이름: {name}");
    Console.WriteLine($"나이: {age}");
    Console.WriteLine($"도시: {city}");
    Console.WriteLine($"활성: {isActive}");
}

// 다양한 호출
CreateUser("이영희");
CreateUser("박민수", 30);
CreateUser("최지훈", 25, "부산");

// 출력:
// 이름: 이영희
// 나이: 0
// 도시: 서울
// 활성: True
// 
// 이름: 박민수
// 나이: 30
// 도시: 서울
// 활성: True
// 
// 이름: 최지훈
// 나이: 25
// 도시: 부산
// 활성: True
```

**선택적 매개변수 규칙:**

1. 선택적 매개변수는 필수 매개변수 뒤에 위치해야 함
2. 기본값은 컴파일 타임 상수여야 함
3. `ref`, `out` 매개변수는 선택적으로 만들 수 없음

```csharp
// ✅ 올바른 순서
void Method1(int required, string optional = "default")
{
}

// ❌ 잘못된 순서
// void Method2(string optional = "default", int required)  // 컴파일 오류
// {
// }
```

### 명명된 인수 (Named Arguments)

명명된 인수는 매개변수 이름을 명시하여 값을 전달하는 방식입니다. 순서에 관계없이 인수를 전달할 수 있으며, 코드의 가독성이 향상됩니다.

```csharp
void SetupConnection(string server, int port, string username, string password)
{
    Console.WriteLine($"서버: {server}:{port}");
    Console.WriteLine($"사용자: {username}");
}

// 명명된 인수 사용
SetupConnection(
    server: "localhost",
    port: 8080,
    username: "admin",
    password: "1234"
);

// 순서를 바꿔도 됨
SetupConnection(
    username: "admin",
    password: "1234",
    server: "localhost",
    port: 8080
);
```

**선택적 매개변수와 명명된 인수의 결합:**

```csharp
void SendEmail(string to, string subject, string body = "", bool isHtml = false, int priority = 1)
{
    Console.WriteLine($"받는사람: {to}");
    Console.WriteLine($"제목: {subject}");
    Console.WriteLine($"내용: {body}");
    Console.WriteLine($"HTML: {isHtml}");
    Console.WriteLine($"우선순위: {priority}");
}

// 중간 매개변수만 지정하기
SendEmail(
    to: "user@example.com",
    subject: "안내",
    isHtml: true,      // body는 기본값, isHtml만 지정
    priority: 5
);

// 출력:
// 받는사람: user@example.com
// 제목: 안내
// 내용: 
// HTML: True
// 우선순위: 5
```

**실용 예제 - 로그 메서드:**

```csharp
void WriteLog(
    string message,
    string level = "INFO",
    bool includeTimestamp = true,
    bool includeLineBreak = true)
{
    if (includeTimestamp)
    {
        Console.Write($"[{DateTime.Now:HH:mm:ss}] ");
    }
    
    Console.Write($"[{level}] {message}");
    
    if (includeLineBreak)
    {
        Console.WriteLine();
    }
}

// 다양한 사용
WriteLog("애플리케이션 시작");
WriteLog("경고 메시지", level: "WARNING");
WriteLog("에러 발생", level: "ERROR", includeTimestamp: false);

// 출력:
// [14:30:15] [INFO] 애플리케이션 시작
// [14:30:15] [WARNING] 경고 메시지
// [ERROR] 에러 발생
```

**명명된 인수의 장점:**

1. **가독성**: 매개변수의 의미가 명확해짐
2. **유연성**: 순서에 관계없이 인수 전달 가능
3. **선택성**: 원하는 매개변수만 지정 가능

---

## 7.5 로컬 함수 (Local Functions)

로컬 함수는 C# 7.0에서 도입된 기능으로, 메서드 내부에 정의되는 지역 함수입니다. 특정 메서드에서만 사용되는 헬퍼 함수를 정의할 때 유용하며, 코드의 응집도를 높이고 외부에 노출되지 않아야 하는 로직을 캡슐화할 수 있습니다.

**기본 구조:**

```csharp
void OuterMethod()
{
    Console.WriteLine("외부 메서드 시작");
    
    // 로컬 함수 정의
    void InnerFunction()
    {
        Console.WriteLine("로컬 함수 실행");
    }
    
    // 로컬 함수 호출
    InnerFunction();
    InnerFunction();
    
    Console.WriteLine("외부 메서드 종료");
}

OuterMethod();

// 출력:
// 외부 메서드 시작
// 로컬 함수 실행
// 로컬 함수 실행
// 외부 메서드 종료
```

**로컬 함수의 특징:**

1. **범위**: 정의된 메서드 내부에서만 호출 가능
2. **접근**: 외부 메서드의 지역 변수와 매개변수에 접근 가능
3. **재귀**: 로컬 함수도 재귀 호출이 가능

**외부 변수 접근:**

```csharp
void ProcessData(int[] numbers)
{
    int sum = 0;
    
    // 로컬 함수는 외부 변수에 접근 가능
    void AddToSum(int value)
    {
        sum += value;  // 외부 변수 sum에 접근
    }
    
    foreach (int num in numbers)
    {
        AddToSum(num);
    }
    
    Console.WriteLine($"합계: {sum}");
}

ProcessData(new int[] { 1, 2, 3, 4, 5 });

// 출력:
// 합계: 15
```

**반환값이 있는 로컬 함수:**

```csharp
void CalculateStatistics(int[] numbers)
{
    // 평균을 계산하는 로컬 함수
    double GetAverage()
    {
        double sum = 0;
        foreach (int num in numbers)
        {
            sum += num;
        }
        return sum / numbers.Length;
    }
    
    // 최댓값을 찾는 로컬 함수
    int GetMax()
    {
        int max = numbers[0];
        foreach (int num in numbers)
        {
            if (num > max)
            {
                max = num;
            }
        }
        return max;
    }
    
    Console.WriteLine($"평균: {GetAverage():F2}");
    Console.WriteLine($"최댓값: {GetMax()}");
}

CalculateStatistics(new int[] { 5, 12, 8, 20, 3 });

// 출력:
// 평균: 9.60
// 최댓값: 20
```

**재귀 로컬 함수:**

```csharp
void PrintFactorial(int n)
{
    // 팩토리얼을 계산하는 재귀 로컬 함수
    long Factorial(int number)
    {
        if (number <= 1)
        {
            return 1;
        }
        return number * Factorial(number - 1);
    }
    
    Console.WriteLine($"{n}! = {Factorial(n)}");
}

PrintFactorial(5);
PrintFactorial(7);

// 출력:
// 5! = 120
// 7! = 5040
```

**로컬 함수 vs 람다식:**

로컬 함수는 람다식과 비슷해 보일 수 있지만 몇 가지 중요한 차이가 있습니다:

```csharp
void CompareLocalFunctionAndLambda()
{
    // 로컬 함수
    int LocalAdd(int a, int b)
    {
        return a + b;
    }
    
    // 람다식
    Func<int, int, int> lambdaAdd = (a, b) => a + b;
    
    Console.WriteLine($"로컬 함수: {LocalAdd(5, 3)}");
    Console.WriteLine($"람다식: {lambdaAdd(5, 3)}");
}
```

**로컬 함수의 장점:**

| 특성 | 로컬 함수 | 람다식 |
|------|----------|--------|
| 재귀 | 쉽게 가능 | 복잡함 |
| 성능 | 약간 더 효율적 | 델리게이트 생성 |
| 제네릭 | 지원 | 제한적 |
| 가독성 | 명확한 메서드 형태 | 간결한 표현 |

**실용 예제 - 유효성 검증:**

```csharp
bool ValidateUser(string username, string email, int age)
{
    // 사용자명 검증 로컬 함수
    bool IsValidUsername()
    {
        return !string.IsNullOrWhiteSpace(username) && username.Length >= 3;
    }
    
    // 이메일 검증 로컬 함수
    bool IsValidEmail()
    {
        return !string.IsNullOrWhiteSpace(email) && email.Contains("@");
    }
    
    // 나이 검증 로컬 함수
    bool IsValidAge()
    {
        return age >= 0 && age <= 150;
    }
    
    // 모든 검증 수행
    if (!IsValidUsername())
    {
        Console.WriteLine("사용자명이 유효하지 않습니다.");
        return false;
    }
    
    if (!IsValidEmail())
    {
        Console.WriteLine("이메일이 유효하지 않습니다.");
        return false;
    }
    
    if (!IsValidAge())
    {
        Console.WriteLine("나이가 유효하지 않습니다.");
        return false;
    }
    
    Console.WriteLine("모든 검증 통과!");
    return true;
}

// 테스트
ValidateUser("홍길동", "hong@example.com", 25);
ValidateUser("김", "invalid-email", 30);

// 출력:
// 모든 검증 통과!
// 사용자명이 유효하지 않습니다.
```

**언제 로컬 함수를 사용할까:**

1. **헬퍼 함수**: 특정 메서드에서만 사용되는 보조 함수
2. **반복 제거**: 같은 로직이 메서드 내에서 여러 번 반복될 때
3. **가독성**: 복잡한 메서드를 논리적 단위로 분리할 때
4. **캡슐화**: 외부에 노출할 필요 없는 로직을 숨길 때

---

## 7장 정리 및 요약

이 장에서는 C#에서 메서드를 정의하고 활용하는 다양한 방법을 학습했습니다.

### 핵심 개념 정리

1. **메서드 정의와 호출**
   - 메서드는 특정 작업을 수행하는 코드의 묶음
   - 코드 재사용성과 유지보수성 향상
   - 반환 타입, 메서드 이름, 매개변수로 구성

2. **매개변수와 반환값**
   - 값 타입: 복사본 전달, 원본 변경 안 됨
   - 참조 타입: 참조 전달, 원본 변경 가능 (불변 타입 제외)
   - `ref`: 초기화 필수, 양방향 전달
   - `out`: 초기화 불필요, 메서드에서 반드시 할당

3. **메서드 오버로딩**
   - 같은 이름, 다른 매개변수로 여러 버전 정의
   - 매개변수의 개수, 타입, 순서로 구분
   - 반환 타입만 다른 것은 오버로딩 불가

4. **선택적 매개변수와 명명된 인수**
   - 선택적 매개변수: 기본값을 가지는 매개변수
   - 명명된 인수: 매개변수 이름으로 값 전달
   - 코드의 유연성과 가독성 향상

5. **로컬 함수**
   - 메서드 내부에 정의되는 지역 함수
   - 외부 변수 접근 가능
   - 헬퍼 함수, 캡슐화에 유용

### 실습 문제

#### 문제 1: 기본 계산 메서드

네 가지 사칙연산을 수행하는 메서드를 작성하세요.

```csharp
int Add(int a, int b)
{
    return a + b;
}

int Subtract(int a, int b)
{
    return a - b;
}

int Multiply(int a, int b)
{
    return a * b;
}

double Divide(int a, int b)
{
    if (b == 0)
    {
        Console.WriteLine("0으로 나눌 수 없습니다.");
        return 0;
    }
    return (double)a / b;
}

// 테스트
Console.WriteLine($"10 + 5 = {Add(10, 5)}");
Console.WriteLine($"10 - 5 = {Subtract(10, 5)}");
Console.WriteLine($"10 × 5 = {Multiply(10, 5)}");
Console.WriteLine($"10 ÷ 5 = {Divide(10, 5)}");
```

#### 문제 2: 배열 처리 메서드

배열의 합계와 평균을 계산하는 메서드를 작성하세요.

```csharp
void PrintArrayStatistics(int[] numbers)
{
    // 합계를 계산하는 로컬 함수
    int GetSum()
    {
        int sum = 0;
        foreach (int num in numbers)
        {
            sum += num;
        }
        return sum;
    }
    
    // 평균을 계산하는 로컬 함수
    double GetAverage()
    {
        return (double)GetSum() / numbers.Length;
    }
    
    Console.WriteLine($"합계: {GetSum()}");
    Console.WriteLine($"평균: {GetAverage():F2}");
}

// 테스트
int[] scores = { 85, 90, 78, 92, 88 };
PrintArrayStatistics(scores);

// 출력:
// 합계: 433
// 평균: 86.60
```

#### 문제 3: 오버로딩을 사용한 출력 메서드

다양한 형태로 메시지를 출력하는 오버로드된 메서드를 작성하세요.

```csharp
void PrintMessage(string message)
{
    Console.WriteLine(message);
}

void PrintMessage(string message, int count)
{
    for (int i = 0; i < count; i++)
    {
        Console.WriteLine($"{i + 1}. {message}");
    }
}

void PrintMessage(string message, char border)
{
    string line = new string(border, message.Length + 4);
    Console.WriteLine(line);
    Console.WriteLine($"{border} {message} {border}");
    Console.WriteLine(line);
}

// 테스트
PrintMessage("안녕하세요");
Console.WriteLine();

PrintMessage("C# 학습", 3);
Console.WriteLine();

PrintMessage("중요 공지", '*');

// 출력:
// 안녕하세요
// 
// 1. C# 학습
// 2. C# 학습
// 3. C# 학습
// 
// **********
// * 중요 공지 *
// **********
```

#### 문제 4: ref/out 키워드 활용

두 변수의 값을 교환하는 메서드와 최대/최소값을 찾는 메서드를 작성하세요.

```csharp
void Swap(ref int a, ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}

void FindMinMax(int[] numbers, out int min, out int max)
{
    min = numbers[0];
    max = numbers[0];
    
    foreach (int num in numbers)
    {
        if (num < min) min = num;
        if (num > max) max = num;
    }
}

// 테스트
int x = 10, y = 20;
Console.WriteLine($"교환 전: x={x}, y={y}");
Swap(ref x, ref y);
Console.WriteLine($"교환 후: x={x}, y={y}");

Console.WriteLine();

int[] values = { 15, 3, 27, 8, 42, 19 };
FindMinMax(values, out int minimum, out int maximum);
Console.WriteLine($"최솟값: {minimum}");
Console.WriteLine($"최댓값: {maximum}");

// 출력:
// 교환 전: x=10, y=20
// 교환 후: x=20, y=10
// 
// 최솟값: 3
// 최댓값: 42
```

### 다음 장 예고

8장 "고급 메서드 활용"에서는 메서드를 더욱 강력하게 활용하는 방법을 학습합니다:
- 람다 식 (Lambda Expressions)
- Func와 Action 델리게이트
- 확장 메서드 (Extension Methods)
- 재귀 함수 (Recursive Functions)

이를 통해 함수형 프로그래밍의 개념을 이해하고, 더욱 표현력 있는 코드를 작성할 수 있게 됩니다!
