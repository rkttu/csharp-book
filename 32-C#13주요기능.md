# 32장. C# 13 주요 기능

C# 13은 2024년 11월 .NET 9와 함께 출시된 최신 버전으로, params의 확장, 새로운 lock 메커니즘, 그리고 ref struct의 유연성 향상을 중심으로 한 릴리스입니다. 이 버전은 성능 최적화와 코드의 안전성을 동시에 추구하며, 현대적인 C# 프로그래밍의 발전을 이어갑니다.

**C# 13의 설계 철학:**

1. **유연성(Flexibility)**: params를 모든 컬렉션 타입으로 확장하여 더 유연한 API 설계를 가능하게 합니다.
2. **성능(Performance)**: 새로운 lock 타입으로 동기화 성능을 개선합니다.
3. **안전성(Safety)**: ref struct가 인터페이스를 구현할 수 있게 하여 타입 안전성을 향상시킵니다.
4. **현대성(Modernity)**: async/await와 iterator에서 ref와 unsafe를 사용할 수 있게 합니다.

## 이 장에서 배울 내용

- **params collections**: params를 Span, ReadOnlySpan 등으로 확장
- **New lock type**: System.Threading.Lock을 사용한 개선된 동기화
- **New escape sequence**: `\e` 이스케이프 시퀀스
- **ref struct interfaces**: ref struct가 인터페이스 구현 가능
- **Method group improvements**: 메서드 그룹의 자연 타입 개선
- **Implicit indexer access**: 객체 초기화에서 암시적 인덱서 접근
- **Overload resolution priority**: 오버로드 해결 우선순위 제어

---

## 32.1 params Collections (params 컬렉션)

C# 13은 `params` 키워드를 배열뿐만 아니라 `Span<T>`, `ReadOnlySpan<T>` 등 다양한 컬렉션 타입으로 확장했습니다. 이는 성능을 크게 향상시키면서도 메모리 할당을 줄일 수 있게 합니다.

**전통적인 params (배열):**

```csharp
// C# 12 이전 - 항상 배열로 할당
void PrintNumbers(params int[] numbers)
{
    foreach (int num in numbers)
    {
        Console.WriteLine(num);
    }
}

PrintNumbers(1, 2, 3);  // int[] 배열 할당 발생
```

**C# 13의 params 확장:**

```csharp
// Span 사용 - 스택 할당 가능
void PrintNumbers(params ReadOnlySpan<int> numbers)
{
    foreach (int num in numbers)
    {
        Console.WriteLine(num);
    }
}

// 스택 할당으로 성능 향상
PrintNumbers(1, 2, 3, 4, 5);

// IEnumerable 사용
void ProcessItems(params IEnumerable<string> items)
{
    foreach (var item in items)
    {
        Console.WriteLine(item.ToUpper());
    }
}

ProcessItems("hello", "world", "C#");
```

**실전 예제 - 수학 함수:**

```csharp
// 가변 인자 수학 함수들
double Sum(params ReadOnlySpan<double> values)
{
    double sum = 0;
    foreach (var value in values)
    {
        sum += value;
    }
    return sum;
}

double Average(params ReadOnlySpan<double> values)
{
    if (values.Length == 0) return 0;
    return Sum(values) / values.Length;
}

double Max(params ReadOnlySpan<double> values)
{
    if (values.Length == 0) 
        throw new ArgumentException("최소 하나의 값이 필요합니다");
    
    double max = values[0];
    for (int i = 1; i < values.Length; i++)
    {
        if (values[i] > max) max = values[i];
    }
    return max;
}

// 사용
Console.WriteLine($"합계: {Sum(1.5, 2.3, 3.7, 4.2)}");
Console.WriteLine($"평균: {Average(10, 20, 30, 40)}");
Console.WriteLine($"최댓값: {Max(5.5, 3.2, 8.9, 2.1)}");
```

**성능 비교:**

```csharp
using System.Diagnostics;

// 배열 기반 (힙 할당)
void OldWay(params int[] numbers)
{
    int sum = 0;
    foreach (var n in numbers) sum += n;
}

// Span 기반 (스택 할당)
void NewWay(params ReadOnlySpan<int> numbers)
{
    int sum = 0;
    foreach (var n in numbers) sum += n;
}

// 성능 측정
var sw = Stopwatch.StartNew();
for (int i = 0; i < 1000000; i++)
{
    OldWay(1, 2, 3, 4, 5);
}
Console.WriteLine($"배열: {sw.ElapsedMilliseconds}ms");

sw.Restart();
for (int i = 0; i < 1000000; i++)
{
    NewWay(1, 2, 3, 4, 5);
}
Console.WriteLine($"Span: {sw.ElapsedMilliseconds}ms");
// Span이 훨씬 빠름!
```

---

## 32.2 New Lock Type and Semantics (새로운 lock 타입)

C# 13은 `System.Threading.Lock` 타입을 도입하여 더 효율적이고 안전한 동기화를 제공합니다. 기존의 `lock(object)` 패턴보다 성능이 우수하고 더 명확한 의도를 표현합니다.

**전통적인 lock:**

```csharp
public class Counter
{
    private readonly object _lock = new object();
    private int _count;
    
    public void Increment()
    {
        lock (_lock)
        {
            _count++;
        }
    }
    
    public int GetCount()
    {
        lock (_lock)
        {
            return _count;
        }
    }
}
```

**C# 13의 새로운 Lock 타입:**

```csharp
using System.Threading;

public class Counter
{
    private readonly Lock _lock = new();
    private int _count;
    
    public void Increment()
    {
        lock (_lock)
        {
            _count++;
        }
    }
    
    public int GetCount()
    {
        lock (_lock)
        {
            return _count;
        }
    }
}
```

**Lock.EnterScope() 사용:**

```csharp
public class BankAccount
{
    private readonly Lock _lock = new();
    private decimal _balance;
    
    public void Deposit(decimal amount)
    {
        using (_lock.EnterScope())
        {
            _balance += amount;
            Console.WriteLine($"입금: {amount:C}, 잔액: {_balance:C}");
        }
    }
    
    public void Withdraw(decimal amount)
    {
        using (_lock.EnterScope())
        {
            if (_balance >= amount)
            {
                _balance -= amount;
                Console.WriteLine($"출금: {amount:C}, 잔액: {_balance:C}");
            }
            else
            {
                Console.WriteLine("잔액 부족");
            }
        }
    }
    
    public decimal GetBalance()
    {
        using (_lock.EnterScope())
        {
            return _balance;
        }
    }
}

// 사용
var account = new BankAccount();
account.Deposit(1000);
account.Withdraw(300);
Console.WriteLine($"최종 잔액: {account.GetBalance():C}");
```

**성능 이점:**

```csharp
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;

public class LockComparison
{
    private readonly object _objectLock = new();
    private readonly Lock _newLock = new();
    private int _counter;
    
    public void TestObjectLock()
    {
        var tasks = new Task[10];
        _counter = 0;
        
        var sw = Stopwatch.StartNew();
        for (int i = 0; i < 10; i++)
        {
            tasks[i] = Task.Run(() =>
            {
                for (int j = 0; j < 100000; j++)
                {
                    lock (_objectLock)
                    {
                        _counter++;
                    }
                }
            });
        }
        Task.WaitAll(tasks);
        Console.WriteLine($"Object lock: {sw.ElapsedMilliseconds}ms");
    }
    
    public void TestNewLock()
    {
        var tasks = new Task[10];
        _counter = 0;
        
        var sw = Stopwatch.StartNew();
        for (int i = 0; i < 10; i++)
        {
            tasks[i] = Task.Run(() =>
            {
                for (int j = 0; j < 100000; j++)
                {
                    lock (_newLock)
                    {
                        _counter++;
                    }
                }
            });
        }
        Task.WaitAll(tasks);
        Console.WriteLine($"New Lock: {sw.ElapsedMilliseconds}ms");
    }
}

// 성능 비교
var comparison = new LockComparison();
comparison.TestObjectLock();
comparison.TestNewLock();
```

---

## 32.3 New Escape Sequence: \e

C# 13은 ANSI 이스케이프 코드를 나타내는 `\e` 이스케이프 시퀀스를 추가했습니다. 이는 터미널에서 색상과 스타일을 제어하는 데 유용합니다.

**기본 사용법:**

```csharp
// 기존 방식
string redText = "\x1b[31m빨간색 텍스트\x1b[0m";
string greenText = "\u001b[32m초록색 텍스트\u001b[0m";

// C# 13 - 더 명확한 \e
string blueText = "\e[34m파란색 텍스트\e[0m";
string boldText = "\e[1m굵은 텍스트\e[0m";

Console.WriteLine(redText);
Console.WriteLine(greenText);
Console.WriteLine(blueText);
Console.WriteLine(boldText);
```

**실전 예제 - 터미널 출력 헬퍼:**

```csharp
public static class TerminalColor
{
    public const string Reset = "\e[0m";
    
    // 전경색
    public const string Black = "\e[30m";
    public const string Red = "\e[31m";
    public const string Green = "\e[32m";
    public const string Yellow = "\e[33m";
    public const string Blue = "\e[34m";
    public const string Magenta = "\e[35m";
    public const string Cyan = "\e[36m";
    public const string White = "\e[37m";
    
    // 배경색
    public const string BgBlack = "\e[40m";
    public const string BgRed = "\e[41m";
    public const string BgGreen = "\e[42m";
    public const string BgYellow = "\e[43m";
    
    // 스타일
    public const string Bold = "\e[1m";
    public const string Underline = "\e[4m";
    
    public static void WriteSuccess(string message)
    {
        Console.WriteLine($"{Green}✓ {message}{Reset}");
    }
    
    public static void WriteError(string message)
    {
        Console.WriteLine($"{Red}✗ {message}{Reset}");
    }
    
    public static void WriteWarning(string message)
    {
        Console.WriteLine($"{Yellow}⚠ {message}{Reset}");
    }
    
    public static void WriteInfo(string message)
    {
        Console.WriteLine($"{Cyan}ℹ {message}{Reset}");
    }
}

// 사용
TerminalColor.WriteSuccess("작업이 성공적으로 완료되었습니다.");
TerminalColor.WriteError("오류가 발생했습니다.");
TerminalColor.WriteWarning("경고: 확인이 필요합니다.");
TerminalColor.WriteInfo("정보: 처리 중입니다.");
```

---

## 32.4 ref struct Types Implement Interfaces

C# 13에서는 `ref struct` 타입이 인터페이스를 구현할 수 있게 되었습니다. 이는 타입 안전성과 코드 재사용성을 크게 향상시킵니다.

**기본 사용법:**

```csharp
public interface IProcessor
{
    void Process();
}

// ref struct가 인터페이스 구현
public ref struct DataProcessor : IProcessor
{
    private Span<byte> _data;
    
    public DataProcessor(Span<byte> data)
    {
        _data = data;
    }
    
    public void Process()
    {
        for (int i = 0; i < _data.Length; i++)
        {
            _data[i] *= 2;
        }
    }
}

// 사용
Span<byte> data = stackalloc byte[] { 1, 2, 3, 4, 5 };
var processor = new DataProcessor(data);
processor.Process();

foreach (byte b in data)
{
    Console.Write($"{b} ");  // 2 4 6 8 10
}
```

**실전 예제 - 범용 스트림 처리:**

```csharp
public interface IStreamReader<T>
{
    T Read();
    bool HasMore();
}

public ref struct SpanStreamReader : IStreamReader<int>
{
    private ReadOnlySpan<int> _span;
    private int _position;
    
    public SpanStreamReader(ReadOnlySpan<int> span)
    {
        _span = span;
        _position = 0;
    }
    
    public int Read()
    {
        if (_position >= _span.Length)
            throw new InvalidOperationException("스트림 끝");
        
        return _span[_position++];
    }
    
    public bool HasMore() => _position < _span.Length;
}

// 범용 처리 함수
void ProcessStream<TReader>(TReader reader) where TReader : IStreamReader<int>
{
    while (reader.HasMore())
    {
        int value = reader.Read();
        Console.WriteLine($"읽은 값: {value}");
    }
}

// 사용
ReadOnlySpan<int> numbers = stackalloc int[] { 10, 20, 30, 40 };
var reader = new SpanStreamReader(numbers);
ProcessStream(reader);
```

---

## 32.5 Allow ref and unsafe in Async and Iterator Methods

C# 13은 async 메서드와 iterator에서 `ref` 지역 변수와 `unsafe` 컨텍스트를 제한적으로 사용할 수 있게 합니다.

**ref locals in async methods:**

```csharp
async Task<int> ProcessDataAsync(int[] array)
{
    // ref 지역 변수 사용 가능 (await 전에)
    ref int first = ref array[0];
    first = 100;
    
    // await 이후에는 ref 사용 불가
    await Task.Delay(100);
    
    return array.Sum();
}

// 사용
int[] numbers = { 1, 2, 3, 4, 5 };
int result = await ProcessDataAsync(numbers);
Console.WriteLine($"결과: {result}");  // 109 (100 + 2 + 3 + 4 + 5)
```

**Iterator with ref locals:**

```csharp
IEnumerable<int> GenerateNumbers(int[] array)
{
    // ref 지역 변수 사용
    ref int current = ref array[0];
    current = 0;
    
    for (int i = 0; i < array.Length; i++)
    {
        yield return array[i] * 2;
    }
}

// 사용
int[] data = { 1, 2, 3 };
foreach (var num in GenerateNumbers(data))
{
    Console.WriteLine(num);  // 0, 4, 6
}
```

---

## 32.6 Implicit Indexer Access in Object Initializers

객체 초기화 구문에서 인덱서를 암시적으로 사용할 수 있게 되었습니다.

**기본 사용법:**

```csharp
public class Matrix
{
    private int[,] _data = new int[3, 3];
    
    public int this[int row, int col]
    {
        get => _data[row, col];
        set => _data[row, col] = value;
    }
}

// C# 13 - 암시적 인덱서 접근
var matrix = new Matrix
{
    [0, 0] = 1,
    [0, 1] = 2,
    [0, 2] = 3,
    [1, 0] = 4,
    [1, 1] = 5,
    [1, 2] = 6
};
```

**실전 예제 - 설정 딕셔너리:**

```csharp
public class Configuration
{
    private Dictionary<string, string> _settings = new();
    
    public string this[string key]
    {
        get => _settings.TryGetValue(key, out var value) ? value : "";
        set => _settings[key] = value;
    }
    
    public void Display()
    {
        foreach (var (key, value) in _settings)
        {
            Console.WriteLine($"{key}: {value}");
        }
    }
}

// 간편한 초기화
var config = new Configuration
{
    ["host"] = "localhost",
    ["port"] = "8080",
    ["timeout"] = "30",
    ["ssl"] = "true"
};

config.Display();
```

---

## 32.7 Overload Resolution Priority

`OverloadResolutionPriorityAttribute`를 사용하여 오버로드 해결 우선순위를 명시적으로 제어할 수 있습니다.

**기본 사용법:**

```csharp
using System.Runtime.CompilerServices;

public class DataProcessor
{
    // 기본 우선순위 (0)
    public void Process(int value)
    {
        Console.WriteLine($"int 처리: {value}");
    }
    
    // 낮은 우선순위
    [OverloadResolutionPriority(-1)]
    public void Process(object value)
    {
        Console.WriteLine($"object 처리: {value}");
    }
    
    // 높은 우선순위
    [OverloadResolutionPriority(1)]
    public void Process(string value)
    {
        Console.WriteLine($"string 처리: {value}");
    }
}

var processor = new DataProcessor();
processor.Process(42);        // int 처리
processor.Process("hello");   // string 처리 (우선순위 높음)
processor.Process(3.14);      // object 처리 (낮은 우선순위)
```

---

## 32.8 실전 종합 예제

```csharp
using System.Threading;

// C# 13 종합 예제: 고성능 데이터 처리 시스템
public ref struct DataBuffer : IDisposable
{
    private Span<byte> _buffer;
    private int _position;
    
    public DataBuffer(Span<byte> buffer)
    {
        _buffer = buffer;
        _position = 0;
    }
    
    public void Write(params ReadOnlySpan<byte> data)
    {
        data.CopyTo(_buffer.Slice(_position));
        _position += data.Length;
    }
    
    public ReadOnlySpan<byte> GetData() => _buffer.Slice(0, _position);
    
    public void Dispose()
    {
        _buffer.Clear();
    }
}

public class DataProcessor
{
    private readonly Lock _lock = new();
    private int _processedCount;
    
    [OverloadResolutionPriority(1)]
    public void Process(params ReadOnlySpan<byte> data)
    {
        using (_lock.EnterScope())
        {
            _processedCount += data.Length;
            TerminalColor.WriteSuccess($"처리됨: {data.Length} 바이트");
        }
    }
    
    [OverloadResolutionPriority(-1)]
    public void Process(object data)
    {
        TerminalColor.WriteWarning("일반 객체 처리");
    }
    
    public int GetProcessedCount()
    {
        using (_lock.EnterScope())
        {
            return _processedCount;
        }
    }
}

// 사용 예제
Span<byte> buffer = stackalloc byte[1024];
using (var dataBuffer = new DataBuffer(buffer))
{
    dataBuffer.Write(1, 2, 3, 4, 5);
    dataBuffer.Write(10, 20, 30);
    
    var processor = new DataProcessor();
    processor.Process(dataBuffer.GetData());
    
    Console.WriteLine($"총 처리: {processor.GetProcessedCount()} 바이트");
}
```

---

## 32.9 마치며

C# 13은 성능과 안전성을 동시에 향상시킨 중요한 릴리스입니다. params collections는 메모리 할당을 줄이고, 새로운 Lock 타입은 동기화 성능을 개선하며, ref struct의 인터페이스 구현은 타입 안전성을 강화합니다.

**학습한 내용 요약:**
- params collections로 고성능 가변 인자
- New Lock type으로 개선된 동기화
- \e 이스케이프 시퀀스로 터미널 제어
- ref struct 인터페이스 구현으로 타입 안전성 향상
- async/iterator에서 ref와 unsafe 사용
- 암시적 인덱서 접근과 오버로드 우선순위 제어

**다음 단계:**
- 고성능 시나리오에 C# 13 기능 적용
- C# 14 프리뷰 기능 탐색
- .NET 9의 새로운 API 활용

**참고 자료:**
- [C# 13의 새로운 기능](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-13)
- [params collections](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-13)
- [System.Threading.Lock](https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.lock)
