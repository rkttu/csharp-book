# 11장. 고급 객체지향 개념

객체지향 프로그래밍(OOP)의 기본 개념을 이해한 후에는, C#이 제공하는 더 고급스럽고 현대적인 기능들을 활용하여 더 안전하고 효율적인 코드를 작성할 수 있습니다. 이 장에서는 클래스의 상속을 제한하는 `sealed` 키워드, 불변 데이터 모델링을 위한 `record` 타입, 값 의미론을 가진 `struct`, 그리고 명명된 상수 집합인 `enum`에 대해 학습합니다.

## 이 장에서 배울 내용

- **sealed 클래스와 메서드**: 상속을 제한하여 설계 의도를 명확히 하고 성능을 최적화하는 방법
- **record 타입**: 불변 데이터 모델을 간결하게 정의하고, 비파괴적 변경을 지원하는 현대적 기능
- **구조체 (Struct)**: 값 타입의 특성을 이해하고, 클래스와의 차이점 및 적절한 사용 시나리오
- **열거형 (Enum)**: 관련된 상수들을 그룹화하여 코드의 가독성과 타입 안전성을 높이는 방법

---

## 11.1 sealed 클래스와 메서드

`sealed` 키워드는 클래스나 메서드의 상속 또는 오버라이딩을 명시적으로 금지하는 한정자입니다. 이는 설계 의도를 명확히 전달하고, 의도하지 않은 상속으로 인한 문제를 방지하며, 컴파일러가 최적화할 수 있는 기회를 제공합니다.

**sealed 클래스:**

sealed 클래스는 더 이상 상속할 수 없는 클래스입니다. 다른 클래스가 이 클래스를 기본 클래스로 사용할 수 없습니다.

```csharp
// sealed 클래스 정의
sealed class FinalClass
{
    public void Display()
    {
        Console.WriteLine("이 클래스는 상속할 수 없습니다.");
    }
}

// ❌ 컴파일 오류: sealed 클래스를 상속할 수 없음
// class DerivedClass : FinalClass
// {
// }

// 사용
FinalClass obj = new FinalClass();
obj.Display();
// 출력: 이 클래스는 상속할 수 없습니다.
```

**sealed 메서드:**

sealed 메서드는 이미 오버라이드된 메서드를 더 이상 하위 클래스에서 오버라이드하지 못하게 합니다. sealed 메서드는 반드시 `override` 키워드와 함께 사용해야 합니다.

```csharp
class BaseClass
{
    public virtual void Display()
    {
        Console.WriteLine("기본 클래스");
    }
}

class MiddleClass : BaseClass
{
    // override와 sealed를 함께 사용
    public sealed override void Display()
    {
        Console.WriteLine("중간 클래스 (더 이상 오버라이드 불가)");
    }
}

// ❌ 컴파일 오류: sealed 메서드를 오버라이드할 수 없음
// class DerivedClass : MiddleClass
// {
//     public override void Display()
//     {
//     }
// }

// 사용
MiddleClass obj = new MiddleClass();
obj.Display();
// 출력: 중간 클래스 (더 이상 오버라이드 불가)
```

**sealed를 사용하는 이유:**

1. **설계 의도 명확화**: 더 이상 확장되지 않아야 하는 클래스임을 명시적으로 표현
2. **안정성 보장**: 예상치 못한 상속으로 인한 버그 방지
3. **성능 최적화**: 컴파일러가 가상 메서드 호출을 최적화할 수 있는 기회 제공
4. **보안**: 중요한 클래스가 악의적으로 확장되는 것을 방지

**실용 예제:**

```csharp
// 불변 설정 클래스
sealed class AppConfiguration
{
    public string DatabaseConnection { get; }
    public int MaxRetries { get; }

    public AppConfiguration(string dbConnection, int maxRetries)
    {
        DatabaseConnection = dbConnection;
        MaxRetries = maxRetries;
    }
}

// 사용
AppConfiguration config = new AppConfiguration(
    "Server=localhost;Database=mydb",
    3
);

Console.WriteLine($"DB: {config.DatabaseConnection}");
Console.WriteLine($"재시도: {config.MaxRetries}회");
```

---

## 11.2 record 타입

`record`는 C# 9.0에서 도입된 참조 타입으로, 주로 불변 데이터 모델을 정의하는 데 사용됩니다. record는 값 기반 동등성(value equality)을 자동으로 구현하며, 간결한 문법으로 데이터 전송 객체(DTO)나 값 객체(Value Object)를 표현할 수 있습니다.

### 11.2.1 record 기본 사용법

**기본 정의:**

```csharp
// 위치 기반 record (C# 9.0+)
record Person(string Name, int Age);

// 사용
Person person1 = new Person("홍길동", 30);
Person person2 = new Person("홍길동", 30);

Console.WriteLine($"이름: {person1.Name}, 나이: {person1.Age}");
// 출력: 이름: 홍길동, 나이: 30

// 값 기반 동등성: 내용이 같으면 같은 것으로 간주
Console.WriteLine(person1 == person2);
// 출력: True

// ToString 자동 생성
Console.WriteLine(person1);
// 출력: Person { Name = 홍길동, Age = 30 }
```

**전통적인 구문을 사용한 record:**

```csharp
record Product
{
    public string Name { get; init; }
    public decimal Price { get; init; }
    public string Category { get; init; }

    public Product(string name, decimal price, string category)
    {
        Name = name;
        Price = price;
        Category = category;
    }
}

// 사용
Product laptop = new Product("노트북", 1500000m, "전자제품");
Console.WriteLine($"{laptop.Name}: {laptop.Price:C}");
// 출력: 노트북: ₩1,500,000
```

**record의 주요 특징:**

1. **값 기반 동등성**: 참조가 아닌 내용으로 비교
2. **불변성**: `init` 접근자를 통해 생성 시에만 값 설정 가능
3. **간결한 문법**: 위치 기반 레코드로 보일러플레이트 코드 감소
4. **ToString 자동 구현**: 디버깅과 로깅에 유용한 문자열 표현
5. **Deconstruction 지원**: 튜플처럼 분해 가능

```csharp
record Point(int X, int Y);

Point p = new Point(10, 20);

// Deconstruction
var (x, y) = p;
Console.WriteLine($"X: {x}, Y: {y}");
// 출력: X: 10, Y: 20
```

### 11.2.2 with 식을 사용한 비파괴적 변경

`with` 식은 기존 record 인스턴스를 기반으로 일부 속성만 변경한 새로운 인스턴스를 생성합니다. 이는 불변 객체를 다루면서도 편리하게 값을 변경할 수 있는 방법을 제공합니다.

```csharp
record Person(string Name, int Age, string City);

Person original = new Person("김철수", 25, "서울");
Console.WriteLine(original);
// 출력: Person { Name = 김철수, Age = 25, City = 서울 }

// with 식으로 나이만 변경한 새 인스턴스 생성
Person older = original with { Age = 26 };
Console.WriteLine(older);
// 출력: Person { Name = 김철수, Age = 26, City = 서울 }

// 여러 속성 동시 변경
Person moved = original with { Age = 26, City = "부산" };
Console.WriteLine(moved);
// 출력: Person { Name = 김철수, Age = 26, City = 부산 }

// 원본은 변경되지 않음
Console.WriteLine(original);
// 출력: Person { Name = 김철수, Age = 25, City = 서울 }
```

**실용 예제 - 주문 정보:**

```csharp
record OrderInfo(
    int OrderId,
    string CustomerName,
    decimal Amount,
    string Status
);

// 초기 주문 생성
OrderInfo order = new OrderInfo(
    OrderId: 1001,
    CustomerName: "이영희",
    Amount: 50000m,
    Status: "접수"
);

Console.WriteLine("초기 주문:");
Console.WriteLine(order);
// 출력: OrderInfo { OrderId = 1001, CustomerName = 이영희, Amount = 50000, Status = 접수 }

// 상태 업데이트
OrderInfo processing = order with { Status = "처리중" };
Console.WriteLine("\n처리 중:");
Console.WriteLine(processing);
// 출력: OrderInfo { OrderId = 1001, CustomerName = 이영희, Amount = 50000, Status = 처리중 }

// 배송 완료
OrderInfo completed = processing with { Status = "배송완료" };
Console.WriteLine("\n배송 완료:");
Console.WriteLine(completed);
// 출력: OrderInfo { OrderId = 1001, CustomerName = 이영희, Amount = 50000, Status = 배송완료 }
```

**record의 장점:**

1. **불변성**: 스레드 안전하고 예측 가능한 코드 작성
2. **간결성**: 보일러플레이트 코드 대폭 감소
3. **가독성**: 의도가 명확한 데이터 모델 표현
4. **편의성**: `with` 식으로 쉬운 복사 및 수정

---

## 11.3 구조체 (Struct)

구조체(struct)는 값 타입(value type)의 사용자 정의 데이터 구조입니다. 클래스(class)와 유사한 문법을 가지지만, 메모리 할당과 동작 방식에서 근본적인 차이가 있습니다.

### 11.3.1 struct vs class

**기본 구조체 정의:**

```csharp
struct Point
{
    public int X;
    public int Y;

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public double DistanceFromOrigin()
    {
        return Math.Sqrt(X * X + Y * Y);
    }
}

// 사용
Point p1 = new Point(3, 4);
Console.WriteLine($"점: ({p1.X}, {p1.Y})");
Console.WriteLine($"원점으로부터 거리: {p1.DistanceFromOrigin():F2}");
// 출력:
// 점: (3, 4)
// 원점으로부터 거리: 5.00
```

**struct와 class의 핵심 차이:**

| 특성 | struct (값 타입) | class (참조 타입) |
|------|-----------------|------------------|
| **메모리 할당** | 스택 (또는 인라인) | 힙 |
| **복사 동작** | 값 복사 (깊은 복사) | 참조 복사 (얕은 복사) |
| **기본값** | 0, false, null 등으로 초기화 | null |
| **상속** | 불가능 (인터페이스만 구현) | 가능 |
| **null 허용** | C# 8.0+ Nullable<T> 필요 | 기본적으로 가능 |
| **성능** | 작은 데이터에 유리 (GC 부담 없음) | 큰 데이터에 유리 (복사 비용 없음) |

**값 의미론 예제:**

```csharp
struct StructPoint
{
    public int X;
    public int Y;

    public StructPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}

class ClassPoint
{
    public int X;
    public int Y;

    public ClassPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}

// struct: 값 복사
StructPoint sp1 = new StructPoint(10, 20);
StructPoint sp2 = sp1;  // 값이 복사됨
sp2.X = 100;

Console.WriteLine("struct 복사 후:");
Console.WriteLine($"sp1.X = {sp1.X}");  // 10 (변경 안 됨)
Console.WriteLine($"sp2.X = {sp2.X}");  // 100

// class: 참조 복사
ClassPoint cp1 = new ClassPoint(10, 20);
ClassPoint cp2 = cp1;  // 참조가 복사됨 (같은 객체를 가리킴)
cp2.X = 100;

Console.WriteLine("\nclass 복사 후:");
Console.WriteLine($"cp1.X = {cp1.X}");  // 100 (함께 변경됨)
Console.WriteLine($"cp2.X = {cp2.X}");  // 100

// 출력:
// struct 복사 후:
// sp1.X = 10
// sp2.X = 100
//
// class 복사 후:
// cp1.X = 100
// cp2.X = 100
```

**struct 사용 가이드라인:**

struct를 사용해야 하는 경우:
- 크기가 작은 데이터 (일반적으로 16바이트 이하)
- 논리적으로 단일 값을 나타내는 경우 (좌표, 색상, 복소수 등)
- 불변성이 요구되는 경우
- 빈번한 생성/소멸이 필요한 경우 (GC 부담 감소)

class를 사용해야 하는 경우:
- 크기가 큰 데이터
- 상속이 필요한 경우
- 참조 의미론이 필요한 경우
- null 값이 의미있는 경우

**실용 예제 - 색상:**

```csharp
struct Color
{
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }

    public Color(byte r, byte g, byte b)
    {
        R = r;
        G = g;
        B = b;
    }

    public override string ToString()
    {
        return $"RGB({R}, {G}, {B})";
    }

    // 미리 정의된 색상
    public static Color Red => new Color(255, 0, 0);
    public static Color Green => new Color(0, 255, 0);
    public static Color Blue => new Color(0, 0, 255);
}

// 사용
Color red = Color.Red;
Color custom = new Color(128, 64, 192);

Console.WriteLine($"빨강: {red}");
Console.WriteLine($"사용자 정의: {custom}");
// 출력:
// 빨강: RGB(255, 0, 0)
// 사용자 정의: RGB(128, 64, 192)
```

### 11.3.2 record struct

C# 10.0에서는 `record struct`가 도입되어, struct에도 record의 편리한 기능들을 사용할 수 있게 되었습니다.

```csharp
// record struct 정의
record struct Point3D(int X, int Y, int Z);

// 사용
Point3D p1 = new Point3D(1, 2, 3);
Point3D p2 = new Point3D(1, 2, 3);

// 값 기반 동등성
Console.WriteLine(p1 == p2);
// 출력: True

// ToString 자동 생성
Console.WriteLine(p1);
// 출력: Point3D { X = 1, Y = 2, Z = 3 }

// with 식 사용
Point3D p3 = p1 with { Z = 5 };
Console.WriteLine(p3);
// 출력: Point3D { X = 1, Y = 2, Z = 5 }

// 원본은 변경 안 됨 (값 타입)
Console.WriteLine(p1);
// 출력: Point3D { X = 1, Y = 2, Z = 3 }
```

**readonly record struct:**

불변성을 보장하려면 `readonly` 한정자를 추가할 수 있습니다.

```csharp
readonly record struct ImmutablePoint(int X, int Y)
{
    // 모든 필드가 자동으로 readonly가 됨
}

// 사용
ImmutablePoint p = new ImmutablePoint(10, 20);
// p.X = 30; // ❌ 컴파일 오류: 읽기 전용 속성에 할당할 수 없음

// with 식은 새 인스턴스 생성이므로 가능
ImmutablePoint p2 = p with { X = 30 };
Console.WriteLine(p2);
// 출력: ImmutablePoint { X = 30, Y = 20 }
```

**record struct vs record class:**

| 특성 | record struct | record class |
|------|--------------|--------------|
| **타입** | 값 타입 | 참조 타입 |
| **메모리** | 스택 | 힙 |
| **복사** | 값 복사 | 참조 복사 |
| **성능** | 작은 데이터에 유리 | 큰 데이터에 유리 |
| **용도** | 좌표, 범위, 작은 데이터 | DTO, 도메인 모델 |

---

## 11.4 열거형 (Enum)

열거형(Enumeration, Enum)은 관련된 명명된 상수들의 집합을 정의하는 값 타입입니다. 숫자 대신 의미 있는 이름을 사용하여 코드의 가독성과 유지보수성을 향상시킵니다.

**기본 열거형:**

```csharp
enum DayOfWeek
{
    Sunday,    // 0
    Monday,    // 1
    Tuesday,   // 2
    Wednesday, // 3
    Thursday,  // 4
    Friday,    // 5
    Saturday   // 6
}

// 사용
DayOfWeek today = DayOfWeek.Monday;
Console.WriteLine($"오늘은 {today}입니다.");
// 출력: 오늘은 Monday입니다.

// 정수값으로 변환
int dayNumber = (int)today;
Console.WriteLine($"요일 번호: {dayNumber}");
// 출력: 요일 번호: 1

// 정수에서 열거형으로 변환
DayOfWeek friday = (DayOfWeek)5;
Console.WriteLine(friday);
// 출력: Friday
```

**명시적 값 지정:**

```csharp
enum HttpStatusCode
{
    OK = 200,
    Created = 201,
    BadRequest = 400,
    Unauthorized = 401,
    NotFound = 404,
    InternalServerError = 500
}

// 사용
HttpStatusCode status = HttpStatusCode.NotFound;
Console.WriteLine($"상태 코드: {(int)status} - {status}");
// 출력: 상태 코드: 404 - NotFound
```

**열거형과 switch 문:**

```csharp
enum OrderStatus
{
    Pending,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}

void PrintOrderStatus(OrderStatus status)
{
    switch (status)
    {
        case OrderStatus.Pending:
            Console.WriteLine("주문이 접수되었습니다.");
            break;
        case OrderStatus.Processing:
            Console.WriteLine("주문을 처리하고 있습니다.");
            break;
        case OrderStatus.Shipped:
            Console.WriteLine("주문이 배송 중입니다.");
            break;
        case OrderStatus.Delivered:
            Console.WriteLine("배송이 완료되었습니다.");
            break;
        case OrderStatus.Cancelled:
            Console.WriteLine("주문이 취소되었습니다.");
            break;
    }
}

// 사용
PrintOrderStatus(OrderStatus.Processing);
// 출력: 주문을 처리하고 있습니다.

PrintOrderStatus(OrderStatus.Delivered);
// 출력: 배송이 완료되었습니다.
```

**switch 식 (C# 8.0+):**

```csharp
string GetStatusMessage(OrderStatus status) => status switch
{
    OrderStatus.Pending => "주문 접수",
    OrderStatus.Processing => "처리 중",
    OrderStatus.Shipped => "배송 중",
    OrderStatus.Delivered => "배송 완료",
    OrderStatus.Cancelled => "취소됨",
    _ => "알 수 없는 상태"
};

// 사용
Console.WriteLine(GetStatusMessage(OrderStatus.Shipped));
// 출력: 배송 중
```

**Flags 특성을 사용한 비트 플래그:**

`[Flags]` 특성을 사용하면 열거형을 비트 플래그로 사용할 수 있어, 여러 값을 조합할 수 있습니다.

```csharp
[Flags]
enum FileAccess
{
    None = 0,           // 0000
    Read = 1,           // 0001
    Write = 2,          // 0010
    Execute = 4,        // 0100
    Delete = 8          // 1000
}

// 사용
FileAccess permission = FileAccess.Read | FileAccess.Write;
Console.WriteLine($"권한: {permission}");
// 출력: 권한: Read, Write

// 권한 확인
bool canRead = (permission & FileAccess.Read) == FileAccess.Read;
bool canExecute = (permission & FileAccess.Execute) == FileAccess.Execute;

Console.WriteLine($"읽기 가능: {canRead}");
Console.WriteLine($"실행 가능: {canExecute}");
// 출력:
// 읽기 가능: True
// 실행 가능: False

// 권한 추가
permission |= FileAccess.Delete;
Console.WriteLine($"업데이트된 권한: {permission}");
// 출력: 업데이트된 권한: Read, Write, Delete

// 권한 제거
permission &= ~FileAccess.Write;
Console.WriteLine($"최종 권한: {permission}");
// 출력: 최종 권한: Read, Delete
```

**열거형 메서드:**

```csharp
enum Priority
{
    Low,
    Medium,
    High,
    Critical
}

// 모든 열거형 값 가져오기
Console.WriteLine("모든 우선순위:");
foreach (Priority p in Enum.GetValues(typeof(Priority)))
{
    Console.WriteLine($"- {p} ({(int)p})");
}
// 출력:
// 모든 우선순위:
// - Low (0)
// - Medium (1)
// - High (2)
// - Critical (3)

// 문자열을 열거형으로 변환
string input = "High";
if (Enum.TryParse<Priority>(input, out Priority priority))
{
    Console.WriteLine($"\n파싱 성공: {priority}");
}
else
{
    Console.WriteLine("\n파싱 실패");
}
// 출력: 파싱 성공: High

// 열거형이 정의되어 있는지 확인
bool isValid = Enum.IsDefined(typeof(Priority), 2);
Console.WriteLine($"\n값 2가 유효한가? {isValid}");
// 출력: 값 2가 유효한가? True
```

**실용 예제 - 로그 레벨:**

```csharp
enum LogLevel
{
    Debug,
    Info,
    Warning,
    Error,
    Critical
}

void Log(string message, LogLevel level)
{
    string prefix = level switch
    {
        LogLevel.Debug => "[DEBUG]",
        LogLevel.Info => "[INFO]",
        LogLevel.Warning => "[WARNING]",
        LogLevel.Error => "[ERROR]",
        LogLevel.Critical => "[CRITICAL]",
        _ => "[UNKNOWN]"
    };

    Console.WriteLine($"{prefix} {message}");
}

// 사용
Log("애플리케이션 시작", LogLevel.Info);
Log("디버그 정보 출력", LogLevel.Debug);
Log("경고: 메모리 사용량 높음", LogLevel.Warning);
Log("오류: 파일을 찾을 수 없음", LogLevel.Error);
Log("치명적: 시스템 장애", LogLevel.Critical);

// 출력:
// [INFO] 애플리케이션 시작
// [DEBUG] 디버그 정보 출력
// [WARNING] 경고: 메모리 사용량 높음
// [ERROR] 오류: 파일을 찾을 수 없음
// [CRITICAL] 치명적: 시스템 장애
```

---

## 11장 정리 및 요약

이 장에서는 C#의 고급 객체지향 기능들을 학습했습니다.

### 핵심 개념 정리

1. **sealed 클래스와 메서드**
   - 상속과 오버라이딩을 제한하여 설계 의도 명확화
   - 보안과 성능 최적화에 기여
   - 클래스와 메서드 모두에 적용 가능

2. **record 타입**
   - 불변 데이터 모델을 간결하게 정의
   - 값 기반 동등성과 자동 ToString 구현
   - `with` 식으로 비파괴적 변경 지원
   - DTO와 값 객체 구현에 이상적

3. **구조체 (Struct)**
   - 값 타입의 사용자 정의 데이터 구조
   - 스택 메모리 할당으로 성능 이점
   - 작고 불변적인 데이터에 적합
   - record struct로 편의성 향상

4. **열거형 (Enum)**
   - 관련된 상수들의 명명된 집합
   - 코드 가독성과 타입 안전성 향상
   - switch 문/식과 완벽한 통합
   - Flags 특성으로 비트 플래그 구현

### 언제 무엇을 사용할까?

**값 vs 참조:**
- **작은 불변 데이터 (< 16바이트)**: `readonly struct` 또는 `readonly record struct`
- **데이터 전송 객체 (DTO)**: `record class`
- **도메인 엔티티**: `class`
- **작은 값 표현 (좌표, 색상)**: `struct`

**불변성 보장:**
- **간단한 불변 데이터**: `record`
- **더 이상 확장 금지**: `sealed class`
- **값 타입 불변**: `readonly struct`

**명명된 상수:**
- **단순 열거**: `enum`
- **비트 플래그**: `[Flags] enum`

### 실습 문제

#### 문제 1: record를 사용한 학생 정보 관리

```csharp
record Student(int Id, string Name, int Grade, double GPA);

// 학생 생성
Student student = new Student(1, "김학생", 3, 3.8);
Console.WriteLine(student);

// 학년 업그레이드
Student graduated = student with { Grade = 4, GPA = 3.9 };
Console.WriteLine(graduated);
```

#### 문제 2: struct를 사용한 좌표 계산

```csharp
struct Point
{
    public double X { get; }
    public double Y { get; }

    public Point(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double DistanceTo(Point other)
    {
        double dx = X - other.X;
        double dy = Y - other.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
}

Point p1 = new Point(0, 0);
Point p2 = new Point(3, 4);
Console.WriteLine($"거리: {p1.DistanceTo(p2):F2}");
// 출력: 거리: 5.00
```

#### 문제 3: enum을 사용한 상태 관리

```csharp
enum TaskStatus
{
    NotStarted,
    InProgress,
    Completed,
    OnHold
}

string GetStatusIcon(TaskStatus status) => status switch
{
    TaskStatus.NotStarted => "⭕",
    TaskStatus.InProgress => "🔄",
    TaskStatus.Completed => "✅",
    TaskStatus.OnHold => "⏸️",
    _ => "❓"
};

Console.WriteLine($"작업 상태: {GetStatusIcon(TaskStatus.InProgress)}");
```

### 다음 장 예고

12장 "예외 처리"에서는 프로그램 실행 중 발생하는 오류를 처리하는 방법을 학습합니다:
- try-catch-finally 구문
- 예외 던지기와 사용자 정의 예외
- 예외 처리 모범 사례

안전하고 견고한 프로그램을 작성하는 핵심 기술을 배우게 됩니다!
