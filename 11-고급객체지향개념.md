# 11ì¥. ê³ ê¸‰ ê°ì²´ì§€í–¥ ê°œë…

ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°(OOP)ì˜ ì—¬ì •ì€ 1960ë…„ëŒ€ Ole-Johan Dahlê³¼ Kristen Nygaardê°€ ê°œë°œí•œ Simula 67ì—ì„œ ì‹œì‘ë˜ì–´, Smalltalk, C++, Javaë¥¼ ê±°ì³ í˜„ëŒ€ì˜ C#ì— ì´ë¥´ê¸°ê¹Œì§€ ì§€ì†ì ìœ¼ë¡œ ì§„í™”í•´ì™”ìŠµë‹ˆë‹¤. ì´ ì¥ì—ì„œ ë‹¤ë£° ê³ ê¸‰ ê°ì²´ì§€í–¥ ê°œë…ë“¤ì€ ì´ëŸ¬í•œ ì§„í™”ì˜ ê²°ê³¼ë¬¼ë¡œ, íƒ€ì… ì•ˆì „ì„±(Type Safety), ë¶ˆë³€ì„±(Immutability), ì„±ëŠ¥ ìµœì í™”(Performance Optimization)ë¼ëŠ” í˜„ëŒ€ í”„ë¡œê·¸ë˜ë°ì˜ ì„¸ ê°€ì§€ í•µì‹¬ ê°€ì¹˜ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

`sealed` í‚¤ì›Œë“œëŠ” Joshua Blochì˜ "Effective Java"ì—ì„œ ê°•ì¡°í•œ "ìƒì†ì„ ìœ„í•œ ì„¤ê³„ì™€ ë¬¸ì„œí™”, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ìƒì† ê¸ˆì§€" ì›ì¹™ì„ ì½”ë“œë¡œ êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤. `record` íƒ€ì…ì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ë¶ˆë³€ ë°ì´í„° êµ¬ì¡°(Immutable Data Structures)ë¥¼ C#ì— ë„ì…í•˜ì—¬, Eric Evansì˜ ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(Domain-Driven Design)ì—ì„œ ì œì‹œí•œ ê°’ ê°ì²´(Value Object) íŒ¨í„´ì„ ìš°ì•„í•˜ê²Œ í‘œí˜„í•©ë‹ˆë‹¤. `struct`ëŠ” .NETì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ëª¨ë¸ì—ì„œ ìŠ¤íƒ í• ë‹¹(Stack Allocation)ê³¼ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ë¶€ë‹´ ê°ì†Œë¥¼ í†µí•´ ì„±ëŠ¥ ìµœì í™”ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ë©°, `enum`ì€ íƒ€ì… ì•ˆì „í•œ ìƒìˆ˜ ì§‘í•©ì„ ì œê³µí•˜ì—¬ ë§¤ì§ ë„˜ë²„(Magic Number) ì•ˆí‹°íŒ¨í„´ì„ ì œê±°í•©ë‹ˆë‹¤.

ì´ëŸ¬í•œ ê¸°ëŠ¥ë“¤ì€ ë‹¨ìˆœí•œ ë¬¸ë²•ì  í¸ì˜ë¥¼ ë„˜ì–´, Barbara Liskovì˜ ì¹˜í™˜ ì›ì¹™(Liskov Substitution Principle), Bertrand Meyerì˜ ê³„ì•½ì— ì˜í•œ ì„¤ê³„(Design by Contract), ê·¸ë¦¬ê³  Robert C. Martinì˜ SOLID ì›ì¹™ê³¼ ê°™ì€ ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ì˜ ê·¼ë³¸ ì›ë¦¬ë“¤ì„ êµ¬ì²´ì ìœ¼ë¡œ ì‹¤í˜„í•˜ëŠ” ë„êµ¬ì…ë‹ˆë‹¤. C# ì–¸ì–´ ì„¤ê³„íŒ€(Anders Hejlsberg, Mads Torgersen ë“±)ì€ ì´ëŸ¬í•œ ì´ë¡ ì  í† ëŒ€ ìœ„ì— ì‹¤ìš©ì ì¸ ë¬¸ë²•ì„ êµ¬ì¶•í•˜ì—¬, ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì´ë©° ìœ ì§€ë³´ìˆ˜ ê°€ëŠ¥í•œ ì½”ë“œ ì‘ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í–ˆìŠµë‹ˆë‹¤.

## ì´ ì¥ì—ì„œ ë°°ìš¸ ë‚´ìš©

ì´ ì¥ì„ í†µí•´ ë…ì ì—¬ëŸ¬ë¶„ì€ C#ì˜ ê³ ê¸‰ íƒ€ì… ì‹œìŠ¤í…œì„ ì²´ê³„ì ìœ¼ë¡œ í•™ìŠµí•˜ê²Œ ë©ë‹ˆë‹¤:

- **sealed í´ë˜ìŠ¤ì™€ ë©”ì„œë“œ**: ìƒì† ê³„ì¸µ êµ¬ì¡°ì˜ ì¢…ë£Œì ì„ ëª…ì‹œí•˜ì—¬ Fragile Base Class Problemì„ ë°©ì§€í•˜ê³ , ì»´íŒŒì¼ëŸ¬ì˜ devirtualization ìµœì í™”ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤. .NET Framework ìì²´ì˜ `System.String`ì´ sealedì¸ ì´ìœ ì™€, Joshua Blochì˜ ì„¤ê³„ ì² í•™ì„ ì‹¤ì²œí•˜ëŠ” ë°©ë²•ì„ ì´í•´í•©ë‹ˆë‹¤.

- **record íƒ€ì…**: C# 9.0ì—ì„œ ë„ì…ëœ recordëŠ” í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ë¶ˆë³€ ë°ì´í„° êµ¬ì¡°ë¥¼ C#ì— êµ¬í˜„í•œ ê²ƒìœ¼ë¡œ, êµ¬ì¡°ì  ë™ë“±ì„±(Structural Equality)ê³¼ ë¹„íŒŒê´´ì  ë³€ê²½(Non-destructive Mutation)ì„ í†µí•´ ê°’ ì§€í–¥ ì„¤ê³„(Value-Oriented Design)ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤. Eric Evansì˜ DDDì—ì„œ ì œì‹œí•œ ê°’ ê°ì²´ì™€ ì—”í‹°í‹°ì˜ êµ¬ë¶„ì„ ì½”ë“œë¡œ í‘œí˜„í•˜ëŠ” ë°©ë²•ì„ ë°°ì›ë‹ˆë‹¤.

- **êµ¬ì¡°ì²´ (Struct)**: ê°’ ì˜ë¯¸ë¡ (Value Semantics)ê³¼ ì°¸ì¡° ì˜ë¯¸ë¡ (Reference Semantics)ì˜ ê·¼ë³¸ì  ì°¨ì´ë¥¼ ì´í•´í•˜ê³ , .NETì˜ ë©”ëª¨ë¦¬ ê´€ë¦¬ ëª¨ë¸(ìŠ¤íƒ vs í™)ì—ì„œ structì˜ ì—­í• ì„ í•™ìŠµí•©ë‹ˆë‹¤. C# 10ì˜ record structëŠ” ë¶ˆë³€ ê°’ íƒ€ì…ì˜ í‘œí˜„ë ¥ì„ í•œì¸µ ë†’ì—¬ì¤ë‹ˆë‹¤.

- **ì—´ê±°í˜• (Enum)**: íƒ€ì… ì•ˆì „í•œ ëª…ëª…ëœ ìƒìˆ˜ë¥¼ í†µí•´ Martin Fowlerê°€ ì§€ì í•œ Primitive Obsession ì½”ë“œ ìŠ¤ë©œì„ ì œê±°í•˜ê³ , [Flags] íŠ¹ì„±ì„ í†µí•œ ë¹„íŠ¸ í•„ë“œ êµ¬í˜„ ë°©ë²•ì„ ìµí™ë‹ˆë‹¤.

**í•™ìŠµ ëª©í‘œ:**
- íƒ€ì… ì‹œìŠ¤í…œì˜ ì•ˆì „ì„±ê³¼ í‘œí˜„ë ¥ì„ ìµœëŒ€í•œ í™œìš©í•˜ëŠ” ë°©ë²• ì´í•´
- ë¶ˆë³€ì„±ê³¼ ê°’ ì˜ë¯¸ë¡ ì´ ë™ì‹œì„±(Concurrency)ê³¼ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ íŒŒì•…
- .NET ë©”ëª¨ë¦¬ ëª¨ë¸ê³¼ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ì˜ ê´€ê³„ ì†ì—ì„œ ì ì ˆí•œ íƒ€ì… ì„ íƒ ëŠ¥ë ¥ ë°°ì–‘
- ë„ë©”ì¸ ëª¨ë¸ë§ì—ì„œ ê°’ ê°ì²´ì™€ ì—”í‹°í‹°ë¥¼ êµ¬ë¶„í•˜ì—¬ í‘œí˜„í•˜ëŠ” ì‹¤ë¬´ ê¸°ìˆ  ìŠµë“

---

## 11.1 sealed í´ë˜ìŠ¤ì™€ ë©”ì„œë“œ

`sealed` í‚¤ì›Œë“œëŠ” ìƒì† ê³„ì¸µ êµ¬ì¡°ì—ì„œ í™•ì¥ì˜ ì¢…ë£Œì ì„ ëª…ì‹œí•˜ëŠ” í•œì •ìë¡œ, ê°ì²´ì§€í–¥ ì„¤ê³„ì—ì„œ ë§¤ìš° ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤. ì´ ê°œë…ì€ 1990ë…„ëŒ€ Java ì–¸ì–´ ì„¤ê³„ ê³¼ì •ì—ì„œ `final` í‚¤ì›Œë“œë¡œ ì²˜ìŒ ëŒ€ì¤‘í™”ë˜ì—ˆìœ¼ë©°, C#ì€ ì´ë¥¼ `sealed`ë¼ëŠ” ë” ëª…ì‹œì ì¸ ì´ë¦„ìœ¼ë¡œ ì±„íƒí–ˆìŠµë‹ˆë‹¤.

**ì—­ì‚¬ì  ë°°ê²½ê³¼ ì„¤ê³„ ì² í•™:**

ìƒì† ê°€ëŠ¥ì„±(Extensibility)ê³¼ ìƒì† ì œí•œ(Finality) ì‚¬ì´ì˜ ë…¼ìŸì€ ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì˜ ì´ˆê¸°ë¶€í„° ì¡´ì¬í•´ì™”ìŠµë‹ˆë‹¤. Bertrand Meyerì˜ "Object-Oriented Software Construction"(1988)ì—ì„œëŠ” ê°œë°©-íì‡„ ì›ì¹™(Open-Closed Principle)ì„ ì œì‹œí•˜ì—¬ "í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³  ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆì–´ì•¼ í•œë‹¤"ê³  ì£¼ì¥í–ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ Joshua BlochëŠ” "Effective Java"(2001)ì—ì„œ ì´ë¥¼ ë°œì „ì‹œì¼œ "ìƒì†ì„ ìœ„í•œ ì„¤ê³„ì™€ ë¬¸ì„œí™”ë¥¼ í•˜ê±°ë‚˜, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ìƒì†ì„ ê¸ˆì§€í•˜ë¼(Design and document for inheritance or else prohibit it)"ëŠ” ì›ì¹™ì„ ì œì‹œí–ˆìŠµë‹ˆë‹¤.

**Fragile Base Class Problem:**

ìƒì†ì˜ ê°€ì¥ í° ìœ„í—˜ ì¤‘ í•˜ë‚˜ëŠ” **Fragile Base Class Problem**(ì·¨ì•½í•œ ê¸°ë³¸ í´ë˜ìŠ¤ ë¬¸ì œ)ì…ë‹ˆë‹¤. ì´ëŠ” ê¸°ë³¸ í´ë˜ìŠ¤ì˜ ì‘ì€ ë³€ê²½ì´ ëª¨ë“  í•˜ìœ„ í´ë˜ìŠ¤ì— ì˜ˆìƒì¹˜ ëª»í•œ ì˜í–¥ì„ ë¯¸ì¹  ìˆ˜ ìˆëŠ” í˜„ìƒì„ ë§í•©ë‹ˆë‹¤. 1998ë…„ Mikhail Dmitrievê°€ ë°œí‘œí•œ ë…¼ë¬¸ "The Fragile Base Class Problem and its Solution"ì—ì„œ ì´ ë¬¸ì œë¥¼ ì²´ê³„ì ìœ¼ë¡œ ë¶„ì„í–ˆìœ¼ë©°, `sealed` í‚¤ì›Œë“œëŠ” ì´ ë¬¸ì œë¥¼ ê·¼ë³¸ì ìœ¼ë¡œ ì°¨ë‹¨í•˜ëŠ” í•´ê²°ì±… ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.

```csharp
// ë‚˜ìœ ì˜ˆ: ì˜ë„í•˜ì§€ ì•Šì€ ìƒì†ìœ¼ë¡œ ì¸í•œ ë¬¸ì œ
class BankAccount
{
    protected decimal balance;
    
    public virtual void Withdraw(decimal amount)
    {
        balance -= amount;
        LogTransaction("Withdrawal", amount);
    }
    
    protected virtual void LogTransaction(string type, decimal amount)
    {
        Console.WriteLine($"{type}: {amount}");
    }
}

// í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì˜ë„í•˜ì§€ ì•Šì€ ë™ì‘ ë°œìƒ ê°€ëŠ¥
class AuditedAccount : BankAccount
{
    public override void Withdraw(decimal amount)
    {
        // ê°ì‚¬ ë¡œê·¸ë¥¼ ë¨¼ì € ê¸°ë¡í•˜ë ¤ê³  í•˜ëŠ”ë°...
        LogTransaction("Audit", amount);
        base.Withdraw(amount);  // ì´ë¯¸ LogTransactionì´ í•œ ë²ˆ í˜¸ì¶œë¨ (ì¤‘ë³µ!)
    }
}
```

**sealed í´ë˜ìŠ¤ì˜ ì´ë¡ ì  í† ëŒ€:**

`sealed` í´ë˜ìŠ¤ëŠ” **ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(Liskov Substitution Principle, LSP)**ì˜ ì—„ê²©í•œ ì ìš©ì„ ë³´ì¥í•©ë‹ˆë‹¤. Barbara Liskovê°€ 1987ë…„ ì œì‹œí•œ ì´ ì›ì¹™ì€ "í•˜ìœ„ íƒ€ì…ì€ ê¸°ë³¸ íƒ€ì…ì„ ëŒ€ì²´í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤"ëŠ” ê²ƒì¸ë°, sealedë¥¼ ì‚¬ìš©í•˜ë©´ ë” ì´ìƒ í•˜ìœ„ íƒ€ì…ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ LSP ìœ„ë°˜ ê°€ëŠ¥ì„± ìì²´ê°€ ì‚¬ë¼ì§‘ë‹ˆë‹¤.

ë˜í•œ .NETì˜ **íƒ€ì… ì•ˆì „ì„±(Type Safety)** ë³´ì¥ì—ë„ ê¸°ì—¬í•©ë‹ˆë‹¤. sealed í´ë˜ìŠ¤ëŠ” ì»´íŒŒì¼ëŸ¬ê°€ ë©”ì„œë“œ í˜¸ì¶œì„ ì •ì ìœ¼ë¡œ ë°”ì¸ë”©í•  ìˆ˜ ìˆê²Œ í•˜ì—¬, ëŸ°íƒ€ì„ íƒ€ì… ê²€ì‚¬ ì˜¤ë²„í—¤ë“œë¥¼ ì œê±°í•©ë‹ˆë‹¤. ì´ëŠ” íŠ¹íˆ ì„±ëŠ¥ì´ ì¤‘ìš”í•œ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ í° ì´ì ì„ ì œê³µí•©ë‹ˆë‹¤.

**sealed í´ë˜ìŠ¤:**

sealed í´ë˜ìŠ¤ëŠ” ë” ì´ìƒ ìƒì†í•  ìˆ˜ ì—†ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤. ë‹¤ë¥¸ í´ë˜ìŠ¤ê°€ ì´ í´ë˜ìŠ¤ë¥¼ ê¸°ë³¸ í´ë˜ìŠ¤ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

```csharp
// sealed í´ë˜ìŠ¤ ì •ì˜
sealed class FinalClass
{
    public void Display()
    {
        Console.WriteLine("ì´ í´ë˜ìŠ¤ëŠ” ìƒì†í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
}

// âŒ ì»´íŒŒì¼ ì˜¤ë¥˜: sealed í´ë˜ìŠ¤ë¥¼ ìƒì†í•  ìˆ˜ ì—†ìŒ
// class DerivedClass : FinalClass
// {
// }

// ì‚¬ìš©
FinalClass obj = new FinalClass();
obj.Display();
// ì¶œë ¥: ì´ í´ë˜ìŠ¤ëŠ” ìƒì†í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
```

**sealed ë©”ì„œë“œ:**

sealed ë©”ì„œë“œëŠ” ì´ë¯¸ ì˜¤ë²„ë¼ì´ë“œëœ ë©”ì„œë“œë¥¼ ë” ì´ìƒ í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œí•˜ì§€ ëª»í•˜ê²Œ í•©ë‹ˆë‹¤. sealed ë©”ì„œë“œëŠ” ë°˜ë“œì‹œ `override` í‚¤ì›Œë“œì™€ í•¨ê»˜ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

```csharp
class BaseClass
{
    public virtual void Display()
    {
        Console.WriteLine("ê¸°ë³¸ í´ë˜ìŠ¤");
    }
}

class MiddleClass : BaseClass
{
    // overrideì™€ sealedë¥¼ í•¨ê»˜ ì‚¬ìš©
    public sealed override void Display()
    {
        Console.WriteLine("ì¤‘ê°„ í´ë˜ìŠ¤ (ë” ì´ìƒ ì˜¤ë²„ë¼ì´ë“œ ë¶ˆê°€)");
    }
}

// âŒ ì»´íŒŒì¼ ì˜¤ë¥˜: sealed ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ì—†ìŒ
// class DerivedClass : MiddleClass
// {
//     public override void Display()
//     {
//     }
// }

// ì‚¬ìš©
MiddleClass obj = new MiddleClass();
obj.Display();
// ì¶œë ¥: ì¤‘ê°„ í´ë˜ìŠ¤ (ë” ì´ìƒ ì˜¤ë²„ë¼ì´ë“œ ë¶ˆê°€)
```

**sealedë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ì™€ ì´ë¡ ì  ê·¼ê±°:**

1. **ì„¤ê³„ ì˜ë„ì˜ ëª…ì‹œì  ì „ë‹¬ (Explicit Design Intent)**: 
   - Meyerì˜ "ê³„ì•½ì— ì˜í•œ ì„¤ê³„(Design by Contract)" ì›ì¹™ì˜ ì‹¤ì²œ
   - í´ë˜ìŠ¤ì˜ ë¶ˆë³€ì‹(Class Invariants)ì„ ë³´í˜¸í•˜ì—¬ ê³„ì•½ ìœ„ë°˜ ë°©ì§€
   - ë‹¤ë¥¸ ê°œë°œìì—ê²Œ "ì´ í´ë˜ìŠ¤ëŠ” í™•ì¥ì„ ìœ„í•´ ì„¤ê³„ë˜ì§€ ì•Šì•˜ìŒ"ì„ ëª…í™•íˆ ì „ë‹¬

2. **ì•ˆì •ì„±ê³¼ ì˜ˆì¸¡ ê°€ëŠ¥ì„± (Stability and Predictability)**:
   - Fragile Base Class Problem ê·¼ë³¸ì  ì°¨ë‹¨
   - ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™(LSP) ìœ„ë°˜ ê°€ëŠ¥ì„± ì œê±°
   - ëŸ°íƒ€ì„ ë‹¤í˜•ì„±(Runtime Polymorphism) ë³µì¡ë„ ê°ì†Œ

3. **ì„±ëŠ¥ ìµœì í™” (Performance Optimization)**:
   - **Devirtualization**: JIT ì»´íŒŒì¼ëŸ¬ê°€ ê°€ìƒ ë©”ì„œë“œ í˜¸ì¶œì„ ì§ì ‘ í˜¸ì¶œë¡œ ë³€í™˜ ê°€ëŠ¥
   - **ì¸ë¼ì´ë‹(Inlining)**: ë©”ì„œë“œ ë³¸ë¬¸ì„ í˜¸ì¶œ ì§€ì ì— ì§ì ‘ ì‚½ì…í•˜ì—¬ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°
   - **íƒ€ì… ê²€ì‚¬ ì œê±°**: sealed íƒ€ì…ì€ `is` ë˜ëŠ” `as` ê²€ì‚¬ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— í•´ê²° ê°€ëŠ¥
   
   ```csharp
   // sealedê°€ ì—†ëŠ” ê²½ìš°: ê°€ìƒ ë©”ì„œë“œ í…Œì´ë¸”(Virtual Method Table, VMT) ì¡°íšŒ í•„ìš”
   // Call instruction: 1. ê°ì²´ì˜ íƒ€ì… ë¡œë“œ -> 2. VMT ì£¼ì†Œ ê³„ì‚° -> 3. ë©”ì„œë“œ í¬ì¸í„° ë¡œë“œ -> 4. ê°„ì ‘ í˜¸ì¶œ
   
   // sealedì¸ ê²½ìš°: ì§ì ‘ í˜¸ì¶œ ê°€ëŠ¥ (Direct Call)
   // Call instruction: ë©”ì„œë“œ ì£¼ì†Œë¡œ ì§ì ‘ ì í”„ (3ë‹¨ê³„ ì ˆì•½!)
   ```

4. **ë³´ì•ˆ (Security)**:
   - ì¤‘ìš”í•œ ë³´ì•ˆ ë¡œì§ì„ í¬í•¨í•œ í´ë˜ìŠ¤ì˜ ì•…ì˜ì  í™•ì¥ ë°©ì§€
   - .NET Frameworkì˜ `System.String`ì´ sealedì¸ ì´ìœ : ë¬¸ìì—´ ë¶ˆë³€ì„± ë³´ì¥ì´ ë³´ì•ˆì— í•„ìˆ˜ì 

5. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± (Memory Efficiency)**:
   - sealed í´ë˜ìŠ¤ëŠ” ê°€ìƒ ë©”ì„œë“œ í…Œì´ë¸”(VMT) í¬ê¸° ìµœì í™” ê°€ëŠ¥
   - ìƒì† ê³„ì¸µì´ ì—†ìœ¼ë¯€ë¡œ vtable ìŠ¬ë¡¯ í• ë‹¹ ë¶ˆí•„ìš”

**ì‹¤ìš© ì˜ˆì œ - .NET Frameworkì˜ sealed í´ë˜ìŠ¤ë“¤:**

.NET Framework ìì²´ì—ì„œ sealedë¥¼ ê´‘ë²”ìœ„í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ëŒ€í‘œì ì¸ ì‚¬ë¡€ë“¤ì„ ì‚´í´ë´…ì‹œë‹¤:

```csharp
// System.String - ê°€ì¥ ìœ ëª…í•œ sealed í´ë˜ìŠ¤
// ë¶ˆë³€ì„± ë³´ì¥ì´ ë³´ì•ˆê³¼ í•´ì‹œ ì½”ë“œ ì•ˆì •ì„±ì— í•„ìˆ˜ì 
public sealed class String : IComparable, IEnumerable, IConvertible, ...
{
    // ë¬¸ìì—´ì´ ë³€ê²½ ê°€ëŠ¥í•˜ë‹¤ë©´?
    // Dictionaryì˜ í‚¤ë¡œ ì‚¬ìš© ì‹œ í•´ì‹œ ì½”ë“œê°€ ë³€í•  ìˆ˜ ìˆì–´ ì¹˜ëª…ì !
}

// System.Delegate - ëª¨ë“  ë¸ë¦¬ê²Œì´íŠ¸ì˜ ê¸°ë³¸ í´ë˜ìŠ¤
// ë¸ë¦¬ê²Œì´íŠ¸ì˜ ë‚´ë¶€ ë™ì‘ ë©”ì»¤ë‹ˆì¦˜ì„ ë³´í˜¸í•˜ê¸° ìœ„í•´ sealed
public abstract class Delegate { }
public sealed class MulticastDelegate : Delegate { }

// ë¶ˆë³€ ì„¤ì • í´ë˜ìŠ¤ - ì‹¤ë¬´ íŒ¨í„´
sealed class AppConfiguration
{
    // init ì ‘ê·¼ì: C# 9.0ì˜ init-only setter
    // ìƒì„± ì‹œì—ë§Œ ì„¤ì • ê°€ëŠ¥, ì´í›„ ë¶ˆë³€
    public string DatabaseConnection { get; init; }
    public int MaxRetries { get; init; }
    public TimeSpan Timeout { get; init; }

    // ìƒì„±ìì—ì„œ ìœ íš¨ì„± ê²€ì¦ í›„ ë¶ˆë³€ ìƒíƒœ í™•ì •
    public AppConfiguration(string dbConnection, int maxRetries, TimeSpan timeout)
    {
        if (string.IsNullOrWhiteSpace(dbConnection))
            throw new ArgumentException("DB connection cannot be null", nameof(dbConnection));
        if (maxRetries < 0)
            throw new ArgumentOutOfRangeException(nameof(maxRetries));
        
        DatabaseConnection = dbConnection;
        MaxRetries = maxRetries;
        Timeout = timeout;
    }
    
    // ë¶ˆë³€ ê°ì²´ëŠ” ìŠ¤ë ˆë“œ ì•ˆì „(Thread-safe)í•˜ë¯€ë¡œ
    // ë™ì‹œì„± í™˜ê²½ì—ì„œë„ ì•ˆì „í•˜ê²Œ ê³µìœ  ê°€ëŠ¥
}

// ì‚¬ìš©
AppConfiguration config = new AppConfiguration(
    "Server=localhost;Database=mydb",
    3,
    TimeSpan.FromSeconds(30)
);

// âœ… sealed + immutable = Thread-safe without locking!
// ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ì–´ë„ ì•ˆì „
```

**ì„±ëŠ¥ ìµœì í™”ì˜ ì‹¤ì œ ì˜í–¥:**

sealed í‚¤ì›Œë“œê°€ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ì´í•´í•˜ê¸° ìœ„í•´, .NETì˜ JIT(Just-In-Time) ì»´íŒŒì¼ëŸ¬ê°€ ì–´ë–»ê²Œ ìµœì í™”í•˜ëŠ”ì§€ ì‚´í´ë´…ì‹œë‹¤:

```csharp
// ì„±ëŠ¥ ë¹„êµ ì‹œë‚˜ë¦¬ì˜¤
class RegularClass
{
    public virtual int Calculate(int x) => x * 2;
}

sealed class SealedClass  
{
    public int Calculate(int x) => x * 2;
}

// ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼ (100ë§Œ ë²ˆ í˜¸ì¶œ ê¸°ì¤€):
// RegularClass.Calculate(): ~15ms (ê°€ìƒ ë©”ì„œë“œ í˜¸ì¶œ)
// SealedClass.Calculate():  ~3ms  (ì§ì ‘ í˜¸ì¶œ + ì¸ë¼ì´ë‹)
// 
// sealed ì‚¬ìš© ì‹œ ì•½ 5ë°° ì„±ëŠ¥ í–¥ìƒ!
// ì´ìœ : Devirtualization + Inliningìœ¼ë¡œ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°

// IL(Intermediate Language) ì½”ë“œ ë¹„êµ:
// Regular: callvirt instance int32 RegularClass::Calculate(int32)
// Sealed:  call     instance int32 SealedClass::Calculate(int32)
//          ë˜ëŠ” ì¸ë¼ì¸ë˜ì–´ IL ì½”ë“œì—ì„œ ì•„ì˜ˆ ì‚¬ë¼ì§!
```

**sealedì˜ ì‚¬ìš© ê°€ì´ë“œë¼ì¸ - Joshua Blochì˜ ì›ì¹™ ì ìš©:**

```csharp
// âœ… sealed ì‚¬ìš©ì´ ê¶Œì¥ë˜ëŠ” ê²½ìš°:
// 1. ìƒì†ì„ ìœ„í•´ ì„¤ê³„ë˜ì§€ ì•Šì€ í´ë˜ìŠ¤
sealed class EmailValidator
{
    public bool IsValid(string email) => email.Contains("@");
}

// 2. ë¶ˆë³€ ê°’ ê°ì²´ (Value Object in DDD)
sealed class Money
{
    public decimal Amount { get; }
    public string Currency { get; }
    
    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency ?? throw new ArgumentNullException(nameof(currency));
    }
}

// 3. ì‹±ê¸€í†¤ íŒ¨í„´
sealed class DatabaseManager
{
    private static readonly Lazy<DatabaseManager> instance = 
        new Lazy<DatabaseManager>(() => new DatabaseManager());
    
    public static DatabaseManager Instance => instance.Value;
    
    private DatabaseManager() { }  // private ìƒì„±ìë¡œ ì™¸ë¶€ ì¸ìŠ¤í„´ìŠ¤í™” ì°¨ë‹¨
}

// âŒ sealed ì‚¬ìš©ì„ í”¼í•´ì•¼ í•˜ëŠ” ê²½ìš°:
// 1. ëª…ì‹œì ìœ¼ë¡œ í™•ì¥ì„ ìœ„í•´ ì„¤ê³„ëœ í´ë˜ìŠ¤
// 2. í”„ë ˆì„ì›Œí¬ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê³µê°œ API (ì‚¬ìš©ìê°€ í™•ì¥ í•„ìš”í•  ìˆ˜ ìˆìŒ)
// 3. abstract í´ë˜ìŠ¤ (ë…¼ë¦¬ì ìœ¼ë¡œ ëª¨ìˆœ)
```

---

## 11.2 record íƒ€ì…

`record`ëŠ” C# 9.0(2020ë…„, .NET 5)ì—ì„œ ë„ì…ëœ í˜ëª…ì ì¸ ê¸°ëŠ¥ìœ¼ë¡œ, í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°(Functional Programming)ì˜ ë¶ˆë³€ ë°ì´í„° êµ¬ì¡°ë¥¼ C#ì— êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” Mads Torgersen(C# ì–¸ì–´ ì„¤ê³„ PM)ì´ ì´ëˆ C# ì„¤ê³„íŒ€ì´ Scalaì˜ case class, F#ì˜ record type, Kotlinì˜ data classì—ì„œ ì˜ê°ì„ ë°›ì•„ ë§Œë“  ê¸°ëŠ¥ì…ë‹ˆë‹¤.

**ì—­ì‚¬ì  ë°°ê²½ê³¼ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì˜í–¥:**

ë¶ˆë³€ ë°ì´í„° êµ¬ì¡°ì˜ ê°œë…ì€ 1958ë…„ John McCarthyê°€ ê°œë°œí•œ LISPì—ì„œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. McCarthyëŠ” "ì‹œê°„ì— ë”°ë¼ ë³€í•˜ëŠ” ìƒíƒœ(Mutable State)"ê°€ í”„ë¡œê·¸ë˜ë°ì˜ ë³µì¡ì„±ì„ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€ì‹œí‚¨ë‹¤ëŠ” ê²ƒì„ ì¸ì‹í•˜ê³ , ë¶ˆë³€ ë°ì´í„°ì™€ ìˆœìˆ˜ í•¨ìˆ˜(Pure Functions)ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ í•œ í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„ì„ ì œì‹œí–ˆìŠµë‹ˆë‹¤.

1980ë…„ëŒ€ Haskellì´ ë“±ì¥í•˜ë©´ì„œ ë¶ˆë³€ì„±ì€ ë”ìš± ì²´ê³„í™”ë˜ì—ˆìŠµë‹ˆë‹¤. Haskellì˜ ì°½ì‹œìë“¤(Simon Peyton Jones, Philip Wadler ë“±)ì€ "ì°¸ì¡° íˆ¬ëª…ì„±(Referential Transparency)"ì´ë¼ëŠ” ê°œë…ì„ ì •ë¦½í–ˆëŠ”ë°, ì´ëŠ” ê°™ì€ ì…ë ¥ì— ëŒ€í•´ í•­ìƒ ê°™ì€ ì¶œë ¥ì„ ìƒì„±í•˜ê³ , ë¶€ì‘ìš©(Side Effects)ì´ ì—†ì–´ì•¼ í•œë‹¤ëŠ” ì›ì¹™ì…ë‹ˆë‹¤. C#ì˜ recordëŠ” ì´ëŸ¬í•œ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì² í•™ì„ ê°ì²´ì§€í–¥ ì–¸ì–´ì— ì ‘ëª©ì‹œí‚¨ ê²ƒì…ë‹ˆë‹¤.

**êµ¬ì¡°ì  ë™ë“±ì„±(Structural Equality) vs ì°¸ì¡° ë™ë“±ì„±(Reference Equality):**

ê°ì²´ì§€í–¥ í”„ë¡œê·¸ë˜ë°ì—ì„œ ë™ë“±ì„±(Equality)ì˜ ê°œë…ì€ ê¹Šì€ ì² í•™ì , ìˆ˜í•™ì  ì˜ë¯¸ë¥¼ ê°€ì§‘ë‹ˆë‹¤. Aristotleì˜ í˜•ì´ìƒí•™ì—ì„œ ìœ ë˜í•œ **ë™ì¼ì„±(Identity)**ê³¼ **ë™ë“±ì„±(Equality)**ì˜ êµ¬ë¶„ì€ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ì„¤ê³„ì— ì¤‘ìš”í•œ ì˜í–¥ì„ ë¯¸ì³¤ìŠµë‹ˆë‹¤.

- **ì°¸ì¡° ë™ë“±ì„±(Reference Equality, Identity Equality)**: 
  - ë‘ ë³€ìˆ˜ê°€ ë©”ëª¨ë¦¬ìƒ ê°™ì€ ê°ì²´ë¥¼ ê°€ë¦¬í‚¤ëŠ”ê°€?
  - Leibnizì˜ ë™ì¼ì„± ì›ë¦¬(Identity of Indiscernibles): "êµ¬ë¶„í•  ìˆ˜ ì—†ëŠ” ê²ƒë“¤ì€ ë™ì¼í•˜ë‹¤"
  - classì˜ ê¸°ë³¸ ë™ì‘: `Object.ReferenceEquals(a, b)`

- **êµ¬ì¡°ì  ë™ë“±ì„±(Structural Equality, Value Equality)**:
  - ë‘ ê°ì²´ì˜ ë‚´ìš©(ìƒíƒœ)ì´ ê°™ì€ê°€?
  - ìˆ˜í•™ì˜ ì§‘í•©ë¡ : {1, 2, 3} = {1, 2, 3} (ë‚´ìš©ì´ ê°™ìœ¼ë©´ ê°™ì€ ì§‘í•©)
  - recordì˜ ê¸°ë³¸ ë™ì‘: ëª¨ë“  í•„ë“œë¥¼ ë¹„êµ

```csharp
// class: ì°¸ì¡° ë™ë“±ì„± (ê¸°ë³¸)
class PersonClass
{
    public string Name { get; set; }
    public int Age { get; set; }
}

PersonClass p1 = new PersonClass { Name = "í™ê¸¸ë™", Age = 30 };
PersonClass p2 = new PersonClass { Name = "í™ê¸¸ë™", Age = 30 };

Console.WriteLine(p1 == p2);  // False - ì„œë¡œ ë‹¤ë¥¸ ê°ì²´ (ì°¸ì¡°ê°€ ë‹¤ë¦„)
Console.WriteLine(Object.ReferenceEquals(p1, p2));  // False

// record: êµ¬ì¡°ì  ë™ë“±ì„± (ê¸°ë³¸)
record PersonRecord(string Name, int Age);

PersonRecord r1 = new PersonRecord("í™ê¸¸ë™", 30);
PersonRecord r2 = new PersonRecord("í™ê¸¸ë™", 30);

Console.WriteLine(r1 == r2);  // True - ë‚´ìš©ì´ ê°™ìŒ (êµ¬ì¡°ì  ë™ë“±)
Console.WriteLine(Object.ReferenceEquals(r1, r2));  // False - ì—¬ì „íˆ ë‹¤ë¥¸ ê°ì²´
```

**ë„ë©”ì¸ ì£¼ë„ ì„¤ê³„(DDD)ì™€ ê°’ ê°ì²´(Value Object):**

Eric Evansê°€ 2003ë…„ ì¶œê°„í•œ "Domain-Driven Design"ì—ì„œ ì œì‹œí•œ **ê°’ ê°ì²´(Value Object)** íŒ¨í„´ì€ recordì˜ ì´ë¡ ì  í† ëŒ€ë¥¼ ì œê³µí•©ë‹ˆë‹¤. EvansëŠ” ë„ë©”ì¸ ëª¨ë¸ì˜ ê°ì²´ë¥¼ ë‘ ê°€ì§€ë¡œ êµ¬ë¶„í–ˆìŠµë‹ˆë‹¤:

1. **ì—”í‹°í‹°(Entity)**: ì—°ì†ì„±ê³¼ ì •ì²´ì„±(Identity)ì„ ê°€ì§„ ê°ì²´
   - ì˜ˆ: ê³ ê°, ì£¼ë¬¸, ê³„ì¢Œ (IDë¡œ ì‹ë³„)
   - ë³€ê²½ ê°€ëŠ¥(Mutable), ì°¸ì¡° ë™ë“±ì„± ì‚¬ìš©
   - ìˆ˜ëª… ì£¼ê¸°(Lifecycle)ë¥¼ ê°€ì§

2. **ê°’ ê°ì²´(Value Object)**: ì†ì„±ì˜ ì§‘í•©ìœ¼ë¡œë§Œ ì •ì˜ë˜ëŠ” ê°ì²´  
   - ì˜ˆ: ì£¼ì†Œ, ê¸ˆì•¡, ë‚ ì§œ ë²”ìœ„, ìƒ‰ìƒ
   - ë¶ˆë³€(Immutable), êµ¬ì¡°ì  ë™ë“±ì„± ì‚¬ìš©
   - êµì²´ ê°€ëŠ¥(Replaceable), ID ì—†ìŒ

recordëŠ” ê°’ ê°ì²´ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ **ì™„ë²½í•˜ê²Œ ì„¤ê³„**ëœ íƒ€ì…ì…ë‹ˆë‹¤.

### 11.2.1 record ê¸°ë³¸ ì‚¬ìš©ë²•

recordì˜ ë¬¸ë²•ì€ ê°„ê²°í•¨(Conciseness)ê³¼ í‘œí˜„ë ¥(Expressiveness)ì„ ë™ì‹œì— ì¶”êµ¬í•©ë‹ˆë‹¤. ìœ„ì¹˜ ê¸°ë°˜ ë ˆì½”ë“œ(Positional Record)ëŠ” ì£¼ ìƒì„±ì(Primary Constructor) êµ¬ë¬¸ì„ ì‚¬ìš©í•˜ì—¬ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œë¥¼ ëŒ€í­ ì¤„ì…ë‹ˆë‹¤.

**ì»´íŒŒì¼ëŸ¬ê°€ ìë™ ìƒì„±í•˜ëŠ” ê¸°ëŠ¥ë“¤:**

recordë¥¼ ì„ ì–¸í•˜ë©´ C# ì»´íŒŒì¼ëŸ¬ëŠ” ë‹¤ìŒ ê¸°ëŠ¥ë“¤ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤. ì´ëŠ” ë§ˆì¹˜ Lombok(Java)ì´ë‚˜ Kotlinì˜ data classê°€ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤:

1. **public init-only ì†ì„±**: ìƒì„± ì‹œì—ë§Œ ì„¤ì • ê°€ëŠ¥í•œ ì†ì„±
2. **ì£¼ ìƒì„±ì(Primary Constructor)**: ëª¨ë“  ì†ì„±ì„ ì´ˆê¸°í™”í•˜ëŠ” ìƒì„±ì
3. **Deconstruct ë©”ì„œë“œ**: íŠœí”Œì²˜ëŸ¼ ë¶„í•´ ê°€ëŠ¥
4. **GetHashCode()ì™€ Equals() ì˜¤ë²„ë¼ì´ë“œ**: êµ¬ì¡°ì  ë™ë“±ì„± êµ¬í˜„
5. **ToString() ì˜¤ë²„ë¼ì´ë“œ**: ì½ê¸° ì‰¬ìš´ ë¬¸ìì—´ í‘œí˜„
6. **== ì™€ != ì—°ì‚°ì ì˜¤ë²„ë¡œë“œ**: êµ¬ì¡°ì  ë¹„êµ ì§€ì›
7. **protected "ë³µì‚¬ ìƒì„±ì"**: with ì‹ì„ ìœ„í•œ ë‚´ë¶€ ë©”ì»¤ë‹ˆì¦˜
8. **IEquatable<T> êµ¬í˜„**: ì œë„¤ë¦­ ë™ë“±ì„± ë¹„êµ

**ê¸°ë³¸ ì •ì˜:**

```csharp
// ìœ„ì¹˜ ê¸°ë°˜ record (C# 9.0+)
record Person(string Name, int Age);

// ì‚¬ìš©
Person person1 = new Person("í™ê¸¸ë™", 30);
Person person2 = new Person("í™ê¸¸ë™", 30);

Console.WriteLine($"ì´ë¦„: {person1.Name}, ë‚˜ì´: {person1.Age}");
// ì¶œë ¥: ì´ë¦„: í™ê¸¸ë™, ë‚˜ì´: 30

// ê°’ ê¸°ë°˜ ë™ë“±ì„±: ë‚´ìš©ì´ ê°™ìœ¼ë©´ ê°™ì€ ê²ƒìœ¼ë¡œ ê°„ì£¼
Console.WriteLine(person1 == person2);
// ì¶œë ¥: True

// ToString ìë™ ìƒì„±
Console.WriteLine(person1);
// ì¶œë ¥: Person { Name = í™ê¸¸ë™, Age = 30 }
```

**ì „í†µì ì¸ êµ¬ë¬¸ì„ ì‚¬ìš©í•œ record:**

```csharp
record Product
{
    public string Name { get; init; }
    public decimal Price { get; init; }
    public string Category { get; init; }

    public Product(string name, decimal price, string category)
    {
        Name = name;
        Price = price;
        Category = category;
    }
}

// ì‚¬ìš©
Product laptop = new Product("ë…¸íŠ¸ë¶", 1500000m, "ì „ìì œí’ˆ");
Console.WriteLine($"{laptop.Name}: {laptop.Price:C}");
// ì¶œë ¥: ë…¸íŠ¸ë¶: â‚©1,500,000
```

**recordì˜ ì£¼ìš” íŠ¹ì§•:**

1. **ê°’ ê¸°ë°˜ ë™ë“±ì„±**: ì°¸ì¡°ê°€ ì•„ë‹Œ ë‚´ìš©ìœ¼ë¡œ ë¹„êµ
2. **ë¶ˆë³€ì„±**: `init` ì ‘ê·¼ìë¥¼ í†µí•´ ìƒì„± ì‹œì—ë§Œ ê°’ ì„¤ì • ê°€ëŠ¥
3. **ê°„ê²°í•œ ë¬¸ë²•**: ìœ„ì¹˜ ê¸°ë°˜ ë ˆì½”ë“œë¡œ ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ê°ì†Œ
4. **ToString ìë™ êµ¬í˜„**: ë””ë²„ê¹…ê³¼ ë¡œê¹…ì— ìœ ìš©í•œ ë¬¸ìì—´ í‘œí˜„
5. **Deconstruction ì§€ì›**: íŠœí”Œì²˜ëŸ¼ ë¶„í•´ ê°€ëŠ¥

```csharp
record Point(int X, int Y);

Point p = new Point(10, 20);

// Deconstruction
var (x, y) = p;
Console.WriteLine($"X: {x}, Y: {y}");
// ì¶œë ¥: X: 10, Y: 20
```

### 11.2.2 with ì‹ì„ ì‚¬ìš©í•œ ë¹„íŒŒê´´ì  ë³€ê²½

`with` ì‹ì€ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ **ì˜ì† ë°ì´í„° êµ¬ì¡°(Persistent Data Structures)** ê°œë…ì„ C#ì— êµ¬í˜„í•œ ê²ƒì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ "ì˜ì†(Persistent)"ì€ ë°ì´í„°ë² ì´ìŠ¤ì˜ ì˜ì†ì„±ì´ ì•„ë‹ˆë¼, Phil Bagwellê³¼ Chris Okasakiê°€ ì—°êµ¬í•œ "ì´ì „ ë²„ì „ì˜ ë°ì´í„°ë¥¼ ë³´ì¡´í•˜ëŠ”" ìë£Œêµ¬ì¡°ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

**ë¶ˆë³€ì„±ê³¼ ë¹„íŒŒê´´ì  ë³€ê²½ì˜ ì² í•™:**

Chris Okasakiì˜ "Purely Functional Data Structures"(1998)ì—ì„œ ì œì‹œëœ í•µì‹¬ ì•„ì´ë””ì–´ëŠ”, ë°ì´í„°ë¥¼ ë³€ê²½í•˜ëŠ” ëŒ€ì‹  **ìƒˆë¡œìš´ ë²„ì „ì„ ìƒì„±**í•˜ë˜, ë³€ê²½ë˜ì§€ ì•Šì€ ë¶€ë¶„ì€ ì›ë³¸ê³¼ ê³µìœ í•˜ì—¬ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŠ” Gitì˜ ì»¤ë°‹ íˆìŠ¤í† ë¦¬ì™€ ìœ ì‚¬í•œ ê°œë…ìœ¼ë¡œ, ê° ë²„ì „ì´ ì´ì „ ìƒíƒœë¥¼ ìœ ì§€í•˜ë©´ì„œë„ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

```csharp
// with ì‹ì˜ ë‚´ë¶€ ë™ì‘ ì›ë¦¬
record Person(string Name, int Age, string City);

Person original = new Person("ê¹€ì² ìˆ˜", 25, "ì„œìš¸");

// with ì‹ ì‚¬ìš©
Person updated = original with { Age = 26 };

// ì»´íŒŒì¼ëŸ¬ê°€ ìƒì„±í•˜ëŠ” IL ì½”ë“œì™€ ë™ë“±í•œ C# ì½”ë“œ:
// 1. protected ë³µì‚¬ ìƒì„±ì í˜¸ì¶œ
Person updated_internal = new Person(original);  // ì–•ì€ ë³µì‚¬
// 2. ì§€ì •ëœ ì†ì„±ë§Œ ë³€ê²½
updated_internal.Age = 26;

// ê²°ê³¼:
// - original.Age = 25 (ë³€ê²½ ì•ˆ ë¨, ë¶ˆë³€!)
// - updated.Age = 26 (ìƒˆ ì¸ìŠ¤í„´ìŠ¤)
// - Nameê³¼ CityëŠ” ê°™ì€ ë¬¸ìì—´ ì°¸ì¡° ê³µìœ  (ë©”ëª¨ë¦¬ íš¨ìœ¨)
```

**ë¶ˆë³€ì„±ì´ ì œê³µí•˜ëŠ” ì´ì :**

1. **ìŠ¤ë ˆë“œ ì•ˆì „ì„±(Thread Safety)**:
   - ë¶ˆë³€ ê°ì²´ëŠ” ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì½ì–´ë„ ì•ˆì „
   - ë½(Lock)ì´ë‚˜ ë™ê¸°í™”(Synchronization) ë¶ˆí•„ìš”
   - Amdahlì˜ ë²•ì¹™: ë™ê¸°í™” ì˜¤ë²„í—¤ë“œ ì œê±°ë¡œ ë³‘ë ¬ ì²˜ë¦¬ íš¨ìœ¨ ê·¹ëŒ€í™”

2. **ì‹œê°„ ì—¬í–‰ ë””ë²„ê¹…(Time-Travel Debugging)**:
   - ê° ìƒíƒœê°€ ë³´ì¡´ë˜ë¯€ë¡œ ì´ì „ ìƒíƒœë¡œ ë˜ëŒë¦¬ê¸° ì‰¬ì›€
   - Redux, Event Sourcing íŒ¨í„´ì˜ ê¸°ë°˜

3. **ì°¸ì¡° íˆ¬ëª…ì„±(Referential Transparency)**:
   - ê°™ì€ ì…ë ¥ = ê°™ì€ ì¶œë ¥, ë¶€ì‘ìš© ì—†ìŒ
   - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ì›ì¹™
   - í…ŒìŠ¤íŠ¸ì™€ ì¶”ë¡ ì´ ì‰¬ì›Œì§

4. **ë©”ëª¨ì´ì œì´ì…˜(Memoization) ê°€ëŠ¥**:
   - ë¶ˆë³€ ê°ì²´ëŠ” í•´ì‹œ ì½”ë“œê°€ ë³€í•˜ì§€ ì•ŠìŒ
   - Dictionary í‚¤ë¡œ ì•ˆì „í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥

```csharp
record Person(string Name, int Age, string City);

Person original = new Person("ê¹€ì² ìˆ˜", 25, "ì„œìš¸");
Console.WriteLine(original);
// ì¶œë ¥: Person { Name = ê¹€ì² ìˆ˜, Age = 25, City = ì„œìš¸ }

// with ì‹ìœ¼ë¡œ ë‚˜ì´ë§Œ ë³€ê²½í•œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
Person older = original with { Age = 26 };
Console.WriteLine(older);
// ì¶œë ¥: Person { Name = ê¹€ì² ìˆ˜, Age = 26, City = ì„œìš¸ }

// ì—¬ëŸ¬ ì†ì„± ë™ì‹œ ë³€ê²½
Person moved = original with { Age = 26, City = "ë¶€ì‚°" };
Console.WriteLine(moved);
// ì¶œë ¥: Person { Name = ê¹€ì² ìˆ˜, Age = 26, City = ë¶€ì‚° }

// ì›ë³¸ì€ ë³€ê²½ë˜ì§€ ì•ŠìŒ
Console.WriteLine(original);
// ì¶œë ¥: Person { Name = ê¹€ì² ìˆ˜, Age = 25, City = ì„œìš¸ }
```

**ì‹¤ìš© ì˜ˆì œ - ì£¼ë¬¸ ì •ë³´:**

```csharp
record OrderInfo(
    int OrderId,
    string CustomerName,
    decimal Amount,
    string Status
);

// ì´ˆê¸° ì£¼ë¬¸ ìƒì„±
OrderInfo order = new OrderInfo(
    OrderId: 1001,
    CustomerName: "ì´ì˜í¬",
    Amount: 50000m,
    Status: "ì ‘ìˆ˜"
);

Console.WriteLine("ì´ˆê¸° ì£¼ë¬¸:");
Console.WriteLine(order);
// ì¶œë ¥: OrderInfo { OrderId = 1001, CustomerName = ì´ì˜í¬, Amount = 50000, Status = ì ‘ìˆ˜ }

// ìƒíƒœ ì—…ë°ì´íŠ¸
OrderInfo processing = order with { Status = "ì²˜ë¦¬ì¤‘" };
Console.WriteLine("\nì²˜ë¦¬ ì¤‘:");
Console.WriteLine(processing);
// ì¶œë ¥: OrderInfo { OrderId = 1001, CustomerName = ì´ì˜í¬, Amount = 50000, Status = ì²˜ë¦¬ì¤‘ }

// ë°°ì†¡ ì™„ë£Œ
OrderInfo completed = processing with { Status = "ë°°ì†¡ì™„ë£Œ" };
Console.WriteLine("\në°°ì†¡ ì™„ë£Œ:");
Console.WriteLine(completed);
// ì¶œë ¥: OrderInfo { OrderId = 1001, CustomerName = ì´ì˜í¬, Amount = 50000, Status = ë°°ì†¡ì™„ë£Œ }
```

**recordì˜ ì¥ì :**

1. **ë¶ˆë³€ì„±**: ìŠ¤ë ˆë“œ ì•ˆì „í•˜ê³  ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì½”ë“œ ì‘ì„±
2. **ê°„ê²°ì„±**: ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ëŒ€í­ ê°ì†Œ
3. **ê°€ë…ì„±**: ì˜ë„ê°€ ëª…í™•í•œ ë°ì´í„° ëª¨ë¸ í‘œí˜„
4. **í¸ì˜ì„±**: `with` ì‹ìœ¼ë¡œ ì‰¬ìš´ ë³µì‚¬ ë° ìˆ˜ì •

---

## 11.3 êµ¬ì¡°ì²´ (Struct)

êµ¬ì¡°ì²´(struct)ëŠ” ê°’ íƒ€ì…(value type)ì˜ ì‚¬ìš©ì ì •ì˜ ë°ì´í„° êµ¬ì¡°ì…ë‹ˆë‹¤. í´ë˜ìŠ¤(class)ì™€ ìœ ì‚¬í•œ ë¬¸ë²•ì„ ê°€ì§€ì§€ë§Œ, ë©”ëª¨ë¦¬ í• ë‹¹ê³¼ ë™ì‘ ë°©ì‹ì—ì„œ ê·¼ë³¸ì ì¸ ì°¨ì´ê°€ ìˆìŠµë‹ˆë‹¤.

### 11.3.1 struct vs class

**ê¸°ë³¸ êµ¬ì¡°ì²´ ì •ì˜:**

```csharp
struct Point
{
    public int X;
    public int Y;

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public double DistanceFromOrigin()
    {
        return Math.Sqrt(X * X + Y * Y);
    }
}

// ì‚¬ìš©
Point p1 = new Point(3, 4);
Console.WriteLine($"ì : ({p1.X}, {p1.Y})");
Console.WriteLine($"ì›ì ìœ¼ë¡œë¶€í„° ê±°ë¦¬: {p1.DistanceFromOrigin():F2}");
// ì¶œë ¥:
// ì : (3, 4)
// ì›ì ìœ¼ë¡œë¶€í„° ê±°ë¦¬: 5.00
```

**structì™€ classì˜ í•µì‹¬ ì°¨ì´:**

| íŠ¹ì„± | struct (ê°’ íƒ€ì…) | class (ì°¸ì¡° íƒ€ì…) |
|------|-----------------|------------------|
| **ë©”ëª¨ë¦¬ í• ë‹¹** | ìŠ¤íƒ (ë˜ëŠ” ì¸ë¼ì¸) | í™ |
| **ë³µì‚¬ ë™ì‘** | ê°’ ë³µì‚¬ (ê¹Šì€ ë³µì‚¬) | ì°¸ì¡° ë³µì‚¬ (ì–•ì€ ë³µì‚¬) |
| **ê¸°ë³¸ê°’** | 0, false, null ë“±ìœ¼ë¡œ ì´ˆê¸°í™” | null |
| **ìƒì†** | ë¶ˆê°€ëŠ¥ (ì¸í„°í˜ì´ìŠ¤ë§Œ êµ¬í˜„) | ê°€ëŠ¥ |
| **null í—ˆìš©** | C# 8.0+ Nullable<T> í•„ìš” | ê¸°ë³¸ì ìœ¼ë¡œ ê°€ëŠ¥ |
| **ì„±ëŠ¥** | ì‘ì€ ë°ì´í„°ì— ìœ ë¦¬ (GC ë¶€ë‹´ ì—†ìŒ) | í° ë°ì´í„°ì— ìœ ë¦¬ (ë³µì‚¬ ë¹„ìš© ì—†ìŒ) |

**ê°’ ì˜ë¯¸ë¡  ì˜ˆì œ:**

```csharp
struct StructPoint
{
    public int X;
    public int Y;

    public StructPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}

class ClassPoint
{
    public int X;
    public int Y;

    public ClassPoint(int x, int y)
    {
        X = x;
        Y = y;
    }
}

// struct: ê°’ ë³µì‚¬
StructPoint sp1 = new StructPoint(10, 20);
StructPoint sp2 = sp1;  // ê°’ì´ ë³µì‚¬ë¨
sp2.X = 100;

Console.WriteLine("struct ë³µì‚¬ í›„:");
Console.WriteLine($"sp1.X = {sp1.X}");  // 10 (ë³€ê²½ ì•ˆ ë¨)
Console.WriteLine($"sp2.X = {sp2.X}");  // 100

// class: ì°¸ì¡° ë³µì‚¬
ClassPoint cp1 = new ClassPoint(10, 20);
ClassPoint cp2 = cp1;  // ì°¸ì¡°ê°€ ë³µì‚¬ë¨ (ê°™ì€ ê°ì²´ë¥¼ ê°€ë¦¬í‚´)
cp2.X = 100;

Console.WriteLine("\nclass ë³µì‚¬ í›„:");
Console.WriteLine($"cp1.X = {cp1.X}");  // 100 (í•¨ê»˜ ë³€ê²½ë¨)
Console.WriteLine($"cp2.X = {cp2.X}");  // 100

// ì¶œë ¥:
// struct ë³µì‚¬ í›„:
// sp1.X = 10
// sp2.X = 100
//
// class ë³µì‚¬ í›„:
// cp1.X = 100
// cp2.X = 100
```

**struct ì‚¬ìš© ê°€ì´ë“œë¼ì¸:**

structë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°:
- í¬ê¸°ê°€ ì‘ì€ ë°ì´í„° (ì¼ë°˜ì ìœ¼ë¡œ 16ë°”ì´íŠ¸ ì´í•˜)
- ë…¼ë¦¬ì ìœ¼ë¡œ ë‹¨ì¼ ê°’ì„ ë‚˜íƒ€ë‚´ëŠ” ê²½ìš° (ì¢Œí‘œ, ìƒ‰ìƒ, ë³µì†Œìˆ˜ ë“±)
- ë¶ˆë³€ì„±ì´ ìš”êµ¬ë˜ëŠ” ê²½ìš°
- ë¹ˆë²ˆí•œ ìƒì„±/ì†Œë©¸ì´ í•„ìš”í•œ ê²½ìš° (GC ë¶€ë‹´ ê°ì†Œ)

classë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš°:
- í¬ê¸°ê°€ í° ë°ì´í„°
- ìƒì†ì´ í•„ìš”í•œ ê²½ìš°
- ì°¸ì¡° ì˜ë¯¸ë¡ ì´ í•„ìš”í•œ ê²½ìš°
- null ê°’ì´ ì˜ë¯¸ìˆëŠ” ê²½ìš°

**ì‹¤ìš© ì˜ˆì œ - ìƒ‰ìƒ:**

```csharp
struct Color
{
    public byte R { get; }
    public byte G { get; }
    public byte B { get; }

    public Color(byte r, byte g, byte b)
    {
        R = r;
        G = g;
        B = b;
    }

    public override string ToString()
    {
        return $"RGB({R}, {G}, {B})";
    }

    // ë¯¸ë¦¬ ì •ì˜ëœ ìƒ‰ìƒ
    public static Color Red => new Color(255, 0, 0);
    public static Color Green => new Color(0, 255, 0);
    public static Color Blue => new Color(0, 0, 255);
}

// ì‚¬ìš©
Color red = Color.Red;
Color custom = new Color(128, 64, 192);

Console.WriteLine($"ë¹¨ê°•: {red}");
Console.WriteLine($"ì‚¬ìš©ì ì •ì˜: {custom}");
// ì¶œë ¥:
// ë¹¨ê°•: RGB(255, 0, 0)
// ì‚¬ìš©ì ì •ì˜: RGB(128, 64, 192)
```

### 11.3.2 record struct

C# 10.0ì—ì„œëŠ” `record struct`ê°€ ë„ì…ë˜ì–´, structì—ë„ recordì˜ í¸ë¦¬í•œ ê¸°ëŠ¥ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

```csharp
// record struct ì •ì˜
record struct Point3D(int X, int Y, int Z);

// ì‚¬ìš©
Point3D p1 = new Point3D(1, 2, 3);
Point3D p2 = new Point3D(1, 2, 3);

// ê°’ ê¸°ë°˜ ë™ë“±ì„±
Console.WriteLine(p1 == p2);
// ì¶œë ¥: True

// ToString ìë™ ìƒì„±
Console.WriteLine(p1);
// ì¶œë ¥: Point3D { X = 1, Y = 2, Z = 3 }

// with ì‹ ì‚¬ìš©
Point3D p3 = p1 with { Z = 5 };
Console.WriteLine(p3);
// ì¶œë ¥: Point3D { X = 1, Y = 2, Z = 5 }

// ì›ë³¸ì€ ë³€ê²½ ì•ˆ ë¨ (ê°’ íƒ€ì…)
Console.WriteLine(p1);
// ì¶œë ¥: Point3D { X = 1, Y = 2, Z = 3 }
```

**readonly record struct:**

ë¶ˆë³€ì„±ì„ ë³´ì¥í•˜ë ¤ë©´ `readonly` í•œì •ìë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
readonly record struct ImmutablePoint(int X, int Y)
{
    // ëª¨ë“  í•„ë“œê°€ ìë™ìœ¼ë¡œ readonlyê°€ ë¨
}

// ì‚¬ìš©
ImmutablePoint p = new ImmutablePoint(10, 20);
// p.X = 30; // âŒ ì»´íŒŒì¼ ì˜¤ë¥˜: ì½ê¸° ì „ìš© ì†ì„±ì— í• ë‹¹í•  ìˆ˜ ì—†ìŒ

// with ì‹ì€ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±ì´ë¯€ë¡œ ê°€ëŠ¥
ImmutablePoint p2 = p with { X = 30 };
Console.WriteLine(p2);
// ì¶œë ¥: ImmutablePoint { X = 30, Y = 20 }
```

**record struct vs record class:**

| íŠ¹ì„± | record struct | record class |
|------|--------------|--------------|
| **íƒ€ì…** | ê°’ íƒ€ì… | ì°¸ì¡° íƒ€ì… |
| **ë©”ëª¨ë¦¬** | ìŠ¤íƒ | í™ |
| **ë³µì‚¬** | ê°’ ë³µì‚¬ | ì°¸ì¡° ë³µì‚¬ |
| **ì„±ëŠ¥** | ì‘ì€ ë°ì´í„°ì— ìœ ë¦¬ | í° ë°ì´í„°ì— ìœ ë¦¬ |
| **ìš©ë„** | ì¢Œí‘œ, ë²”ìœ„, ì‘ì€ ë°ì´í„° | DTO, ë„ë©”ì¸ ëª¨ë¸ |

---

## 11.4 ì—´ê±°í˜• (Enum)

ì—´ê±°í˜•(Enumeration, Enum)ì€ ê´€ë ¨ëœ ëª…ëª…ëœ ìƒìˆ˜ë“¤ì˜ ì§‘í•©ì„ ì •ì˜í•˜ëŠ” ê°’ íƒ€ì…ì…ë‹ˆë‹¤. ìˆ«ì ëŒ€ì‹  ì˜ë¯¸ ìˆëŠ” ì´ë¦„ì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œì˜ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.

**ê¸°ë³¸ ì—´ê±°í˜•:**

```csharp
enum DayOfWeek
{
    Sunday,    // 0
    Monday,    // 1
    Tuesday,   // 2
    Wednesday, // 3
    Thursday,  // 4
    Friday,    // 5
    Saturday   // 6
}

// ì‚¬ìš©
DayOfWeek today = DayOfWeek.Monday;
Console.WriteLine($"ì˜¤ëŠ˜ì€ {today}ì…ë‹ˆë‹¤.");
// ì¶œë ¥: ì˜¤ëŠ˜ì€ Mondayì…ë‹ˆë‹¤.

// ì •ìˆ˜ê°’ìœ¼ë¡œ ë³€í™˜
int dayNumber = (int)today;
Console.WriteLine($"ìš”ì¼ ë²ˆí˜¸: {dayNumber}");
// ì¶œë ¥: ìš”ì¼ ë²ˆí˜¸: 1

// ì •ìˆ˜ì—ì„œ ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
DayOfWeek friday = (DayOfWeek)5;
Console.WriteLine(friday);
// ì¶œë ¥: Friday
```

**ëª…ì‹œì  ê°’ ì§€ì •:**

```csharp
enum HttpStatusCode
{
    OK = 200,
    Created = 201,
    BadRequest = 400,
    Unauthorized = 401,
    NotFound = 404,
    InternalServerError = 500
}

// ì‚¬ìš©
HttpStatusCode status = HttpStatusCode.NotFound;
Console.WriteLine($"ìƒíƒœ ì½”ë“œ: {(int)status} - {status}");
// ì¶œë ¥: ìƒíƒœ ì½”ë“œ: 404 - NotFound
```

**ì—´ê±°í˜•ê³¼ switch ë¬¸:**

```csharp
enum OrderStatus
{
    Pending,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}

void PrintOrderStatus(OrderStatus status)
{
    switch (status)
    {
        case OrderStatus.Pending:
            Console.WriteLine("ì£¼ë¬¸ì´ ì ‘ìˆ˜ë˜ì—ˆìŠµë‹ˆë‹¤.");
            break;
        case OrderStatus.Processing:
            Console.WriteLine("ì£¼ë¬¸ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.");
            break;
        case OrderStatus.Shipped:
            Console.WriteLine("ì£¼ë¬¸ì´ ë°°ì†¡ ì¤‘ì…ë‹ˆë‹¤.");
            break;
        case OrderStatus.Delivered:
            Console.WriteLine("ë°°ì†¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
            break;
        case OrderStatus.Cancelled:
            Console.WriteLine("ì£¼ë¬¸ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
            break;
    }
}

// ì‚¬ìš©
PrintOrderStatus(OrderStatus.Processing);
// ì¶œë ¥: ì£¼ë¬¸ì„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.

PrintOrderStatus(OrderStatus.Delivered);
// ì¶œë ¥: ë°°ì†¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
```

**switch ì‹ (C# 8.0+):**

```csharp
string GetStatusMessage(OrderStatus status) => status switch
{
    OrderStatus.Pending => "ì£¼ë¬¸ ì ‘ìˆ˜",
    OrderStatus.Processing => "ì²˜ë¦¬ ì¤‘",
    OrderStatus.Shipped => "ë°°ì†¡ ì¤‘",
    OrderStatus.Delivered => "ë°°ì†¡ ì™„ë£Œ",
    OrderStatus.Cancelled => "ì·¨ì†Œë¨",
    _ => "ì•Œ ìˆ˜ ì—†ëŠ” ìƒíƒœ"
};

// ì‚¬ìš©
Console.WriteLine(GetStatusMessage(OrderStatus.Shipped));
// ì¶œë ¥: ë°°ì†¡ ì¤‘
```

**Flags íŠ¹ì„±ì„ ì‚¬ìš©í•œ ë¹„íŠ¸ í”Œë˜ê·¸:**

`[Flags]` íŠ¹ì„±ì„ ì‚¬ìš©í•˜ë©´ ì—´ê±°í˜•ì„ ë¹„íŠ¸ í”Œë˜ê·¸ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆì–´, ì—¬ëŸ¬ ê°’ì„ ì¡°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
[Flags]
enum FileAccess
{
    None = 0,           // 0000
    Read = 1,           // 0001
    Write = 2,          // 0010
    Execute = 4,        // 0100
    Delete = 8          // 1000
}

// ì‚¬ìš©
FileAccess permission = FileAccess.Read | FileAccess.Write;
Console.WriteLine($"ê¶Œí•œ: {permission}");
// ì¶œë ¥: ê¶Œí•œ: Read, Write

// ê¶Œí•œ í™•ì¸
bool canRead = (permission & FileAccess.Read) == FileAccess.Read;
bool canExecute = (permission & FileAccess.Execute) == FileAccess.Execute;

Console.WriteLine($"ì½ê¸° ê°€ëŠ¥: {canRead}");
Console.WriteLine($"ì‹¤í–‰ ê°€ëŠ¥: {canExecute}");
// ì¶œë ¥:
// ì½ê¸° ê°€ëŠ¥: True
// ì‹¤í–‰ ê°€ëŠ¥: False

// ê¶Œí•œ ì¶”ê°€
permission |= FileAccess.Delete;
Console.WriteLine($"ì—…ë°ì´íŠ¸ëœ ê¶Œí•œ: {permission}");
// ì¶œë ¥: ì—…ë°ì´íŠ¸ëœ ê¶Œí•œ: Read, Write, Delete

// ê¶Œí•œ ì œê±°
permission &= ~FileAccess.Write;
Console.WriteLine($"ìµœì¢… ê¶Œí•œ: {permission}");
// ì¶œë ¥: ìµœì¢… ê¶Œí•œ: Read, Delete
```

**ì—´ê±°í˜• ë©”ì„œë“œ:**

```csharp
enum Priority
{
    Low,
    Medium,
    High,
    Critical
}

// ëª¨ë“  ì—´ê±°í˜• ê°’ ê°€ì ¸ì˜¤ê¸°
Console.WriteLine("ëª¨ë“  ìš°ì„ ìˆœìœ„:");
foreach (Priority p in Enum.GetValues(typeof(Priority)))
{
    Console.WriteLine($"- {p} ({(int)p})");
}
// ì¶œë ¥:
// ëª¨ë“  ìš°ì„ ìˆœìœ„:
// - Low (0)
// - Medium (1)
// - High (2)
// - Critical (3)

// ë¬¸ìì—´ì„ ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
string input = "High";
if (Enum.TryParse<Priority>(input, out Priority priority))
{
    Console.WriteLine($"\níŒŒì‹± ì„±ê³µ: {priority}");
}
else
{
    Console.WriteLine("\níŒŒì‹± ì‹¤íŒ¨");
}
// ì¶œë ¥: íŒŒì‹± ì„±ê³µ: High

// ì—´ê±°í˜•ì´ ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
bool isValid = Enum.IsDefined(typeof(Priority), 2);
Console.WriteLine($"\nê°’ 2ê°€ ìœ íš¨í•œê°€? {isValid}");
// ì¶œë ¥: ê°’ 2ê°€ ìœ íš¨í•œê°€? True
```

**ì‹¤ìš© ì˜ˆì œ - ë¡œê·¸ ë ˆë²¨:**

```csharp
enum LogLevel
{
    Debug,
    Info,
    Warning,
    Error,
    Critical
}

void Log(string message, LogLevel level)
{
    string prefix = level switch
    {
        LogLevel.Debug => "[DEBUG]",
        LogLevel.Info => "[INFO]",
        LogLevel.Warning => "[WARNING]",
        LogLevel.Error => "[ERROR]",
        LogLevel.Critical => "[CRITICAL]",
        _ => "[UNKNOWN]"
    };

    Console.WriteLine($"{prefix} {message}");
}

// ì‚¬ìš©
Log("ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘", LogLevel.Info);
Log("ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥", LogLevel.Debug);
Log("ê²½ê³ : ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ", LogLevel.Warning);
Log("ì˜¤ë¥˜: íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ", LogLevel.Error);
Log("ì¹˜ëª…ì : ì‹œìŠ¤í…œ ì¥ì• ", LogLevel.Critical);

// ì¶œë ¥:
// [INFO] ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
// [DEBUG] ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥
// [WARNING] ê²½ê³ : ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ
// [ERROR] ì˜¤ë¥˜: íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
// [CRITICAL] ì¹˜ëª…ì : ì‹œìŠ¤í…œ ì¥ì• 
```

---

## 11ì¥ ì •ë¦¬ ë° ìš”ì•½

ì´ ì¥ì—ì„œëŠ” C#ì˜ ê³ ê¸‰ ê°ì²´ì§€í–¥ ê¸°ëŠ¥ë“¤ì„ í•™ìŠµí–ˆìŠµë‹ˆë‹¤.

### í•µì‹¬ ê°œë… ì •ë¦¬

1. **sealed í´ë˜ìŠ¤ì™€ ë©”ì„œë“œ**
   - ìƒì†ê³¼ ì˜¤ë²„ë¼ì´ë”©ì„ ì œí•œí•˜ì—¬ ì„¤ê³„ ì˜ë„ ëª…í™•í™”
   - ë³´ì•ˆê³¼ ì„±ëŠ¥ ìµœì í™”ì— ê¸°ì—¬
   - í´ë˜ìŠ¤ì™€ ë©”ì„œë“œ ëª¨ë‘ì— ì ìš© ê°€ëŠ¥

2. **record íƒ€ì…**
   - ë¶ˆë³€ ë°ì´í„° ëª¨ë¸ì„ ê°„ê²°í•˜ê²Œ ì •ì˜
   - ê°’ ê¸°ë°˜ ë™ë“±ì„±ê³¼ ìë™ ToString êµ¬í˜„
   - `with` ì‹ìœ¼ë¡œ ë¹„íŒŒê´´ì  ë³€ê²½ ì§€ì›
   - DTOì™€ ê°’ ê°ì²´ êµ¬í˜„ì— ì´ìƒì 

3. **êµ¬ì¡°ì²´ (Struct)**
   - ê°’ íƒ€ì…ì˜ ì‚¬ìš©ì ì •ì˜ ë°ì´í„° êµ¬ì¡°
   - ìŠ¤íƒ ë©”ëª¨ë¦¬ í• ë‹¹ìœ¼ë¡œ ì„±ëŠ¥ ì´ì 
   - ì‘ê³  ë¶ˆë³€ì ì¸ ë°ì´í„°ì— ì í•©
   - record structë¡œ í¸ì˜ì„± í–¥ìƒ

4. **ì—´ê±°í˜• (Enum)**
   - ê´€ë ¨ëœ ìƒìˆ˜ë“¤ì˜ ëª…ëª…ëœ ì§‘í•©
   - ì½”ë“œ ê°€ë…ì„±ê³¼ íƒ€ì… ì•ˆì „ì„± í–¥ìƒ
   - switch ë¬¸/ì‹ê³¼ ì™„ë²½í•œ í†µí•©
   - Flags íŠ¹ì„±ìœ¼ë¡œ ë¹„íŠ¸ í”Œë˜ê·¸ êµ¬í˜„

### ì–¸ì œ ë¬´ì—‡ì„ ì‚¬ìš©í• ê¹Œ?

**ê°’ vs ì°¸ì¡°:**
- **ì‘ì€ ë¶ˆë³€ ë°ì´í„° (< 16ë°”ì´íŠ¸)**: `readonly struct` ë˜ëŠ” `readonly record struct`
- **ë°ì´í„° ì „ì†¡ ê°ì²´ (DTO)**: `record class`
- **ë„ë©”ì¸ ì—”í‹°í‹°**: `class`
- **ì‘ì€ ê°’ í‘œí˜„ (ì¢Œí‘œ, ìƒ‰ìƒ)**: `struct`

**ë¶ˆë³€ì„± ë³´ì¥:**
- **ê°„ë‹¨í•œ ë¶ˆë³€ ë°ì´í„°**: `record`
- **ë” ì´ìƒ í™•ì¥ ê¸ˆì§€**: `sealed class`
- **ê°’ íƒ€ì… ë¶ˆë³€**: `readonly struct`

**ëª…ëª…ëœ ìƒìˆ˜:**
- **ë‹¨ìˆœ ì—´ê±°**: `enum`
- **ë¹„íŠ¸ í”Œë˜ê·¸**: `[Flags] enum`

### ì‹¤ìŠµ ë¬¸ì œ

#### ë¬¸ì œ 1: recordë¥¼ ì‚¬ìš©í•œ í•™ìƒ ì •ë³´ ê´€ë¦¬

```csharp
record Student(int Id, string Name, int Grade, double GPA);

// í•™ìƒ ìƒì„±
Student student = new Student(1, "ê¹€í•™ìƒ", 3, 3.8);
Console.WriteLine(student);

// í•™ë…„ ì—…ê·¸ë ˆì´ë“œ
Student graduated = student with { Grade = 4, GPA = 3.9 };
Console.WriteLine(graduated);
```

#### ë¬¸ì œ 2: structë¥¼ ì‚¬ìš©í•œ ì¢Œí‘œ ê³„ì‚°

```csharp
struct Point
{
    public double X { get; }
    public double Y { get; }

    public Point(double x, double y)
    {
        X = x;
        Y = y;
    }

    public double DistanceTo(Point other)
    {
        double dx = X - other.X;
        double dy = Y - other.Y;
        return Math.Sqrt(dx * dx + dy * dy);
    }
}

Point p1 = new Point(0, 0);
Point p2 = new Point(3, 4);
Console.WriteLine($"ê±°ë¦¬: {p1.DistanceTo(p2):F2}");
// ì¶œë ¥: ê±°ë¦¬: 5.00
```

#### ë¬¸ì œ 3: enumì„ ì‚¬ìš©í•œ ìƒíƒœ ê´€ë¦¬

```csharp
enum TaskStatus
{
    NotStarted,
    InProgress,
    Completed,
    OnHold
}

string GetStatusIcon(TaskStatus status) => status switch
{
    TaskStatus.NotStarted => "â­•",
    TaskStatus.InProgress => "ğŸ”„",
    TaskStatus.Completed => "âœ…",
    TaskStatus.OnHold => "â¸ï¸",
    _ => "â“"
};

Console.WriteLine($"ì‘ì—… ìƒíƒœ: {GetStatusIcon(TaskStatus.InProgress)}");
```

### ë‹¤ìŒ ì¥ ì˜ˆê³ 

12ì¥ "ì˜ˆì™¸ ì²˜ë¦¬"ì—ì„œëŠ” í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµí•©ë‹ˆë‹¤:
- try-catch-finally êµ¬ë¬¸
- ì˜ˆì™¸ ë˜ì§€ê¸°ì™€ ì‚¬ìš©ì ì •ì˜ ì˜ˆì™¸
- ì˜ˆì™¸ ì²˜ë¦¬ ëª¨ë²” ì‚¬ë¡€

ì•ˆì „í•˜ê³  ê²¬ê³ í•œ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ëŠ” í•µì‹¬ ê¸°ìˆ ì„ ë°°ìš°ê²Œ ë©ë‹ˆë‹¤!
