# 5장. 컬렉션

프로그래밍에서 여러 개의 데이터를 효율적으로 관리하고 처리하는 것은 매우 중요합니다. 배열은 고정된 크기로 데이터를 저장하는 기본적인 방법이지만, 실제 프로그램에서는 데이터의 개수가 동적으로 변하는 경우가 많습니다. C#은 이러한 필요를 충족하기 위해 **컬렉션(Collections)**이라는 강력한 데이터 구조를 제공합니다.

컬렉션은 크기가 자동으로 조정되고, 데이터를 추가하거나 제거하기 쉬우며, 다양한 편리한 메서드를 제공하여 배열보다 훨씬 유연하고 사용하기 편리합니다. 이 장에서는 가장 많이 사용되는 두 가지 컬렉션인 `List<T>`와 `Dictionary<TKey, TValue>`에 대해 학습합니다.

## 이 장에서 배울 내용

- **List<T>**: 순서가 있는 데이터 목록을 관리하고, 요소를 추가/제거하며, 검색하고 정렬하는 방법
- **Dictionary<TKey, TValue>**: 키-값 쌍으로 데이터를 저장하고, 키를 통해 빠르게 값을 찾는 방법

---

## 5.1 List<T>

`List<T>`는 C#에서 가장 널리 사용되는 컬렉션으로, 배열과 유사하지만 크기가 동적으로 조정되는 특징이 있습니다. `T`는 제네릭 타입 매개변수로, 저장할 데이터의 타입을 지정합니다. 예를 들어 `List<int>`는 정수 목록, `List<string>`은 문자열 목록을 의미합니다.

**기본 생성과 초기화:**

```csharp
// 빈 리스트 생성
List<int> numbers = new List<int>();

// 초기값과 함께 생성
List<string> fruits = new List<string> { "사과", "바나나", "오렌지" };

// var 키워드 사용
var cities = new List<string> { "서울", "부산", "대구" };

Console.WriteLine($"과일 개수: {fruits.Count}");  // 출력: 과일 개수: 3
```

**주요 특징:**
- **동적 크기**: 요소를 추가하거나 제거할 때 크기가 자동으로 조정됩니다.
- **인덱스 접근**: 배열처럼 `[인덱스]`로 요소에 접근할 수 있습니다.
- **타입 안정성**: 제네릭을 사용하여 지정된 타입의 데이터만 저장할 수 있습니다.

### 5.1.1 요소 추가 및 제거

List는 데이터를 동적으로 추가하고 제거하는 다양한 메서드를 제공합니다.

**요소 추가:**

```csharp
List<int> numbers = new List<int>();

// 끝에 요소 추가
numbers.Add(10);
numbers.Add(20);
numbers.Add(30);

Console.WriteLine($"개수: {numbers.Count}");  // 출력: 개수: 3

// 여러 요소를 한 번에 추가
numbers.AddRange(new int[] { 40, 50, 60 });
Console.WriteLine($"개수: {numbers.Count}");  // 출력: 개수: 6

// 특정 위치에 삽입
numbers.Insert(0, 5);  // 인덱스 0에 5 삽입
Console.WriteLine($"첫 번째 요소: {numbers[0]}");  // 출력: 첫 번째 요소: 5
```

**요소 제거:**

```csharp
List<string> fruits = new List<string> { "사과", "바나나", "오렌지", "포도" };

// 특정 값 제거 (첫 번째로 일치하는 항목 제거)
fruits.Remove("바나나");
Console.WriteLine(string.Join(", ", fruits));  // 출력: 사과, 오렌지, 포도

// 인덱스로 제거
fruits.RemoveAt(0);  // 첫 번째 요소 제거
Console.WriteLine(string.Join(", ", fruits));  // 출력: 오렌지, 포도

// 모든 요소 제거
fruits.Clear();
Console.WriteLine($"개수: {fruits.Count}");  // 출력: 개수: 0
```

**주요 메서드:**
- `Add(item)`: 끝에 요소 추가
- `AddRange(collection)`: 여러 요소를 한 번에 추가
- `Insert(index, item)`: 특정 위치에 삽입
- `Remove(item)`: 특정 값을 가진 요소 제거
- `RemoveAt(index)`: 특정 인덱스의 요소 제거
- `Clear()`: 모든 요소 제거

### 5.1.2 요소 검색

List는 요소를 찾고 확인하는 다양한 방법을 제공합니다.

**기본 검색 메서드:**

```csharp
List<string> animals = new List<string> { "개", "고양이", "토끼", "햄스터", "고양이" };

// 특정 요소가 있는지 확인
bool hasCat = animals.Contains("고양이");
Console.WriteLine($"고양이가 있나요? {hasCat}");  // 출력: 고양이가 있나요? True

// 첫 번째 일치 항목의 인덱스 찾기
int index = animals.IndexOf("고양이");
Console.WriteLine($"고양이의 인덱스: {index}");  // 출력: 고양이의 인덱스: 1

// 마지막 일치 항목의 인덱스 찾기
int lastIndex = animals.LastIndexOf("고양이");
Console.WriteLine($"고양이의 마지막 인덱스: {lastIndex}");  // 출력: 고양이의 마지막 인덱스: 4
```

**조건부 검색:**

```csharp
List<int> scores = new List<int> { 85, 92, 78, 95, 88, 73 };

// 조건을 만족하는 첫 번째 요소 찾기
int firstHighScore = scores.Find(score => score >= 90);
Console.WriteLine($"90점 이상인 첫 번째 점수: {firstHighScore}");  // 출력: 90점 이상인 첫 번째 점수: 92

// 조건을 만족하는 모든 요소 찾기
List<int> highScores = scores.FindAll(score => score >= 90);
Console.WriteLine($"90점 이상 개수: {highScores.Count}");  // 출력: 90점 이상 개수: 2

// 조건을 만족하는 요소가 있는지 확인
bool hasFailingScore = scores.Exists(score => score < 60);
Console.WriteLine($"60점 미만이 있나요? {hasFailingScore}");  // 출력: 60점 미만이 있나요? False
```

**주요 메서드:**
- `Contains(item)`: 특정 요소가 있는지 확인
- `IndexOf(item)`: 첫 번째 일치 항목의 인덱스 반환
- `Find(predicate)`: 조건을 만족하는 첫 번째 요소 반환
- `FindAll(predicate)`: 조건을 만족하는 모든 요소 반환
- `Exists(predicate)`: 조건을 만족하는 요소가 있는지 확인

### 5.1.3 정렬과 필터링

List는 데이터를 정렬하고 필터링하는 강력한 기능을 제공합니다.

**정렬:**

```csharp
List<int> numbers = new List<int> { 45, 12, 78, 23, 67, 34 };

// 오름차순 정렬
numbers.Sort();
Console.WriteLine("오름차순: " + string.Join(", ", numbers));
// 출력: 오름차순: 12, 23, 34, 45, 67, 78

// 내림차순 정렬
numbers.Reverse();
Console.WriteLine("내림차순: " + string.Join(", ", numbers));
// 출력: 내림차순: 78, 67, 45, 34, 23, 12
```

**문자열 정렬:**

```csharp
List<string> names = new List<string> { "홍길동", "김철수", "이영희", "박민수" };

names.Sort();
Console.WriteLine("정렬된 이름: " + string.Join(", ", names));
// 출력: 정렬된 이름: 김철수, 박민수, 이영희, 홍길동
```

**조건부 필터링:**

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// 짝수만 필터링
List<int> evenNumbers = numbers.FindAll(n => n % 2 == 0);
Console.WriteLine("짝수: " + string.Join(", ", evenNumbers));
// 출력: 짝수: 2, 4, 6, 8, 10

// 5보다 큰 수만 필터링
List<int> greaterThanFive = numbers.FindAll(n => n > 5);
Console.WriteLine("5보다 큰 수: " + string.Join(", ", greaterThanFive));
// 출력: 5보다 큰 수: 6, 7, 8, 9, 10
```

**순회:**

```csharp
List<string> fruits = new List<string> { "사과", "바나나", "오렌지" };

// foreach로 순회
foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}

// for로 순회 (인덱스가 필요한 경우)
for (int i = 0; i < fruits.Count; i++)
{
    Console.WriteLine($"{i}: {fruits[i]}");
}
```

**주요 메서드:**
- `Sort()`: 오름차순 정렬
- `Reverse()`: 순서 뒤집기
- `FindAll(predicate)`: 조건을 만족하는 모든 요소를 새 리스트로 반환

---

## 5.2 Dictionary<TKey, TValue>

`Dictionary<TKey, TValue>`는 키(Key)와 값(Value)의 쌍으로 데이터를 저장하는 컬렉션입니다. 키를 통해 값을 빠르게 찾을 수 있어서, 전화번호부나 사전처럼 데이터를 관리할 때 매우 유용합니다. `TKey`는 키의 타입, `TValue`는 값의 타입을 나타냅니다.

**기본 개념:**

Dictionary는 내부적으로 해시 테이블을 사용하여 키를 기반으로 값을 O(1) 시간 복잡도로 찾을 수 있습니다. 각 키는 고유해야 하며, 같은 키를 중복해서 추가할 수 없습니다.

**기본 생성과 초기화:**

```csharp
// 빈 Dictionary 생성
Dictionary<string, int> scores = new Dictionary<string, int>();

// 초기값과 함께 생성
Dictionary<string, string> phoneBook = new Dictionary<string, string>
{
    { "홍길동", "010-1234-5678" },
    { "김철수", "010-2345-6789" },
    { "이영희", "010-3456-7890" }
};

Console.WriteLine($"전화번호부 항목 수: {phoneBook.Count}");
// 출력: 전화번호부 항목 수: 3
```

### 5.2.1 키-값 쌍 추가

Dictionary에 새로운 데이터를 추가하는 방법입니다.

**요소 추가:**

```csharp
Dictionary<string, int> ages = new Dictionary<string, int>();

// Add 메서드로 추가
ages.Add("홍길동", 25);
ages.Add("김철수", 30);
ages.Add("이영희", 28);

// 인덱서로 추가 (더 일반적인 방법)
ages["박민수"] = 35;

Console.WriteLine($"등록된 사람 수: {ages.Count}");  // 출력: 등록된 사람 수: 4
```

**중복 키 처리:**

```csharp
Dictionary<string, string> capitals = new Dictionary<string, string>
{
    { "한국", "서울" },
    { "일본", "도쿄" }
};

// Add 메서드는 같은 키가 있으면 예외 발생
// capitals.Add("한국", "부산");  // ❌ ArgumentException 발생

// 인덱서는 같은 키가 있으면 값을 덮어씀
capitals["한국"] = "부산";  // ✅ 값이 "부산"으로 변경됨
Console.WriteLine($"한국의 수도: {capitals["한국"]}");  // 출력: 한국의 수도: 부산

// 안전하게 추가하기
if (!capitals.ContainsKey("중국"))
{
    capitals.Add("중국", "베이징");
}
```

**여러 항목 초기화:**

```csharp
var studentScores = new Dictionary<string, int>
{
    ["홍길동"] = 85,
    ["김철수"] = 92,
    ["이영희"] = 78,
    ["박민수"] = 95
};
```

### 5.2.2 키로 값 조회

Dictionary에서 키를 사용하여 값을 찾는 방법입니다.

**기본 조회:**

```csharp
Dictionary<string, string> phoneBook = new Dictionary<string, string>
{
    { "홍길동", "010-1234-5678" },
    { "김철수", "010-2345-6789" },
    { "이영희", "010-3456-7890" }
};

// 인덱서로 조회
string phone = phoneBook["홍길동"];
Console.WriteLine($"홍길동의 전화번호: {phone}");
// 출력: 홍길동의 전화번호: 010-1234-5678

// 존재하지 않는 키를 조회하면 예외 발생
// string unknown = phoneBook["박민수"];  // ❌ KeyNotFoundException 발생
```

**안전한 조회 (TryGetValue):**

```csharp
Dictionary<string, int> ages = new Dictionary<string, int>
{
    { "홍길동", 25 },
    { "김철수", 30 }
};

// TryGetValue를 사용하여 안전하게 조회
if (ages.TryGetValue("홍길동", out int age))
{
    Console.WriteLine($"홍길동의 나이: {age}");  // 출력: 홍길동의 나이: 25
}
else
{
    Console.WriteLine("정보를 찾을 수 없습니다.");
}

// 존재하지 않는 키
if (ages.TryGetValue("박민수", out int age2))
{
    Console.WriteLine($"박민수의 나이: {age2}");
}
else
{
    Console.WriteLine("박민수의 정보를 찾을 수 없습니다.");
    // 출력: 박민수의 정보를 찾을 수 없습니다.
}
```

**값 수정:**

```csharp
Dictionary<string, int> scores = new Dictionary<string, int>
{
    { "홍길동", 85 },
    { "김철수", 90 }
};

// 기존 값 수정
scores["홍길동"] = 95;
Console.WriteLine($"홍길동의 새 점수: {scores["홍길동"]}");
// 출력: 홍길동의 새 점수: 95
```

### 5.2.3 키 존재 여부 확인

Dictionary에서 특정 키나 값이 있는지 확인하는 방법입니다.

**키 존재 확인:**

```csharp
Dictionary<string, string> countries = new Dictionary<string, string>
{
    { "KR", "대한민국" },
    { "US", "미국" },
    { "JP", "일본" }
};

// ContainsKey로 키 존재 확인
if (countries.ContainsKey("KR"))
{
    Console.WriteLine("KR 키가 존재합니다.");  // 출력됨
}

if (!countries.ContainsKey("CN"))
{
    Console.WriteLine("CN 키가 없습니다.");  // 출력됨
}
```

**값 존재 확인:**

```csharp
Dictionary<string, int> inventory = new Dictionary<string, int>
{
    { "사과", 10 },
    { "바나나", 5 },
    { "오렌지", 0 }
};

// ContainsValue로 값 존재 확인
bool hasZeroStock = inventory.ContainsValue(0);
Console.WriteLine($"재고가 0인 품목이 있나요? {hasZeroStock}");
// 출력: 재고가 0인 품목이 있나요? True
```

**키와 값 순회:**

```csharp
Dictionary<string, int> scores = new Dictionary<string, int>
{
    { "홍길동", 85 },
    { "김철수", 92 },
    { "이영희", 78 }
};

// 모든 키-값 쌍 순회
Console.WriteLine("=== 전체 점수 ===");
foreach (KeyValuePair<string, int> item in scores)
{
    Console.WriteLine($"{item.Key}: {item.Value}점");
}

// var 키워드 사용 (더 간결함)
Console.WriteLine("\n=== var 사용 ===");
foreach (var item in scores)
{
    Console.WriteLine($"{item.Key}: {item.Value}점");
}

// 키만 순회
Console.WriteLine("\n=== 이름만 출력 ===");
foreach (string name in scores.Keys)
{
    Console.WriteLine(name);
}

// 값만 순회
Console.WriteLine("\n=== 점수만 출력 ===");
foreach (int score in scores.Values)
{
    Console.WriteLine($"{score}점");
}
```

**요소 제거:**

```csharp
Dictionary<string, string> users = new Dictionary<string, string>
{
    { "user1", "홍길동" },
    { "user2", "김철수" },
    { "user3", "이영희" }
};

// 특정 키 제거
bool removed = users.Remove("user2");
Console.WriteLine($"제거 성공: {removed}");  // 출력: 제거 성공: True

// 모든 요소 제거
users.Clear();
Console.WriteLine($"남은 항목 수: {users.Count}");  // 출력: 남은 항목 수: 0
```

**주요 메서드와 속성:**
- `Add(key, value)`: 키-값 쌍 추가
- `ContainsKey(key)`: 키 존재 여부 확인
- `ContainsValue(value)`: 값 존재 여부 확인
- `TryGetValue(key, out value)`: 안전한 값 조회
- `Remove(key)`: 특정 키 제거
- `Clear()`: 모든 항목 제거
- `Keys`: 모든 키 컬렉션
- `Values`: 모든 값 컬렉션
- `Count`: 항목 개수

---

## 5장 정리

이 장에서는 C#의 대표적인 컬렉션인 `List<T>`와 `Dictionary<TKey, TValue>`에 대해 학습했습니다.

**핵심 내용:**

1. **List<T>**
   - 동적 크기 조정이 가능한 순서 있는 컬렉션
   - 요소 추가/제거, 검색, 정렬, 필터링 기능 제공
   - 인덱스를 통한 빠른 접근

2. **Dictionary<TKey, TValue>**
   - 키-값 쌍으로 데이터 저장
   - 키를 통한 빠른 조회 (O(1))
   - 고유한 키 필요, 중복 불가

**실습 문제:**

1. 학생들의 이름을 저장하는 List를 만들고, 이름을 추가하고 정렬해보세요.
2. 제품명과 가격을 저장하는 Dictionary를 만들고, 특정 제품의 가격을 조회해보세요.
3. 숫자 List에서 짝수만 필터링하여 새로운 List를 만들어보세요.

**다음 장 예고:**

6장에서는 문자열을 더 효율적으로 처리하는 방법을 배웁니다. 문자열 조작, 검색, 분리 등의 기능과 함께 StringBuilder를 활용한 성능 최적화 기법을 학습하게 됩니다.
