# 18장. 고급 비동기 패턴

17장에서 배운 비동기 프로그래밍의 기초를 바탕으로, 이 장에서는 실무에서 자주 사용되는 고급 비동기 패턴들을 학습합니다. 여러 작업을 조율하고, 작업을 취소하며, 비동기 스트림을 처리하는 방법을 익히게 됩니다.

## 18.1 여러 Task 다루기

여러 개의 비동기 작업을 효율적으로 관리하고 조율하는 것은 실무 애플리케이션에서 필수적입니다. `Task.WhenAll`과 `Task.WhenAny`를 사용하면 복잡한 비동기 작업 흐름을 간단하게 구현할 수 있습니다.

### 18.1.1 Task.WhenAll

`Task.WhenAll`은 여러 작업이 모두 완료될 때까지 기다립니다. 작업들이 병렬로 실행되므로 순차 실행보다 훨씬 빠릅니다.

```csharp
async Task<int> DownloadFileAsync(string url)
{
    await Task.Delay(1000); // 다운로드 시뮬레이션
    return url.Length;
}

async Task DownloadMultipleFilesAsync()
{
    string[] urls = {
        "https://example.com/file1.txt",
        "https://example.com/file2.txt",
        "https://example.com/file3.txt"
    };
    
    // 모든 다운로드를 동시에 시작
    Task<int>[] tasks = urls.Select(url => DownloadFileAsync(url)).ToArray();
    
    // 모든 작업이 완료될 때까지 대기
    int[] results = await Task.WhenAll(tasks);
    
    Console.WriteLine($"총 다운로드 크기: {results.Sum()} 바이트");
}
```

**주요 특징:**
- 모든 작업을 병렬로 실행
- 하나라도 실패하면 예외 발생
- 결과를 배열로 반환

### 18.1.2 Task.WhenAny

`Task.WhenAny`는 여러 작업 중 하나라도 완료되면 반환됩니다. 타임아웃 구현이나 여러 소스 중 가장 빠른 응답 사용에 유용합니다.

```csharp
async Task<string> GetFastestResponseAsync()
{
    Task<string> server1 = DownloadFromServerAsync("Server1");
    Task<string> server2 = DownloadFromServerAsync("Server2");
    Task<string> server3 = DownloadFromServerAsync("Server3");
    
    // 가장 먼저 완료되는 작업 대기
    Task<string> completedTask = await Task.WhenAny(server1, server2, server3);
    
    // 결과 반환
    return await completedTask;
}

// 타임아웃 구현 예제
async Task<string> DownloadWithTimeoutAsync(string url, TimeSpan timeout)
{
    Task<string> downloadTask = DownloadAsync(url);
    Task delayTask = Task.Delay(timeout);
    
    Task completedTask = await Task.WhenAny(downloadTask, delayTask);
    
    if (completedTask == delayTask)
    {
        throw new TimeoutException("다운로드 시간 초과");
    }
    
    return await downloadTask;
}
```

**주요 활용 사례:**
- 타임아웃 구현
- 여러 소스 중 가장 빠른 응답 선택
- 작업 진행률 모니터링

---

## 18.2 취소 토큰 (CancellationToken)

비동기 작업은 시간이 오래 걸릴 수 있으므로, 사용자가 작업을 취소할 수 있는 메커니즘이 필요합니다. `CancellationToken`은 협력적 취소(Cooperative Cancellation)를 위한 표준 메커니즘입니다.

### 기본 사용법

```csharp
async Task DownloadLargeFileAsync(string url, CancellationToken cancellationToken)
{
    for (int i = 0; i < 100; i++)
    {
        // 취소 요청 확인
        cancellationToken.ThrowIfCancellationRequested();
        
        // 작업 수행
        await DownloadChunkAsync(url, i);
        
        Console.WriteLine($"진행률: {i + 1}%");
    }
}

// 사용 예제
async Task UseDownloadAsync()
{
    var cts = new CancellationTokenSource();
    
    try
    {
        // 5초 후 자동 취소
        cts.CancelAfter(TimeSpan.FromSeconds(5));
        
        await DownloadLargeFileAsync("https://example.com/large.zip", cts.Token);
        Console.WriteLine("다운로드 완료");
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("다운로드가 취소되었습니다.");
    }
}
```

### 여러 토큰 연결하기

```csharp
async Task ProcessWithMultipleCancellationAsync()
{
    var userCts = new CancellationTokenSource(); // 사용자 취소
    var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30)); // 타임아웃
    
    // 여러 토큰을 하나로 결합
    var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
        userCts.Token, 
        timeoutCts.Token
    );
    
    try
    {
        await LongRunningOperationAsync(linkedCts.Token);
    }
    catch (OperationCanceledException)
    {
        if (userCts.Token.IsCancellationRequested)
            Console.WriteLine("사용자가 취소했습니다.");
        else if (timeoutCts.Token.IsCancellationRequested)
            Console.WriteLine("시간 초과로 취소되었습니다.");
    }
}
```

**모범 사례:**
- 비동기 메서드에 `CancellationToken` 매개변수 추가
- 주기적으로 `ThrowIfCancellationRequested()` 호출
- 사용자 인터페이스에서 취소 버튼 제공
- 타임아웃과 사용자 취소를 모두 지원

---

## 18.3 비동기 스트림 (IAsyncEnumerable<T>)

C# 8.0에서 도입된 `IAsyncEnumerable<T>`는 비동기적으로 데이터를 생성하고 소비할 수 있게 해줍니다. 대량의 데이터를 처리할 때 메모리를 절약하고 응답성을 향상시킵니다.

### 기본 개념

```csharp
// 비동기 스트림 생성
async IAsyncEnumerable<int> GenerateNumbersAsync(int count)
{
    for (int i = 0; i < count; i++)
    {
        await Task.Delay(100); // 비동기 작업 시뮬레이션
        yield return i;
    }
}

// 비동기 스트림 소비
async Task ConsumeNumbersAsync()
{
    await foreach (int number in GenerateNumbersAsync(10))
    {
        Console.WriteLine($"받은 숫자: {number}");
    }
}
```

### 실전 예제: 대용량 파일 처리

```csharp
async IAsyncEnumerable<string> ReadLinesAsync(string filePath)
{
    using var reader = new StreamReader(filePath);
    
    while (!reader.EndOfStream)
    {
        string line = await reader.ReadLineAsync();
        yield return line;
    }
}

async Task ProcessLargeFileAsync(string filePath)
{
    int lineCount = 0;
    
    await foreach (string line in ReadLinesAsync(filePath))
    {
        // 각 줄을 처리
        Console.WriteLine(line);
        lineCount++;
    }
    
    Console.WriteLine($"총 {lineCount}줄 처리 완료");
}
```

### 취소 토큰과 함께 사용

```csharp
async IAsyncEnumerable<string> FetchDataAsync(
    [EnumeratorCancellation] CancellationToken cancellationToken = default)
{
    for (int i = 0; i < 100; i++)
    {
        cancellationToken.ThrowIfCancellationRequested();
        
        await Task.Delay(100, cancellationToken);
        yield return $"데이터 {i}";
    }
}

async Task UseAsyncStreamWithCancellationAsync()
{
    var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
    
    try
    {
        await foreach (string data in FetchDataAsync(cts.Token))
        {
            Console.WriteLine(data);
        }
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("스트림이 취소되었습니다.");
    }
}
```

**장점:**
- 메모리 효율적 (한 번에 하나씩 처리)
- 응답성 향상 (데이터가 도착하는 즉시 처리)
- 취소 지원
- LINQ 연산자와 호환 (`System.Linq.Async` 패키지)

---

## 18.4 ConfigureAwait

`ConfigureAwait`는 비동기 작업이 완료된 후 실행 컨텍스트를 어떻게 처리할지 제어합니다. 올바른 사용은 성능과 데드락 방지에 중요합니다.

### 기본 개념

```csharp
// UI 애플리케이션 (WPF, WinForms, MAUI)
async Task UpdateUIAsync()
{
    // UI 스레드에서 시작
    string data = await DownloadDataAsync(); // 기본: UI 스레드로 복귀
    
    // UI 스레드에서 실행
    textBox.Text = data; // 안전함
}

// 라이브러리 코드
async Task<string> LibraryMethodAsync()
{
    // ConfigureAwait(false)로 성능 향상
    string data = await DownloadDataAsync().ConfigureAwait(false);
    
    // 스레드 풀 스레드에서 실행 (UI 스레드 X)
    string processed = ProcessData(data);
    
    return processed;
}
```

### 사용 지침

**UI 애플리케이션:**
```csharp
async void Button_Click(object sender, EventArgs e)
{
    // UI 코드에서는 ConfigureAwait 사용하지 않기
    string result = await DownloadDataAsync();
    
    // UI 스레드에서 실행되어야 함
    label.Text = result;
}
```

**라이브러리 코드:**
```csharp
public async Task<Data> GetDataAsync()
{
    // 라이브러리에서는 항상 ConfigureAwait(false) 사용
    var response = await httpClient.GetAsync(url)
        .ConfigureAwait(false);
    
    var content = await response.Content.ReadAsStringAsync()
        .ConfigureAwait(false);
    
    return ParseData(content);
}
```

### ASP.NET Core

```csharp
// ASP.NET Core에서는 SynchronizationContext가 없음
// ConfigureAwait(false)가 불필요하지만 사용해도 무방
public async Task<IActionResult> GetProducts()
{
    var products = await productService.GetProductsAsync()
        .ConfigureAwait(false); // 선택사항
    
    return Ok(products);
}
```

**핵심 규칙:**
- **UI 코드**: `ConfigureAwait` 사용하지 않기 (UI 스레드 필요)
- **라이브러리 코드**: 항상 `ConfigureAwait(false)` 사용 (성능, 데드락 방지)
- **ASP.NET Core**: 선택사항 (SynchronizationContext 없음)

---

## 18장 정리

이 장에서는 비동기 프로그래밍의 고급 패턴들을 학습했습니다:

### 주요 개념 요약

1. **Task.WhenAll / Task.WhenAny**
   - 여러 작업을 효율적으로 조율
   - 병렬 실행으로 성능 향상
   - 타임아웃과 경쟁 시나리오 구현

2. **CancellationToken**
   - 협력적 취소 메커니즘
   - 사용자 경험 향상
   - 리소스 낭비 방지

3. **IAsyncEnumerable<T>**
   - 비동기 스트림 처리
   - 메모리 효율성
   - 대용량 데이터 처리에 적합

4. **ConfigureAwait**
   - 실행 컨텍스트 제어
   - 성능 최적화
   - 데드락 방지

### 실무 적용

이러한 패턴들은 다음과 같은 실무 시나리오에서 활용됩니다:
- 웹 API의 동시 요청 처리
- 파일 업로드/다운로드의 취소 기능
- 실시간 데이터 스트리밍
- 마이크로서비스 간 통신
- 배치 처리 시스템

고급 비동기 패턴을 마스터하면 더 효율적이고 사용자 친화적인 애플리케이션을 개발할 수 있습니다.
