# 25장. 디버깅과 로깅

소프트웨어 개발에서 코드를 작성하는 것만큼 중요한 것이 **디버깅(Debugging)**과 **로깅(Logging)**입니다. 디버깅은 프로그램의 오류를 찾아 수정하는 과정이며, 로깅은 프로그램 실행 중 발생하는 이벤트와 상태를 기록하여 문제 분석과 모니터링을 가능하게 합니다. 이 장에서는 Visual Studio Code의 강력한 디버깅 도구와 .NET의 로깅 프레임워크를 활용하여 효과적으로 프로그램을 개발하고 유지보수하는 방법을 학습합니다.

**디버깅의 역사와 중요성:**

"디버그(Debug)"라는 용어는 1947년 하버드 대학의 Mark II 컴퓨터에서 실제 나방(moth)이 회로에 끼어 오작동을 일으킨 사건에서 유래했습니다. Grace Hopper와 그녀의 팀은 이 나방을 제거하면서 "디버깅했다(debugged)"고 기록했습니다. 이후 디버깅은 프로그램의 오류를 찾아 수정하는 과정을 의미하게 되었습니다.

현대 소프트웨어 개발에서 디버깅은 개발 시간의 상당 부분을 차지합니다. 연구에 따르면 개발자는 전체 시간의 50% 이상을 디버깅에 할애하며, 효과적인 디버깅 도구와 기법은 생산성에 직접적인 영향을 미칩니다.

**로깅의 중요성:**

로깅은 프로그램의 "블랙박스"와 같은 역할을 합니다. 프로그램이 어떻게 실행되었는지, 어떤 문제가 발생했는지를 시간순으로 기록하여:

- **문제 재현**: 오류가 발생한 정확한 상황을 파악할 수 있습니다
- **성능 분석**: 병목 지점과 느린 작업을 식별할 수 있습니다
- **보안 감사**: 누가 언제 무엇을 했는지 추적할 수 있습니다
- **운영 모니터링**: 프로덕션 환경에서 시스템 상태를 실시간으로 확인할 수 있습니다

## 이 장에서 배울 내용

- **Visual Studio Code 디버거 활용**: 중단점 설정, 변수 검사, 호출 스택 추적, 조건부 디버깅 등 개발 생산성을 높이는 핵심 디버깅 기법을 학습합니다.

- **효과적인 로깅 전략**: `Console.WriteLine`의 한계를 이해하고, 구조화된 로깅(Structured Logging)을 통해 검색과 분석이 용이한 로그를 작성하는 방법을 배웁니다.

- **Microsoft.Extensions.Logging**: .NET의 표준 로깅 추상화를 활용하여 로깅 프레임워크에 독립적인 코드를 작성하고, 다양한 로그 출력 대상을 관리하는 방법을 익힙니다.

- **로그 레벨 관리**: Trace, Debug, Information, Warning, Error, Critical 등 로그 레벨을 적절히 사용하여 환경별로 필요한 정보만 기록하는 전략을 학습합니다.

**학습 목표:**

- Visual Studio Code 디버거의 주요 기능을 활용하여 효율적으로 디버깅
- 적절한 로그 레벨과 메시지로 유지보수하기 쉬운 로그 작성
- 구조화된 로깅을 통한 검색과 분석 가능한 로그 기록
- 개발, 테스트, 프로덕션 환경별 로깅 설정 관리

---

## 25.1 Visual Studio Code 디버거 사용

Visual Studio Code는 강력한 디버깅 도구를 내장하고 있습니다. 디버거를 사용하면 프로그램을 단계별로 실행하면서 변수의 값을 확인하고, 실행 흐름을 추적하여 문제의 원인을 빠르게 찾을 수 있습니다.

**디버거의 주요 개념:**

- **중단점(Breakpoint)**: 프로그램 실행을 일시 중지할 위치를 지정합니다
- **단계 실행(Stepping)**: 코드를 한 줄씩 실행하면서 동작을 관찰합니다
- **변수 검사(Variable Inspection)**: 실행 중인 변수의 값과 상태를 확인합니다
- **호출 스택(Call Stack)**: 현재 실행 위치에 도달하기까지의 함수 호출 경로를 추적합니다
- **조사식(Watch)**: 특정 표현식의 값을 지속적으로 모니터링합니다

### 25.1.1 중단점 (Breakpoints)

중단점은 디버깅의 가장 기본적이고 강력한 도구입니다. 코드의 특정 줄에 중단점을 설정하면, 프로그램이 해당 줄에 도달했을 때 실행이 일시 중지됩니다.

**중단점 설정 방법:**

```csharp
// Program.cs
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("프로그램 시작");
        
        // 이 줄의 왼쪽 여백을 클릭하여 중단점 설정
        int number = 10;
        int result = CalculateDouble(number);
        
        Console.WriteLine($"결과: {result}");
        Console.WriteLine("프로그램 종료");
    }
    
    static int CalculateDouble(int value)
    {
        // 여기에도 중단점을 설정할 수 있습니다
        return value * 2;
    }
}
```

**중단점 설정 단계:**

1. Visual Studio Code에서 코드 파일을 엽니다
2. 중단점을 설정할 줄 번호 왼쪽의 여백(gutter)을 클릭합니다
3. 빨간 점이 표시되면 중단점이 설정된 것입니다
4. F5 키를 눌러 디버그 모드로 실행합니다

**디버그 모드 실행:**

```bash
# 또는 터미널에서
dotnet run
```

디버그 모드로 실행하면 프로그램이 중단점에 도달했을 때 멈추며, 다음과 같은 작업을 수행할 수 있습니다:

**디버그 제어 버튼:**

- **계속(Continue, F5)**: 다음 중단점까지 실행
- **한 단계씩 실행(Step Over, F10)**: 현재 줄을 실행하고 다음 줄로 이동 (함수 호출 시 내부로 들어가지 않음)
- **한 단계씩 코드 실행(Step Into, F11)**: 함수 호출이 있으면 함수 내부로 들어감
- **프로시저 나가기(Step Out, Shift+F11)**: 현재 함수를 끝까지 실행하고 호출자로 돌아감
- **다시 시작(Restart, Ctrl+Shift+F5)**: 디버깅을 처음부터 다시 시작
- **중지(Stop, Shift+F5)**: 디버깅 종료

**실습 예제:**

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // 중단점 1: 여기서 시작
        var numbers = new List<int> { 1, 2, 3, 4, 5 };
        
        // 중단점 2: 리스트 내용 확인
        int sum = 0;
        foreach (int num in numbers)
        {
            // 중단점 3: 각 반복에서 num 값 확인
            sum += num;
        }
        
        // 중단점 4: 최종 결과 확인
        Console.WriteLine($"합계: {sum}");
    }
}
```

### 25.1.2 변수 검사

디버거가 중단점에서 멈추면, 현재 범위(scope)의 모든 변수 값을 확인할 수 있습니다.

**변수 확인 방법:**

1. **변수 창(Variables Panel)**: 
   - 좌측 디버그 사이드바의 "변수" 섹션에서 로컬 변수, 전역 변수 확인
   - 객체를 확장하여 내부 속성 탐색

2. **호버 검사(Hover Inspection)**:
   - 변수 위에 마우스를 올리면 현재 값 표시
   - 복잡한 객체는 팝업에서 확장 가능

3. **조사식(Watch)**:
   - 특정 표현식을 추가하여 지속적으로 모니터링
   - 변수뿐만 아니라 복잡한 표현식도 평가 가능

**변수 검사 예제:**

```csharp
using System;
using System.Collections.Generic;

class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
}

class Program
{
    static void Main()
    {
        // 중단점을 설정하고 각 단계의 변수 상태를 확인해봅시다
        var products = new List<Product>
        {
            new Product { Name = "노트북", Price = 1500000, Stock = 10 },
            new Product { Name = "마우스", Price = 50000, Stock = 50 },
            new Product { Name = "키보드", Price = 120000, Stock = 30 }
        };
        
        // 중단점: products 리스트 내용 확인
        decimal totalValue = 0;
        
        foreach (var product in products)
        {
            // 중단점: 각 product의 속성 확인
            decimal productValue = product.Price * product.Stock;
            totalValue += productValue;
            
            Console.WriteLine($"{product.Name}: {productValue:C}");
        }
        
        // 중단점: 최종 totalValue 확인
        Console.WriteLine($"총 재고 가치: {totalValue:C}");
    }
}
```

**변수 창에서 확인할 수 있는 정보:**

- **로컬 변수(Locals)**: 현재 메서드의 모든 지역 변수
- **매개변수(Parameters)**: 메서드에 전달된 인수
- **필드(Fields)**: 클래스의 멤버 변수
- **속성(Properties)**: 객체의 속성 값
- **컬렉션 요소**: 배열, 리스트, 딕셔너리 등의 내용

**디버그 콘솔(Debug Console):**

디버그 콘솔에서 C# 표현식을 직접 평가할 수 있습니다:

```
// 디버그 콘솔에서 실행 가능한 표현식 예시
products.Count
products[0].Name
totalValue * 1.1m  // 10% 마진 계산
products.Where(p => p.Stock < 20).Count()
```

### 25.1.3 조건부 중단점

모든 실행에서 멈추는 일반 중단점과 달리, 조건부 중단점은 특정 조건을 만족할 때만 실행을 중지합니다. 이는 반복문 안에서 특정 값을 가진 경우에만 디버깅하고 싶을 때 매우 유용합니다.

**조건부 중단점 설정:**

1. 일반 중단점을 설정합니다 (빨간 점)
2. 중단점을 우클릭하고 "중단점 편집(Edit Breakpoint)" 선택
3. 조건식을 입력합니다

**조건부 중단점 종류:**

**1. 표현식 조건(Expression Condition):**

특정 조건이 참일 때만 중단됩니다.

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        var numbers = new List<int>();
        
        // 1부터 100까지 숫자 생성
        for (int i = 1; i <= 100; i++)
        {
            numbers.Add(i);
            
            // 중단점: 조건 "i == 50" 설정
            // i가 50일 때만 멈춥니다
            ProcessNumber(i);
        }
    }
    
    static void ProcessNumber(int number)
    {
        // 중단점: 조건 "number > 90" 설정
        // 90보다 큰 값에서만 멈춥니다
        Console.WriteLine($"처리 중: {number}");
    }
}
```

**2. 적중 횟수(Hit Count):**

중단점이 특정 횟수만큼 실행된 후에 중단됩니다.

```csharp
using System;

class Program
{
    static void Main()
    {
        // 중단점: 적중 횟수 "= 10" 설정
        // 10번째 반복에서만 멈춥니다
        for (int i = 0; i < 100; i++)
        {
            ProcessData(i);
        }
    }
    
    static void ProcessData(int value)
    {
        Console.WriteLine($"데이터 처리: {value}");
    }
}
```

**3. 로그 포인트(Log Point):**

프로그램 실행을 중지하지 않고 메시지만 출력합니다. 중단점 대신 다이아몬드 모양 아이콘이 표시됩니다.

```csharp
using System;

class Program
{
    static void Main()
    {
        for (int i = 0; i < 10; i++)
        {
            // 로그 포인트: "현재 i 값: {i}"
            // 중단하지 않고 콘솔에 메시지만 출력
            int result = Calculate(i);
            Console.WriteLine($"결과: {result}");
        }
    }
    
    static int Calculate(int value)
    {
        return value * value;
    }
}
```

**실전 활용 예제:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

class Order
{
    public int OrderId { get; set; }
    public string CustomerName { get; set; }
    public decimal Amount { get; set; }
    public string Status { get; set; }
}

class Program
{
    static void Main()
    {
        var orders = GenerateOrders();
        
        foreach (var order in orders)
        {
            // 조건부 중단점: order.Amount > 1000000
            // 백만 원 이상 주문만 검사
            ProcessOrder(order);
        }
        
        // 중단점: Status가 "실패"인 주문 개수 확인
        var failedOrders = orders.Where(o => o.Status == "실패").ToList();
        Console.WriteLine($"실패한 주문: {failedOrders.Count}개");
    }
    
    static void ProcessOrder(Order order)
    {
        // 조건부 중단점: order.Status == "실패"
        // 실패한 주문에서만 멈춰서 원인 파악
        try
        {
            if (order.Amount > 2000000)
            {
                throw new Exception("금액 초과");
            }
            
            order.Status = "성공";
        }
        catch (Exception ex)
        {
            order.Status = "실패";
            Console.WriteLine($"주문 {order.OrderId} 실패: {ex.Message}");
        }
    }
    
    static List<Order> GenerateOrders()
    {
        var random = new Random();
        var orders = new List<Order>();
        
        for (int i = 1; i <= 50; i++)
        {
            orders.Add(new Order
            {
                OrderId = i,
                CustomerName = $"고객{i}",
                Amount = random.Next(100000, 3000000),
                Status = "대기"
            });
        }
        
        return orders;
    }
}
```

**조건부 중단점 활용 팁:**

- **성능 고려**: 조건을 평가하는 데도 시간이 걸리므로 복잡한 조건은 피합니다
- **부작용 주의**: 조건식에서 변수를 변경하지 않도록 주의합니다
- **로그 포인트 활용**: 실행 흐름을 추적하되 중단하고 싶지 않을 때 유용합니다
- **임시 비활성화**: 중단점을 삭제하지 않고 우클릭으로 비활성화/활성화 가능합니다

---

## 25.2 로깅

로깅은 프로그램 실행 중 발생하는 이벤트, 상태 변화, 오류 등을 기록하는 프로세스입니다. 개발 단계에서는 디버깅을, 프로덕션 환경에서는 모니터링과 문제 진단을 가능하게 합니다.

**로깅의 핵심 원칙:**

1. **적절한 상세도**: 너무 많으면 노이즈, 너무 적으면 정보 부족
2. **구조화된 정보**: 검색과 분석이 가능하도록 일관된 형식 유지
3. **성능 고려**: 로깅이 애플리케이션 성능에 미치는 영향 최소화
4. **보안**: 민감한 정보(비밀번호, 개인정보)를 로그에 기록하지 않음
5. **회전 정책**: 로그 파일이 무한정 커지지 않도록 관리

### 25.2.1 Console.WriteLine vs 로깅 프레임워크

초보 개발자들은 디버깅과 정보 출력을 위해 `Console.WriteLine`을 자주 사용합니다. 간단한 프로그램에서는 문제가 없지만, 실무 애플리케이션에서는 여러 한계가 있습니다.

**Console.WriteLine의 한계:**

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("프로그램 시작");
        
        try
        {
            ProcessData();
            Console.WriteLine("데이터 처리 완료");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"오류 발생: {ex.Message}");
        }
        
        Console.WriteLine("프로그램 종료");
    }
    
    static void ProcessData()
    {
        Console.WriteLine("데이터 처리 중...");
        // 실제 처리 로직
    }
}
```

**문제점:**

1. **레벨 구분 없음**: 정보성 메시지, 경고, 오류가 모두 같은 방식으로 출력됩니다
2. **파일 저장 불가**: 콘솔에만 출력되어 나중에 분석할 수 없습니다
3. **필터링 어려움**: 특정 종류의 메시지만 보거나 끌 수 없습니다
4. **타임스탬프 없음**: 언제 발생했는지 알 수 없습니다
5. **구조화 부족**: 검색과 분석이 어렵습니다
6. **프로덕션 부적합**: 서비스 애플리케이션에서는 콘솔이 없을 수 있습니다

**로깅 프레임워크의 장점:**

```csharp
using System;
using Microsoft.Extensions.Logging;

class Program
{
    // 로깅 프레임워크는 다음과 같은 기능을 제공합니다:
    // - 로그 레벨 (Trace, Debug, Information, Warning, Error, Critical)
    // - 다양한 출력 대상 (콘솔, 파일, 데이터베이스, 클라우드)
    // - 타임스탬프와 컨텍스트 정보 자동 추가
    // - 환경별 설정 (개발/테스트/프로덕션)
    // - 구조화된 로깅 (검색과 필터링 용이)
    // - 비동기 로깅 (성능 최적화)
}
```

**비교 예제:**

```csharp
// ❌ Console.WriteLine 방식
Console.WriteLine("사용자 홍길동이 로그인했습니다");
Console.WriteLine($"오류: 파일을 찾을 수 없음 - {filePath}");

// ✅ 로깅 프레임워크 방식
logger.LogInformation("사용자 {UserName}이 로그인했습니다", "홍길동");
logger.LogError("파일을 찾을 수 없음: {FilePath}", filePath);
```

로깅 프레임워크는 다음 섹션에서 자세히 다룹니다.

### 25.2.2 Microsoft.Extensions.Logging

`Microsoft.Extensions.Logging`은 .NET의 표준 로깅 추상화(abstraction)입니다. 이를 사용하면 로깅 프레임워크에 독립적인 코드를 작성할 수 있으며, 나중에 실제 로깅 구현체(Serilog, NLog 등)를 쉽게 교체할 수 있습니다.

**설치:**

```bash
# .NET 프로젝트에 로깅 패키지 추가
dotnet add package Microsoft.Extensions.Logging
dotnet add package Microsoft.Extensions.Logging.Console
```

**기본 설정과 사용:**

```csharp
using System;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

class Program
{
    static void Main()
    {
        // 1. 서비스 컬렉션 생성 (의존성 주입 컨테이너)
        var serviceProvider = new ServiceCollection()
            .AddLogging(builder =>
            {
                builder
                    .AddConsole()  // 콘솔 로깅 추가
                    .SetMinimumLevel(LogLevel.Debug);  // 최소 로그 레벨 설정
            })
            .BuildServiceProvider();
        
        // 2. 로거 가져오기
        var logger = serviceProvider.GetRequiredService<ILogger<Program>>();
        
        // 3. 로깅 사용
        logger.LogInformation("애플리케이션 시작");
        
        try
        {
            ProcessOrders(logger);
            logger.LogInformation("주문 처리 완료");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "주문 처리 중 오류 발생");
        }
        
        logger.LogInformation("애플리케이션 종료");
    }
    
    static void ProcessOrders(ILogger logger)
    {
        logger.LogDebug("주문 처리 시작");
        
        // 구조화된 로깅 - 변수를 템플릿으로 전달
        string customerName = "홍길동";
        int orderCount = 5;
        logger.LogInformation(
            "고객 {CustomerName}의 주문 {OrderCount}건 처리",
            customerName,
            orderCount
        );
        
        // 경고 로그
        if (orderCount > 10)
        {
            logger.LogWarning(
                "주문 수가 많습니다: {OrderCount}건",
                orderCount
            );
        }
    }
}
```

**실행 결과:**

```
info: Program[0]
      애플리케이션 시작
dbug: Program[0]
      주문 처리 시작
info: Program[0]
      고객 홍길동의 주문 5건 처리
info: Program[0]
      주문 처리 완료
info: Program[0]
      애플리케이션 종료
```

**구조화된 로깅 (Structured Logging):**

문자열 보간 대신 템플릿과 매개변수를 사용하면 로그를 구조화된 데이터로 저장할 수 있습니다.

```csharp
using System;
using Microsoft.Extensions.Logging;

class OrderProcessor
{
    private readonly ILogger<OrderProcessor> _logger;
    
    public OrderProcessor(ILogger<OrderProcessor> logger)
    {
        _logger = logger;
    }
    
    public void ProcessOrder(int orderId, string customerName, decimal amount)
    {
        // ❌ 나쁜 예: 문자열 보간
        _logger.LogInformation($"주문 처리: {orderId}, 고객: {customerName}, 금액: {amount}");
        
        // ✅ 좋은 예: 구조화된 로깅
        _logger.LogInformation(
            "주문 처리 시작 - OrderId: {OrderId}, Customer: {CustomerName}, Amount: {Amount}",
            orderId,
            customerName,
            amount
        );
        
        // 이렇게 하면 나중에 다음과 같이 검색 가능:
        // - OrderId가 1234인 모든 로그
        // - Amount가 100만원 이상인 주문 로그
        // - 특정 CustomerName의 모든 활동
    }
}
```

**로그 범위 (Log Scopes):**

관련된 로그를 그룹화하여 컨텍스트를 추가할 수 있습니다.

```csharp
using System;
using Microsoft.Extensions.Logging;

class UserService
{
    private readonly ILogger<UserService> _logger;
    
    public UserService(ILogger<UserService> logger)
    {
        _logger = logger;
    }
    
    public void ProcessUserRequest(string userId)
    {
        // 범위 시작 - 이 블록 안의 모든 로그에 UserId 추가
        using (_logger.BeginScope("UserId: {UserId}", userId))
        {
            _logger.LogInformation("사용자 요청 처리 시작");
            
            ValidateUser(userId);
            ProcessData(userId);
            
            _logger.LogInformation("사용자 요청 처리 완료");
        }
    }
    
    private void ValidateUser(string userId)
    {
        _logger.LogDebug("사용자 검증 중");
        // 검증 로직
    }
    
    private void ProcessData(string userId)
    {
        _logger.LogDebug("데이터 처리 중");
        // 처리 로직
    }
}
```

**파일 로깅 추가:**

```bash
# 파일 로깅 패키지 설치
dotnet add package Serilog.Extensions.Logging.File
```

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

var serviceProvider = new ServiceCollection()
    .AddLogging(builder =>
    {
        builder
            .AddConsole()  // 콘솔 출력
            .AddFile("logs/app-{Date}.txt");  // 파일 출력 (일별 로테이션)
    })
    .BuildServiceProvider();
```

### 25.2.3 로그 레벨

로그 레벨은 메시지의 중요도와 상세도를 나타냅니다. 적절한 로그 레벨을 사용하면 환경에 따라 필요한 정보만 기록할 수 있습니다.

**로그 레벨 종류 (낮음 → 높음):**

| 레벨 | 값 | 용도 | 사용 예시 |
|------|----|----|---------|
| **Trace** | 0 | 매우 상세한 추적 정보 | 함수 진입/종료, 루프 반복 |
| **Debug** | 1 | 디버깅 정보 | 변수 값, 중간 계산 결과 |
| **Information** | 2 | 일반 정보성 메시지 | 요청 처리 완료, 상태 변경 |
| **Warning** | 3 | 경고 (문제는 아니지만 주의) | 임계값 근접, 권장하지 않는 사용 |
| **Error** | 4 | 오류 (기능 실패) | 예외 발생, 작업 실패 |
| **Critical** | 5 | 치명적 오류 (시스템 장애) | 서비스 중단, 데이터 손실 |
| **None** | 6 | 로깅 비활성화 | - |

**로그 레벨 사용 예제:**

```csharp
using System;
using Microsoft.Extensions.Logging;

class PaymentService
{
    private readonly ILogger<PaymentService> _logger;
    
    public PaymentService(ILogger<PaymentService> logger)
    {
        _logger = logger;
    }
    
    public bool ProcessPayment(string userId, decimal amount)
    {
        // Trace: 매우 상세한 추적 (개발 시에만)
        _logger.LogTrace(
            "ProcessPayment 메서드 진입 - UserId: {UserId}, Amount: {Amount}",
            userId,
            amount
        );
        
        // Debug: 디버깅 정보
        _logger.LogDebug("결제 유효성 검증 시작");
        
        if (amount <= 0)
        {
            // Warning: 잠재적 문제
            _logger.LogWarning(
                "잘못된 결제 금액 - UserId: {UserId}, Amount: {Amount}",
                userId,
                amount
            );
            return false;
        }
        
        // Information: 정상적인 흐름의 중요 이벤트
        _logger.LogInformation(
            "결제 처리 시작 - UserId: {UserId}, Amount: {Amount:C}",
            userId,
            amount
        );
        
        try
        {
            // 결제 처리 로직
            if (amount > 1000000)
            {
                // Warning: 주의가 필요한 상황
                _logger.LogWarning(
                    "고액 결제 감지 - UserId: {UserId}, Amount: {Amount:C}",
                    userId,
                    amount
                );
            }
            
            // 결제 성공
            _logger.LogInformation(
                "결제 완료 - UserId: {UserId}, Amount: {Amount:C}",
                userId,
                amount
            );
            
            return true;
        }
        catch (PaymentException ex)
        {
            // Error: 복구 가능한 오류
            _logger.LogError(
                ex,
                "결제 실패 - UserId: {UserId}, Amount: {Amount:C}",
                userId,
                amount
            );
            return false;
        }
        catch (Exception ex)
        {
            // Critical: 치명적 오류
            _logger.LogCritical(
                ex,
                "결제 시스템 치명적 오류 - UserId: {UserId}",
                userId
            );
            throw;
        }
    }
}

class PaymentException : Exception
{
    public PaymentException(string message) : base(message) { }
}
```

**환경별 로그 레벨 설정:**

```csharp
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

class Program
{
    static void Main()
    {
        // 환경 변수로 로그 레벨 결정
        string environment = Environment.GetEnvironmentVariable("ENVIRONMENT") ?? "Development";
        
        var serviceProvider = new ServiceCollection()
            .AddLogging(builder =>
            {
                builder.AddConsole();
                
                // 환경별 로그 레벨 설정
                if (environment == "Development")
                {
                    // 개발: 모든 로그 출력
                    builder.SetMinimumLevel(LogLevel.Trace);
                }
                else if (environment == "Staging")
                {
                    // 스테이징: Debug 이상
                    builder.SetMinimumLevel(LogLevel.Debug);
                }
                else // Production
                {
                    // 프로덕션: Information 이상만
                    builder.SetMinimumLevel(LogLevel.Information);
                }
                
                // 특정 네임스페이스의 로그 레벨 조정
                builder.AddFilter("Microsoft", LogLevel.Warning);  // Microsoft 관련은 Warning 이상만
                builder.AddFilter("System", LogLevel.Warning);      // System 관련은 Warning 이상만
            })
            .BuildServiceProvider();
        
        var logger = serviceProvider.GetRequiredService<ILogger<Program>>();
        
        logger.LogTrace("Trace 메시지 - 매우 상세");
        logger.LogDebug("Debug 메시지 - 디버깅");
        logger.LogInformation("Information 메시지 - 일반 정보");
        logger.LogWarning("Warning 메시지 - 경고");
        logger.LogError("Error 메시지 - 오류");
        logger.LogCritical("Critical 메시지 - 치명적");
    }
}
```

**로그 레벨 선택 가이드:**

```csharp
using Microsoft.Extensions.Logging;

class LoggingGuideExample
{
    private readonly ILogger<LoggingGuideExample> _logger;
    
    public void DemonstrateLogLevels()
    {
        // ✅ Trace: 코드 흐름 추적 (매우 빈번, 개발 전용)
        _logger.LogTrace("메서드 시작");
        _logger.LogTrace("루프 반복 {Iteration}회차", 5);
        
        // ✅ Debug: 디버깅에 유용한 정보
        int calculatedValue = 42;
        _logger.LogDebug("계산 결과: {Value}", calculatedValue);
        
        // ✅ Information: 애플리케이션의 정상 흐름
        _logger.LogInformation("사용자 로그인 성공");
        _logger.LogInformation("주문 생성 완료 - OrderId: {OrderId}", 12345);
        
        // ✅ Warning: 문제는 아니지만 주의 필요
        _logger.LogWarning("API 응답 시간이 느립니다: {ElapsedMs}ms", 3000);
        _logger.LogWarning("디스크 사용량 80% 초과");
        
        // ✅ Error: 기능 실패, 예외 발생
        try
        {
            // 오류가 발생할 수 있는 코드
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "파일 처리 실패 - FileName: {FileName}", "data.csv");
        }
        
        // ✅ Critical: 시스템 전체에 영향을 미치는 치명적 오류
        _logger.LogCritical("데이터베이스 연결 불가 - 서비스 중단");
    }
}
```

**appsettings.json을 통한 로그 레벨 설정 (ASP.NET Core):**

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information",
      "MyApp": "Debug"
    }
  }
}
```

**실전 활용 팁:**

1. **개발 환경**: Debug 또는 Trace 레벨로 상세한 정보 확인
2. **프로덕션 환경**: Information 이상으로 설정하여 성능 영향 최소화
3. **오류 추적**: Error와 Critical은 항상 기록하고 알림 설정
4. **성능 모니터링**: Warning으로 성능 저하 조기 감지
5. **로그 볼륨 관리**: Trace와 Debug는 프로덕션에서 비활성화

---

## 25장 정리 및 요약

이 장에서는 효과적인 디버깅과 로깅 전략을 학습했습니다.

### 핵심 내용 요약

**디버깅:**
- Visual Studio Code의 중단점을 활용한 단계별 디버깅
- 변수 검사와 조사식으로 실행 중 상태 확인
- 조건부 중단점으로 특정 상황에서만 실행 중지
- 로그 포인트로 실행 흐름 추적

**로깅:**
- Console.WriteLine의 한계와 로깅 프레임워크의 필요성
- Microsoft.Extensions.Logging을 통한 구조화된 로깅
- 로그 레벨(Trace, Debug, Information, Warning, Error, Critical)의 적절한 사용
- 환경별 로그 설정으로 개발과 프로덕션 환경 분리

### 실습 과제

**초급:**
1. 간단한 계산기 프로그램을 작성하고 디버거로 각 연산 단계를 추적해보세요
2. 조건부 중단점을 사용하여 특정 값에서만 멈추는 프로그램을 만들어보세요
3. ILogger를 사용하여 파일 복사 프로그램에 로깅을 추가해보세요

**중급:**
4. 구조화된 로깅을 활용하여 사용자 활동을 추적하는 웹 애플리케이션 로그를 작성해보세요
5. 로그 범위(BeginScope)를 사용하여 HTTP 요청마다 고유 ID를 부여하는 미들웨어를 구현해보세요
6. 환경 변수에 따라 다른 로그 레벨을 적용하는 설정을 만들어보세요

**고급:**
7. Serilog와 같은 고급 로깅 라이브러리를 통합하고 파일, 콘솔, Elasticsearch 등 다중 출력을 구성해보세요
8. 로그 분석 도구를 사용하여 성능 병목 지점을 찾아보세요
9. 예외 발생 시 자동으로 상세 로그를 남기고 알림을 보내는 시스템을 구현해보세요

### 다음 단계

이제 디버깅과 로깅의 기초를 다졌으니, 다음 주제들을 탐구해보세요:

- **고급 디버깅**: 메모리 덤프 분석, 성능 프로파일링, 원격 디버깅
- **분산 추적**: 마이크로서비스 환경에서의 로그 추적과 상관관계 분석
- **로그 집계**: ELK Stack (Elasticsearch, Logstash, Kibana) 활용
- **관측성(Observability)**: 로그, 메트릭, 트레이스를 통합한 시스템 모니터링

디버깅과 로깅은 소프트웨어 개발과 운영의 필수 기술입니다. 이 장에서 배운 내용을 바탕으로 더 견고하고 관측 가능한 애플리케이션을 만들어보세요!
