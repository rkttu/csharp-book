# 31장. C# 12 주요 기능

C# 12는 2023년 11월 .NET 8과 함께 출시된 버전으로, 주 생성자(Primary Constructors), 컬렉션 식(Collection Expressions), 그리고 람다의 개선을 중심으로 한 주요 릴리스입니다. 이 버전은 코드의 간결성을 더욱 높이고, 객체 생성과 컬렉션 초기화를 현대적이고 직관적으로 만드는 데 초점을 맞췄습니다.

**C# 12의 설계 철학:**

1. **간결성(Conciseness)**: 주 생성자를 통해 클래스 정의를 더욱 간소화합니다.
2. **일관성(Consistency)**: 컬렉션 식으로 모든 컬렉션 타입을 통일된 방식으로 초기화합니다.
3. **표현력(Expressiveness)**: 람다 식의 기본 매개변수로 더 유연한 함수 정의를 가능하게 합니다.
4. **성능(Performance)**: Inline arrays로 고성능 시나리오를 지원합니다.

## 이 장에서 배울 내용

- **Primary constructors**: 클래스와 구조체에서 간결한 생성자 정의
- **Collection expressions**: 통일된 컬렉션 초기화 구문
- **Default lambda parameters**: 람다 식에서 기본 매개변수 사용
- **Alias any type**: using 별칭으로 모든 타입 지원
- **Inline arrays**: 고성능 고정 크기 배열
- **ref readonly parameters**: 참조로 전달하되 읽기 전용으로 제한

---

## 31.1 Primary Constructors (주 생성자)

Primary constructors는 C# 12의 가장 주목할 만한 기능으로, 클래스나 구조체의 선언부에 직접 생성자 매개변수를 정의할 수 있게 합니다. 이는 record 타입에서만 가능했던 기능을 일반 클래스와 구조체로 확장한 것입니다.

**문제 상황 - 전통적 접근의 한계:**

기존에는 생성자 매개변수를 필드에 할당하는 보일러플레이트 코드가 많이 필요했습니다:

```csharp
// 전통적인 방식
public class Person
{
    private readonly string _firstName;
    private readonly string _lastName;
    
    public Person(string firstName, string lastName)
    {
        _firstName = firstName;
        _lastName = lastName;
    }
    
    public string FullName => $"{_firstName} {_lastName}";
}
```

**Primary Constructors의 해결책:**

```csharp
// C# 12 - 주 생성자
public class Person(string firstName, string lastName)
{
    public string FullName => $"{firstName} {lastName}";
    
    public void Introduce()
    {
        Console.WriteLine($"안녕하세요, {firstName} {lastName}입니다.");
    }
}

// 사용
var person = new Person("홍", "길동");
Console.WriteLine(person.FullName);  // 홍 길동
person.Introduce();  // 안녕하세요, 홍 길동입니다.
```

**의존성 주입과 함께 사용:**

```csharp
// 서비스 클래스
public class UserService(IUserRepository repository, ILogger logger)
{
    public User GetUser(int id)
    {
        logger.LogInformation($"사용자 {id} 조회 중");
        return repository.GetById(id);
    }
    
    public void SaveUser(User user)
    {
        logger.LogInformation($"사용자 {user.Id} 저장 중");
        repository.Save(user);
    }
}

// 인터페이스와 모의 구현
public interface IUserRepository
{
    User GetById(int id);
    void Save(User user);
}

public interface ILogger
{
    void LogInformation(string message);
}
```

**속성과 함께 사용:**

```csharp
public class Product(string name, decimal price)
{
    // 주 생성자 매개변수를 속성으로 노출
    public string Name { get; } = name;
    public decimal Price { get; set; } = price;
    
    // 추가 속성
    public decimal Discount { get; set; }
    
    public decimal FinalPrice => Price * (1 - Discount);
}

var product = new Product("노트북", 1500000)
{
    Discount = 0.1m  // 10% 할인
};

Console.WriteLine($"{product.Name}: {product.FinalPrice:C}");
```

**주의사항:**
- 주 생성자 매개변수는 클래스 전체에서 사용 가능합니다.
- 명시적으로 필드나 속성으로 저장하지 않으면 캡처되어 보관됩니다.
- record 타입과 달리 자동으로 속성이 생성되지 않습니다.

---

## 31.2 Collection Expressions (컬렉션 식)

Collection expressions는 배열, 리스트, 스팬 등 모든 컬렉션 타입을 통일된 문법으로 초기화할 수 있게 하는 혁신적인 기능입니다.

**기본 문법:**

```csharp
// 배열
int[] array = [1, 2, 3, 4, 5];

// 리스트
List<int> list = [1, 2, 3, 4, 5];

// Span
Span<int> span = [1, 2, 3, 4, 5];

// ImmutableArray
ImmutableArray<int> immutable = [1, 2, 3, 4, 5];

// 모두 동일한 문법!
```

**스프레드 연산자 (..):**

기존 컬렉션을 펼쳐서 새로운 컬렉션을 만들 수 있습니다:

```csharp
int[] numbers1 = [1, 2, 3];
int[] numbers2 = [4, 5, 6];

// 두 배열 결합
int[] combined = [.. numbers1, .. numbers2];
// 결과: [1, 2, 3, 4, 5, 6]

// 중간에 요소 추가
int[] extended = [0, .. numbers1, 99, .. numbers2, 100];
// 결과: [0, 1, 2, 3, 99, 4, 5, 6, 100]
```

**실전 예제 - 데이터 변환:**

```csharp
// 여러 소스에서 데이터 수집
List<string> GetAllNames(User[] users, Admin[] admins, Guest[] guests)
{
    return [
        .. users.Select(u => u.Name),
        .. admins.Select(a => a.Name),
        .. guests.Select(g => g.Name)
    ];
}

// 필터링과 결합
List<int> GetValidScores(int[] scores1, int[] scores2)
{
    return [
        .. scores1.Where(s => s >= 0),
        .. scores2.Where(s => s >= 0)
    ];
}

// 사용
var users = new[] 
{ 
    new User { Name = "홍길동" }, 
    new User { Name = "김철수" } 
};
var admins = new[] 
{ 
    new Admin { Name = "관리자1" } 
};
var guests = new[] 
{ 
    new Guest { Name = "게스트1" } 
};

var allNames = GetAllNames(users, admins, guests);
Console.WriteLine(string.Join(", ", allNames));
```

**빈 컬렉션:**

```csharp
// 빈 컬렉션 생성
List<int> empty = [];
int[] emptyArray = [];

// 조건부 컬렉션
List<int> GetNumbers(bool includeNegative)
{
    return includeNegative 
        ? [-1, 0, 1, 2, 3]
        : [0, 1, 2, 3];
}
```

**메서드 매개변수:**

```csharp
void PrintNumbers(List<int> numbers)
{
    Console.WriteLine(string.Join(", ", numbers));
}

// 직접 컬렉션 식 전달
PrintNumbers([1, 2, 3, 4, 5]);

// 여러 소스 결합하여 전달
int[] a = [1, 2];
int[] b = [3, 4];
PrintNumbers([.. a, .. b, 5]);
```

---

## 31.3 Default Lambda Parameters (람다 기본 매개변수)

C# 12에서는 람다 식에서도 메서드처럼 기본 매개변수를 사용할 수 있게 되었습니다.

**기본 사용법:**

```csharp
// 람다에 기본 매개변수
var greet = (string name = "손님") => $"안녕하세요, {name}님!";

Console.WriteLine(greet());          // 안녕하세요, 손님님!
Console.WriteLine(greet("홍길동"));   // 안녕하세요, 홍길동님!

// 여러 매개변수
var calculate = (int x, int y = 10) => x + y;

Console.WriteLine(calculate(5));      // 15
Console.WriteLine(calculate(5, 20));  // 25
```

**실전 예제 - 유연한 필터:**

```csharp
// 기본값이 있는 필터 함수
var filterByAge = (List<Person> people, int minAge = 0, int maxAge = 150) 
    => people.Where(p => p.Age >= minAge && p.Age <= maxAge).ToList();

var people = new List<Person>
{
    new("홍길동", 25),
    new("김철수", 35),
    new("이영희", 45)
};

// 기본값 사용 - 모든 연령
var all = filterByAge(people);

// 최소 연령만 지정
var over30 = filterByAge(people, 30);

// 범위 지정
var between30And40 = filterByAge(people, 30, 40);

public record Person(string Name, int Age);
```

**델리게이트와 함께:**

```csharp
Func<int, int, int> power = (int baseNum, int exponent = 2) 
    => (int)Math.Pow(baseNum, exponent);

Console.WriteLine(power(5));      // 25 (5^2)
Console.WriteLine(power(5, 3));   // 125 (5^3)
```

---

## 31.4 Alias Any Type (타입 별칭 확장)

C# 12에서는 `using` 별칭을 통해 튜플, 배열, 포인터 등 모든 타입에 대한 별칭을 만들 수 있게 되었습니다.

**기본 사용법:**

```csharp
// 튜플 별칭
using Point = (int X, int Y);
using Point3D = (int X, int Y, int Z);

// 복잡한 제네릭 타입
using StringDictionary = System.Collections.Generic.Dictionary<string, string>;
using IntList = System.Collections.Generic.List<int>;

// 사용
Point p = (10, 20);
Console.WriteLine($"좌표: ({p.X}, {p.Y})");

Point3D p3d = (10, 20, 30);
Console.WriteLine($"3D 좌표: ({p3d.X}, {p3d.Y}, {p3d.Z})");
```

**실전 예제 - 복잡한 타입 간소화:**

```csharp
// 복잡한 중첩 제네릭
using UserCache = System.Collections.Generic.Dictionary<
    string, 
    System.Collections.Generic.List<(int Id, string Name, System.DateTime LastLogin)>
>;

// 간단하게 사용
UserCache cache = new();
cache["admin"] = [(1, "관리자", DateTime.Now)];

// 함수 시그니처
using Validator = System.Func<string, (bool IsValid, string Message)>;

Validator emailValidator = email =>
{
    bool isValid = email.Contains("@");
    return (isValid, isValid ? "유효함" : "유효하지 않음");
};

var result = emailValidator("test@example.com");
Console.WriteLine($"결과: {result.Message}");
```

**배열 별칭:**

```csharp
using IntArray = int[];
using Matrix = int[][];

IntArray numbers = [1, 2, 3, 4, 5];
Matrix matrix = [[1, 2], [3, 4], [5, 6]];
```

---

## 31.5 Inline Arrays (인라인 배열)

Inline arrays는 구조체 내에 고정 크기 배열을 효율적으로 정의할 수 있게 하는 고급 기능입니다. 주로 고성능 시나리오에서 사용됩니다.

**기본 정의:**

```csharp
using System.Runtime.CompilerServices;

[InlineArray(10)]
public struct Buffer10
{
    private int _element0;
}

// 사용
Buffer10 buffer = default;
buffer[0] = 1;
buffer[1] = 2;

for (int i = 0; i < 10; i++)
{
    buffer[i] = i * 10;
}

// 배열처럼 접근
foreach (int value in buffer)
{
    Console.Write($"{value} ");
}
// 출력: 0 10 20 30 40 50 60 70 80 90
```

**Span과 함께 사용:**

```csharp
[InlineArray(100)]
public struct LargeBuffer
{
    private byte _element0;
}

void ProcessData()
{
    LargeBuffer buffer = default;
    Span<byte> span = buffer;
    
    // Span 연산 활용
    span.Fill(0xFF);
    span[0] = 0x00;
    span[99] = 0x00;
}
```

**주의사항:**
- 고성능이 중요한 시나리오에서만 사용
- 일반적인 컬렉션이 필요한 경우 List<T> 사용 권장
- stackalloc과 유사한 성능 특성

---

## 31.6 ref readonly Parameters (ref readonly 매개변수)

`ref readonly` 매개변수는 값을 참조로 전달하되, 메서드 내에서 수정할 수 없게 합니다. 이는 대형 구조체를 효율적으로 전달하면서도 안전성을 보장합니다.

**기본 사용법:**

```csharp
// 대형 구조체
public struct LargeStruct
{
    public int[] Data;
    public string Description;
    
    public LargeStruct()
    {
        Data = new int[1000];
        Description = "Large data structure";
    }
}

// ref readonly로 효율적이고 안전하게 전달
void ProcessData(ref readonly LargeStruct data)
{
    // 읽기는 가능
    Console.WriteLine(data.Description);
    Console.WriteLine($"데이터 크기: {data.Data.Length}");
    
    // 컴파일 오류! 수정 불가
    // data.Description = "Modified";
}

// 사용
LargeStruct largeData = new();
ProcessData(ref largeData);
```

**in vs ref readonly:**

```csharp
// in 매개변수 (C# 7.2)
void MethodWithIn(in int value)
{
    // 읽기만 가능
    Console.WriteLine(value);
}

// ref readonly 매개변수 (C# 12)
void MethodWithRefReadonly(ref readonly int value)
{
    // 읽기만 가능, 명시적으로 ref로 전달 필요
    Console.WriteLine(value);
}

int x = 10;
MethodWithIn(x);           // ref 없이 호출 가능
MethodWithRefReadonly(ref x);  // ref 필요
```

**실전 예제 - 성능 최적화:**

```csharp
public struct Vector3D
{
    public double X, Y, Z;
    
    public Vector3D(double x, double y, double z)
    {
        X = x; Y = y; Z = z;
    }
}

// 효율적인 벡터 연산
double DotProduct(ref readonly Vector3D a, ref readonly Vector3D b)
{
    return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
}

Vector3D v1 = new(1, 2, 3);
Vector3D v2 = new(4, 5, 6);
double result = DotProduct(ref v1, ref v2);
Console.WriteLine($"내적: {result}");  // 32
```

---

## 31.7 실전 종합 예제

C# 12의 여러 기능을 활용한 실용적인 예제입니다:

```csharp
// 주 생성자 사용
public class TodoService(ITodoRepository repository, ILogger logger)
{
    // 컬렉션 식 사용
    public List<Todo> GetAllTodos() => [.. repository.GetAll()];
    
    public List<Todo> GetTodosByStatus(TodoStatus status = TodoStatus.Pending)
    {
        logger.LogInfo($"상태별 할 일 조회: {status}");
        return [.. repository.GetAll().Where(t => t.Status == status)];
    }
    
    public List<Todo> GetCombinedTodos(List<Todo> personal, List<Todo> work)
    {
        // 스프레드 연산자로 병합
        return [.. personal, .. work];
    }
    
    public void ProcessBatch(ref readonly TodoBatch batch)
    {
        logger.LogInfo($"배치 처리: {batch.Items.Length}개 항목");
        foreach (var item in batch.Items)
        {
            repository.Save(item);
        }
    }
}

// 타입 별칭
using TodoList = System.Collections.Generic.List<Todo>;
using TodoValidator = System.Func<Todo, (bool IsValid, string Message)>;

public class Todo(int id, string title)
{
    public int Id { get; } = id;
    public string Title { get; set; } = title;
    public TodoStatus Status { get; set; } = TodoStatus.Pending;
    public DateTime CreatedAt { get; init; } = DateTime.Now;
}

public enum TodoStatus
{
    Pending,
    InProgress,
    Completed
}

// 인라인 배열 사용
[InlineArray(50)]
public struct TodoBatch
{
    public Todo _element0;
}

// 인터페이스
public interface ITodoRepository
{
    IEnumerable<Todo> GetAll();
    void Save(Todo todo);
}

public interface ILogger
{
    void LogInfo(string message);
}

// 람다 기본 매개변수
TodoValidator CreateValidator(int maxTitleLength = 100)
{
    return todo =>
    {
        if (string.IsNullOrEmpty(todo.Title))
            return (false, "제목이 비어있습니다");
        if (todo.Title.Length > maxTitleLength)
            return (false, $"제목이 너무 깁니다 (최대 {maxTitleLength}자)");
        return (true, "유효합니다");
    };
}

// 사용 예제
var mockRepo = new MockTodoRepository();
var mockLogger = new MockLogger();
var service = new TodoService(mockRepo, mockLogger);

// 컬렉션 식으로 할 일 생성
TodoList todos = 
[
    new(1, "C# 12 학습"),
    new(2, "프로젝트 완료"),
    new(3, "코드 리뷰")
];

foreach (var todo in todos)
{
    mockRepo.Save(todo);
}

// 기본 매개변수 사용
var pending = service.GetTodosByStatus();
var completed = service.GetTodosByStatus(TodoStatus.Completed);

Console.WriteLine($"대기 중: {pending.Count}개");
Console.WriteLine($"완료: {completed.Count}개");

// Mock 구현
class MockTodoRepository : ITodoRepository
{
    private readonly List<Todo> _todos = [];
    
    public IEnumerable<Todo> GetAll() => _todos;
    public void Save(Todo todo) => _todos.Add(todo);
}

class MockLogger : ILogger
{
    public void LogInfo(string message) => Console.WriteLine($"[INFO] {message}");
}
```

---

## 31.8 마치며

C# 12는 코드의 간결성과 표현력을 크게 향상시킨 중요한 릴리스입니다. Primary constructors는 클래스 정의를 더 간단하게 만들고, collection expressions는 컬렉션 초기화를 통일되고 직관적으로 만들며, 람다 기본 매개변수는 함수형 프로그래밍을 더욱 유연하게 만듭니다.

**학습한 내용 요약:**
- Primary constructors로 간결한 클래스 정의
- Collection expressions로 통일된 컬렉션 초기화
- Default lambda parameters로 유연한 람다 식
- Alias any type으로 복잡한 타입 간소화
- Inline arrays로 고성능 시나리오 지원
- ref readonly parameters로 안전한 참조 전달

**다음 단계:**
- 실제 프로젝트에 C# 12 기능 적용
- C# 13의 새로운 기능 학습
- 성능 최적화 기법 더 깊이 탐구

**참고 자료:**
- [C# 12의 새로운 기능](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-12)
- [Primary constructors](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-12#primary-constructors)
- [Collection expressions](https://learn.microsoft.com/ko-kr/dotnet/csharp/whats-new/csharp-12#collection-expressions)
