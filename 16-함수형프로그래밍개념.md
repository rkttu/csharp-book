# 16장. 함수형 프로그래밍 개념

함수형 프로그래밍(Functional Programming, FP)은 계산을 수학적 함수의 평가로 다루는 프로그래밍 패러다임입니다. C#은 객체지향 언어이지만, 람다 식과 LINQ 도입 이후 함수형 프로그래밍의 핵심 개념들을 지원하여 다중 패러다임 언어로 진화했습니다. 이 장에서는 함수형 프로그래밍의 핵심 개념들을 C#으로 구현하고 활용하는 방법을 학습합니다.

함수형 프로그래밍의 주요 원칙은 다음과 같습니다:
- **불변성(Immutability)**: 데이터를 변경하지 않고 새로운 데이터를 생성
- **순수 함수(Pure Functions)**: 부작용이 없고 같은 입력에 항상 같은 출력을 반환
- **일급 함수(First-class Functions)**: 함수를 값처럼 다루고 전달
- **고차 함수(Higher-order Functions)**: 함수를 인자로 받거나 반환하는 함수

이러한 개념들은 코드의 예측 가능성을 높이고, 테스트를 쉽게 만들며, 병렬 처리와 동시성 프로그래밍을 안전하게 구현할 수 있게 해줍니다.

## 이 장에서 배울 내용

- **불변성의 이해와 활용**: 데이터를 변경하지 않는 프로그래밍 방식과 C#에서의 불변 객체 구현
- **순수 함수 작성**: 부작용이 없는 함수를 작성하여 코드의 예측 가능성 향상
- **고차 함수 활용**: 함수를 인자로 받거나 반환하는 함수를 통한 추상화
- **커링과 부분 적용**: 여러 인자를 받는 함수를 단일 인자 함수의 체인으로 변환

---

## 16.1 불변성 (Immutability)

불변성은 함수형 프로그래밍의 가장 핵심적인 개념입니다. 불변(Immutable) 객체는 일단 생성된 후에는 그 상태를 변경할 수 없는 객체를 말합니다. 데이터를 수정하는 대신, 수정된 복사본을 새로 만들어 반환합니다.

**불변성의 장점:**
- **예측 가능성**: 객체의 상태가 변하지 않으므로 동작을 예측하기 쉬움
- **스레드 안전성**: 여러 스레드가 동시에 접근해도 안전함
- **디버깅 용이**: 상태 변경을 추적할 필요가 없어 디버깅이 쉬움
- **시간 여행**: 이전 상태를 쉽게 보관하고 되돌릴 수 있음

### 가변 vs 불변 비교

```csharp
// 가변(Mutable) 방식 - 상태가 변경됨
class MutablePerson
{
    public string Name { get; set; }
    public int Age { get; set; }
}

var person = new MutablePerson { Name = "홍길동", Age = 25 };
person.Age = 26;  // 원본 객체가 수정됨
Console.WriteLine($"나이: {person.Age}");
// 출력: 나이: 26

// 불변(Immutable) 방식 - 새로운 객체 생성
record ImmutablePerson(string Name, int Age);

var person2 = new ImmutablePerson("김철수", 25);
var olderPerson = person2 with { Age = 26 };  // 새로운 객체 생성
Console.WriteLine($"원본 나이: {person2.Age}");
Console.WriteLine($"새 나이: {olderPerson.Age}");
// 출력:
// 원본 나이: 25
// 새 나이: 26
```

### C#의 불변 타입

C#에는 기본적으로 불변인 타입들이 있습니다:

```csharp
// string은 불변 타입
string text = "Hello";
string upper = text.ToUpper();  // 새로운 문자열 생성
Console.WriteLine($"원본: {text}");
Console.WriteLine($"대문자: {upper}");
// 출력:
// 원본: Hello
// 대문자: HELLO

// DateTime도 불변 타입
DateTime date = DateTime.Now;
DateTime nextDay = date.AddDays(1);  // 새로운 DateTime 생성
Console.WriteLine($"오늘: {date:yyyy-MM-dd}");
Console.WriteLine($"내일: {nextDay:yyyy-MM-dd}");
```

### record를 사용한 불변 객체

C# 9.0에서 도입된 `record` 키워드는 불변 객체를 쉽게 만들 수 있게 해줍니다:

```csharp
// 불변 레코드 정의
record Point(int X, int Y);

var p1 = new Point(10, 20);

// with 식을 사용한 복사 및 수정
var p2 = p1 with { X = 30 };

Console.WriteLine($"p1: ({p1.X}, {p1.Y})");
Console.WriteLine($"p2: ({p2.X}, {p2.Y})");
// 출력:
// p1: (10, 20)
// p2: (30, 20)
```

### 불변 컬렉션

불변 컬렉션은 생성 후 내용을 변경할 수 없는 컬렉션입니다:

```csharp
// 일반 리스트 (가변)
List<int> mutableList = new List<int> { 1, 2, 3 };
mutableList.Add(4);  // 원본이 수정됨

// 불변 리스트 패턴
List<int> numbers = new List<int> { 1, 2, 3 };

// 새로운 요소를 추가한 새 리스트 생성
List<int> newNumbers = new List<int>(numbers) { 4 };

Console.WriteLine($"원본: {string.Join(", ", numbers)}");
Console.WriteLine($"새 리스트: {string.Join(", ", newNumbers)}");
// 출력:
// 원본: 1, 2, 3
// 새 리스트: 1, 2, 3, 4
```

### LINQ와 불변성

LINQ 메서드들은 원본 컬렉션을 변경하지 않고 새로운 컬렉션을 반환합니다:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

// Where는 원본을 변경하지 않음
var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();

Console.WriteLine($"원본: {string.Join(", ", numbers)}");
Console.WriteLine($"짝수: {string.Join(", ", evenNumbers)}");
// 출력:
// 원본: 1, 2, 3, 4, 5
// 짝수: 2, 4
```

### 실용 예제 - 불변 계좌

```csharp
record BankAccount(string Owner, decimal Balance)
{
    // 입금 - 새로운 계좌 객체 반환
    public BankAccount Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("입금액은 양수여야 합니다.");
        return this with { Balance = Balance + amount };
    }
    
    // 출금 - 새로운 계좌 객체 반환
    public BankAccount Withdraw(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("출금액은 양수여야 합니다.");
        if (Balance < amount)
            throw new InvalidOperationException("잔액이 부족합니다.");
        return this with { Balance = Balance - amount };
    }
}

// 사용 예제
var account = new BankAccount("홍길동", 1000);
Console.WriteLine($"초기 잔액: {account.Balance}원");

var account2 = account.Deposit(500);
Console.WriteLine($"입금 후: {account2.Balance}원");

var account3 = account2.Withdraw(300);
Console.WriteLine($"출금 후: {account3.Balance}원");

Console.WriteLine($"원본 계좌: {account.Balance}원");
// 출력:
// 초기 잔액: 1000원
// 입금 후: 1500원
// 출금 후: 1200원
// 원본 계좌: 1000원
```

---

## 16.2 순수 함수 (Pure Functions)

순수 함수는 다음 두 가지 특성을 만족하는 함수입니다:
1. **참조 투명성(Referential Transparency)**: 같은 입력에 대해 항상 같은 출력을 반환
2. **부작용 없음(No Side Effects)**: 함수 외부의 상태를 변경하지 않음

순수 함수는 테스트하기 쉽고, 이해하기 쉬우며, 재사용하기 좋습니다.

### 순수 함수 vs 비순수 함수

```csharp
// ❌ 비순수 함수 - 외부 상태에 의존
int externalValue = 10;
int ImpureAdd(int x)
{
    return x + externalValue;  // 외부 변수에 의존
}

// ❌ 비순수 함수 - 부작용이 있음
int counter = 0;
int ImpureIncrement()
{
    counter++;  // 외부 상태를 변경
    return counter;
}

// ❌ 비순수 함수 - 랜덤값 반환
int ImpureRandom()
{
    return new Random().Next();  // 매번 다른 값 반환
}

// ✅ 순수 함수 - 입력만 사용, 부작용 없음
int PureAdd(int x, int y)
{
    return x + y;
}

// 테스트
Console.WriteLine($"5 + 3 = {PureAdd(5, 3)}");
Console.WriteLine($"5 + 3 = {PureAdd(5, 3)}");
// 출력: (항상 같은 결과)
// 5 + 3 = 8
// 5 + 3 = 8
```

### 순수 함수의 예제

```csharp
// ✅ 순수 함수 - 문자열 변환
string ToUpperCase(string text)
{
    return text.ToUpper();
}

// ✅ 순수 함수 - 리스트 필터링
List<int> FilterEven(List<int> numbers)
{
    return numbers.Where(n => n % 2 == 0).ToList();
}

// ✅ 순수 함수 - 계산
double CalculateArea(double radius)
{
    return Math.PI * radius * radius;
}

// 사용 예제
Console.WriteLine(ToUpperCase("hello"));
Console.WriteLine(string.Join(", ", FilterEven(new List<int> { 1, 2, 3, 4, 5 })));
Console.WriteLine($"원의 넓이: {CalculateArea(5):F2}");
// 출력:
// HELLO
// 2, 4
// 원의 넓이: 78.54
```

### 부작용의 종류

함수형 프로그래밍에서 피해야 할 부작용들:

```csharp
// ❌ 콘솔 출력 (I/O는 부작용)
void LogMessage(string message)
{
    Console.WriteLine(message);  // 외부 세계와 상호작용
}

// ❌ 파일 쓰기 (I/O는 부작용)
void SaveToFile(string data)
{
    File.WriteAllText("data.txt", data);  // 파일 시스템 변경
}

// ❌ 전역 변수 수정
int globalCounter = 0;
void IncrementGlobal()
{
    globalCounter++;  // 전역 상태 변경
}

// ❌ 인자로 받은 객체 수정
void ModifyList(List<int> list)
{
    list.Add(100);  // 외부 리스트 수정
}
```

### 순수 함수로 리팩토링

비순수 함수를 순수 함수로 변환하는 방법:

```csharp
// ❌ 비순수 함수
class Calculator
{
    private int total = 0;
    
    public void Add(int value)
    {
        total += value;  // 상태 변경
    }
    
    public int GetTotal()
    {
        return total;
    }
}

// ✅ 순수 함수 스타일
record CalculatorState(int Total)
{
    public CalculatorState Add(int value)
    {
        return new CalculatorState(Total + value);
    }
}

// 사용 예제
var calc = new CalculatorState(0);
var calc2 = calc.Add(10);
var calc3 = calc2.Add(20);

Console.WriteLine($"초기: {calc.Total}");
Console.WriteLine($"10 추가: {calc2.Total}");
Console.WriteLine($"20 추가: {calc3.Total}");
// 출력:
// 초기: 0
// 10 추가: 10
// 20 추가: 30
```

### 순수 함수를 사용한 데이터 변환

```csharp
record Student(string Name, int Score);

// 순수 함수들
bool IsPass(Student student) => student.Score >= 60;
string GetGrade(int score) =>
    score >= 90 ? "A" :
    score >= 80 ? "B" :
    score >= 70 ? "C" :
    score >= 60 ? "D" : "F";

// 데이터 처리
var students = new List<Student>
{
    new("홍길동", 85),
    new("김철수", 92),
    new("이영희", 78),
    new("박민수", 55)
};

// 순수 함수를 조합하여 데이터 처리
var passedStudents = students
    .Where(IsPass)
    .Select(s => new { s.Name, Grade = GetGrade(s.Score) })
    .ToList();

Console.WriteLine("합격 학생:");
foreach (var student in passedStudents)
{
    Console.WriteLine($"- {student.Name}: {student.Grade}");
}
// 출력:
// 합격 학생:
// - 홍길동: B
// - 김철수: A
// - 이영희: C
```

---

## 16.3 고차 함수 (Higher-Order Functions)

고차 함수는 다음 중 하나 이상을 수행하는 함수입니다:
1. 함수를 인자로 받음
2. 함수를 반환값으로 돌려줌

고차 함수는 코드의 재사용성과 추상화 수준을 크게 높여줍니다.

### 함수를 인자로 받는 함수

```csharp
// 고차 함수: 리스트와 변환 함수를 받음
List<int> Transform(List<int> numbers, Func<int, int> operation)
{
    var result = new List<int>();
    foreach (int num in numbers)
    {
        result.Add(operation(num));
    }
    return result;
}

// 사용 예제
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

var doubled = Transform(numbers, x => x * 2);
var squared = Transform(numbers, x => x * x);
var plusTen = Transform(numbers, x => x + 10);

Console.WriteLine($"2배: {string.Join(", ", doubled)}");
Console.WriteLine($"제곱: {string.Join(", ", squared)}");
Console.WriteLine($"+10: {string.Join(", ", plusTen)}");
// 출력:
// 2배: 2, 4, 6, 8, 10
// 제곱: 1, 4, 9, 16, 25
// +10: 11, 12, 13, 14, 15
```

### 함수를 반환하는 함수

```csharp
// 고차 함수: 함수를 반환
Func<int, int> MakeMultiplier(int factor)
{
    return x => x * factor;
}

// 특정 배수를 만드는 함수들 생성
var double = MakeMultiplier(2);
var triple = MakeMultiplier(3);
var quadruple = MakeMultiplier(4);

Console.WriteLine($"5의 2배: {double(5)}");
Console.WriteLine($"5의 3배: {triple(5)}");
Console.WriteLine($"5의 4배: {quadruple(5)}");
// 출력:
// 5의 2배: 10
// 5의 3배: 15
// 5의 4배: 20
```

### LINQ의 고차 함수

LINQ의 많은 메서드들이 고차 함수입니다:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Where - 술어 함수를 받음
var evens = numbers.Where(n => n % 2 == 0);
Console.WriteLine($"짝수: {string.Join(", ", evens)}");

// Select - 변환 함수를 받음
var squares = numbers.Select(n => n * n);
Console.WriteLine($"제곱: {string.Join(", ", squares)}");

// OrderBy - 키 선택 함수를 받음
var descending = numbers.OrderByDescending(n => n);
Console.WriteLine($"내림차순: {string.Join(", ", descending)}");

// Aggregate - 누산 함수를 받음
var sum = numbers.Aggregate(0, (acc, n) => acc + n);
Console.WriteLine($"합계: {sum}");
// 출력:
// 짝수: 2, 4, 6, 8, 10
// 제곱: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
// 내림차순: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
// 합계: 55
```

### 함수 합성 (Function Composition)

여러 함수를 조합하여 새로운 함수를 만드는 기법:

```csharp
// 함수 합성 헬퍼
Func<A, C> Compose<A, B, C>(Func<A, B> f, Func<B, C> g)
{
    return x => g(f(x));
}

// 개별 함수들
Func<int, int> addTwo = x => x + 2;
Func<int, int> multiplyThree = x => x * 3;
Func<int, string> toString = x => $"결과: {x}";

// 함수 합성
var addThenMultiply = Compose(addTwo, multiplyThree);
var fullPipeline = Compose(addThenMultiply, toString);

Console.WriteLine(fullPipeline(5));
// 출력: 결과: 21
// (5 + 2) * 3 = 21
```

### 실용 예제 - 데이터 처리 파이프라인

```csharp
// 데이터 처리 함수들
Func<string, string> trimWhitespace = s => s.Trim();
Func<string, string> toLowerCase = s => s.ToLower();
Func<string, bool> isNotEmpty = s => !string.IsNullOrEmpty(s);
Func<string, int> countWords = s => s.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;

// 고차 함수를 사용한 파이프라인
List<string> texts = new List<string>
{
    "  Hello World  ",
    "   ",
    "C# Programming",
    "  Functional  Programming  "
};

var wordCounts = texts
    .Select(trimWhitespace)
    .Where(isNotEmpty)
    .Select(toLowerCase)
    .Select(s => new { Text = s, Words = countWords(s) })
    .ToList();

Console.WriteLine("텍스트 분석:");
foreach (var item in wordCounts)
{
    Console.WriteLine($"'{item.Text}' - {item.Words}단어");
}
// 출력:
// 텍스트 분석:
// 'hello world' - 2단어
// 'c# programming' - 2단어
// 'functional  programming' - 2단어
```

### 커스텀 고차 함수

```csharp
// 조건에 따라 다른 연산 수행
int ApplyIf(int value, bool condition, Func<int, int> transform)
{
    return condition ? transform(value) : value;
}

// 반복 적용
int ApplyTimes(int value, int times, Func<int, int> operation)
{
    int result = value;
    for (int i = 0; i < times; i++)
    {
        result = operation(result);
    }
    return result;
}

// 사용 예제
int num = 10;

var result1 = ApplyIf(num, num > 5, x => x * 2);
Console.WriteLine($"조건부 적용: {result1}");

var result2 = ApplyTimes(2, 4, x => x * 2);
Console.WriteLine($"4번 2배: {result2}");
// 출력:
// 조건부 적용: 20
// 4번 2배: 32
```

---

## 16.4 커링 (Currying)과 부분 적용

커링은 여러 개의 인자를 받는 함수를 단일 인자를 받는 함수들의 체인으로 변환하는 기법입니다. 부분 적용은 함수의 일부 인자를 미리 고정하여 새로운 함수를 만드는 기법입니다.

### 일반 함수 vs 커리된 함수

```csharp
// 일반 함수 - 모든 인자를 한 번에 받음
int Add3Numbers(int a, int b, int c)
{
    return a + b + c;
}

// 커리된 함수 - 한 번에 하나의 인자만 받음
Func<int, Func<int, Func<int, int>>> Add3NumbersCurried =
    a => b => c => a + b + c;

// 사용 예제
Console.WriteLine($"일반 함수: {Add3Numbers(1, 2, 3)}");
Console.WriteLine($"커리된 함수: {Add3NumbersCurried(1)(2)(3)}");
// 출력:
// 일반 함수: 6
// 커리된 함수: 6
```

### 부분 적용 (Partial Application)

```csharp
// 2개 인자를 받는 함수
int Multiply(int a, int b) => a * b;

// 부분 적용 - 첫 번째 인자를 고정
Func<int, int> MultiplyBy5(int b) => Multiply(5, b);
Func<int, int> MultiplyBy10(int b) => Multiply(10, b);

Console.WriteLine($"5 × 3 = {MultiplyBy5(3)}");
Console.WriteLine($"10 × 3 = {MultiplyBy10(3)}");
// 출력:
// 5 × 3 = 15
// 10 × 3 = 30
```

### 커링 헬퍼 함수

```csharp
// 2인자 함수를 커링
Func<T1, Func<T2, TResult>> Curry<T1, T2, TResult>(Func<T1, T2, TResult> func)
{
    return a => b => func(a, b);
}

// 3인자 함수를 커링
Func<T1, Func<T2, Func<T3, TResult>>> Curry<T1, T2, T3, TResult>(
    Func<T1, T2, T3, TResult> func)
{
    return a => b => c => func(a, b, c);
}

// 사용 예제
Func<int, int, int> add = (a, b) => a + b;
var curriedAdd = Curry(add);

var add5 = curriedAdd(5);
Console.WriteLine($"5 + 3 = {add5(3)}");
Console.WriteLine($"5 + 7 = {add5(7)}");
// 출력:
// 5 + 3 = 8
// 5 + 7 = 12
```

### 실용 예제 - 로깅 함수

```csharp
// 커리된 로깅 함수
Func<string, Func<string, Func<string, string>>> CreateLogger =
    prefix => level => message => $"[{prefix}] [{level}] {message}";

// 부분 적용으로 특화된 로거 생성
var appLogger = CreateLogger("APP");
var dbLogger = CreateLogger("DB");

var appInfo = appLogger("INFO");
var appError = appLogger("ERROR");
var dbInfo = dbLogger("INFO");

Console.WriteLine(appInfo("애플리케이션 시작"));
Console.WriteLine(appError("오류 발생"));
Console.WriteLine(dbInfo("데이터베이스 연결 성공"));
// 출력:
// [APP] [INFO] 애플리케이션 시작
// [APP] [ERROR] 오류 발생
// [DB] [INFO] 데이터베이스 연결 성공
```

### 실용 예제 - HTTP 요청 빌더

```csharp
// 커리된 HTTP 요청 설정
Func<string, Func<string, Func<string, string>>> BuildRequest =
    method => url => body => $"{method} {url}\nBody: {body}";

// 부분 적용으로 HTTP 메서드별 빌더 생성
var get = BuildRequest("GET");
var post = BuildRequest("POST");
var put = BuildRequest("PUT");

// URL별 빌더
var postToApi = post("/api/users");
var putToApi = put("/api/users");

Console.WriteLine(postToApi("{ \"name\": \"홍길동\" }"));
Console.WriteLine();
Console.WriteLine(putToApi("{ \"name\": \"김철수\" }"));
// 출력:
// POST /api/users
// Body: { "name": "홍길동" }
//
// PUT /api/users
// Body: { "name": "김철수" }
```

### 커링의 장점

```csharp
// 설정 함수들
Func<string, Func<int, Func<bool, string>>> ConfigureServer =
    host => port => ssl => $"Server: {host}:{port}, SSL: {ssl}";

// 단계별 설정
var localhost = ConfigureServer("localhost");
var localhostDev = localhost(3000);
var localhostProd = localhost(443);

Console.WriteLine(localhostDev(false));
Console.WriteLine(localhostProd(true));
// 출력:
// Server: localhost:3000, SSL: False
// Server: localhost:443, SSL: True
```

### 파이프라인과 커링

```csharp
// 커리된 문자열 처리 함수
Func<string, Func<string, string>> Prepend = prefix => text => prefix + text;
Func<string, Func<string, string>> Append = suffix => text => text + suffix;
Func<string, string> ToUpper = text => text.ToUpper();

// 부분 적용
var addHello = Prepend("Hello, ");
var addExclamation = Append("!");

// 함수 합성
string ProcessText(string text)
{
    return addExclamation(ToUpper(addHello(text)));
}

Console.WriteLine(ProcessText("world"));
// 출력: Hello, WORLD!
```

---

## 16장 정리 및 요약

이 장에서는 함수형 프로그래밍의 핵심 개념들을 C#로 구현하고 활용하는 방법을 학습했습니다.

### 핵심 개념 정리

1. **불변성 (Immutability)**
   - 데이터를 변경하지 않고 새로운 복사본 생성
   - C# `record` 타입과 `with` 식 활용
   - 스레드 안전성과 예측 가능성 향상
   - LINQ는 기본적으로 불변성을 따름

2. **순수 함수 (Pure Functions)**
   - 같은 입력에 항상 같은 출력 반환
   - 부작용이 없어 테스트와 디버깅이 쉬움
   - 외부 상태에 의존하지 않음
   - 함수 합성과 재사용이 용이

3. **고차 함수 (Higher-Order Functions)**
   - 함수를 인자로 받거나 반환
   - 코드의 추상화 수준 향상
   - LINQ 메서드들이 대표적인 예
   - 함수 합성을 통한 파이프라인 구축

4. **커링과 부분 적용**
   - 다인자 함수를 단일 인자 함수 체인으로 변환
   - 부분 적용으로 특화된 함수 생성
   - 설정과 파라미터화에 유용
   - 함수 재사용성 극대화

### 함수형 프로그래밍의 장점

- **예측 가능성**: 부작용이 없어 동작 예측이 쉬움
- **테스트 용이성**: 순수 함수는 단위 테스트가 간단함
- **병렬 처리**: 불변 데이터는 동시성 문제 없음
- **모듈화**: 작은 순수 함수들을 조합하여 복잡한 로직 구현
- **디버깅**: 상태 변경 추적이 불필요

### C#에서의 함수형 프로그래밍

C#은 객체지향과 함수형 프로그래밍을 모두 지원하는 다중 패러다임 언어입니다:
- `record` 타입으로 불변 객체 쉽게 생성
- 람다 식과 LINQ로 선언적 프로그래밍
- `Func`와 `Action`으로 고차 함수 구현
- 표현식 트리로 코드를 데이터로 다룸

### 실무 적용 팁

1. **LINQ 활용**: 컬렉션 처리는 LINQ로 선언적으로 작성
2. **불변 데이터**: 가능한 한 `record`와 불변 객체 사용
3. **순수 함수**: 비즈니스 로직은 순수 함수로 구현
4. **적절한 혼용**: 모든 코드를 함수형으로 작성할 필요는 없음
5. **성능 고려**: 성능이 중요한 부분은 명령형으로 작성

### 다음 단계

17장에서는 비동기 프로그래밍을 학습합니다. 함수형 프로그래밍의 개념들은 비동기 코드를 작성할 때도 유용하게 활용됩니다. 특히 순수 함수와 불변성은 동시성 프로그래밍에서 매우 중요한 역할을 합니다.

### 실습 문제

#### 문제 1: 불변 객체 구현

```csharp
// record를 사용하여 불변 객체 구현
record Product(string Name, decimal Price, int Quantity)
{
    // 가격 인상 메서드 (새 객체 반환)
    public Product IncreasePrice(decimal amount)
    {
        return this with { Price = Price + amount };
    }
    
    // 재고 추가 메서드 (새 객체 반환)
    public Product AddStock(int amount)
    {
        return this with { Quantity = Quantity + amount };
    }
}

// 테스트
var product = new Product("노트북", 1000000, 10);
var updated = product.IncreasePrice(100000).AddStock(5);

Console.WriteLine($"원본: {product.Name} - {product.Price:C}, 재고: {product.Quantity}");
Console.WriteLine($"변경: {updated.Name} - {updated.Price:C}, 재고: {updated.Quantity}");
```

#### 문제 2: 순수 함수로 데이터 처리

```csharp
record Order(int Id, string Customer, decimal Amount, string Status);

// 순수 함수들
bool IsLargeOrder(Order order) => order.Amount >= 100000;
bool IsCompleted(Order order) => order.Status == "완료";
string FormatOrder(Order order) => $"{order.Customer}: {order.Amount:C}";

// 데이터 처리
var orders = new List<Order>
{
    new(1, "홍길동", 150000, "완료"),
    new(2, "김철수", 50000, "대기"),
    new(3, "이영희", 200000, "완료"),
    new(4, "박민수", 80000, "완료")
};

// 완료된 대량 주문만 선택
var largeCompletedOrders = orders
    .Where(IsCompleted)
    .Where(IsLargeOrder)
    .Select(FormatOrder)
    .ToList();

Console.WriteLine("완료된 대량 주문:");
largeCompletedOrders.ForEach(Console.WriteLine);
```

#### 문제 3: 고차 함수 활용

```csharp
// 고차 함수: 변환 함수를 받아 리스트 처리
List<TResult> ProcessList<T, TResult>(
    List<T> items,
    Func<T, bool> filter,
    Func<T, TResult> transform)
{
    return items.Where(filter).Select(transform).ToList();
}

// 테스트
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

var evenSquares = ProcessList(
    numbers,
    n => n % 2 == 0,
    n => n * n
);

Console.WriteLine($"짝수의 제곱: {string.Join(", ", evenSquares)}");
```

#### 문제 4: 커링 적용

```csharp
// 커리된 할인 계산 함수
Func<decimal, Func<decimal, decimal>> ApplyDiscount =
    discountRate => price => price * (1 - discountRate);

// 특정 할인율 함수 생성
var tenPercentOff = ApplyDiscount(0.10m);
var twentyPercentOff = ApplyDiscount(0.20m);

Console.WriteLine($"10% 할인: {tenPercentOff(10000):C}");
Console.WriteLine($"20% 할인: {twentyPercentOff(10000):C}");
// 출력:
// 10% 할인: ₩9,000
// 20% 할인: ₩8,000
```

이러한 함수형 프로그래밍 개념들은 코드의 품질을 높이고, 버그를 줄이며, 유지보수를 쉽게 만듭니다. 실무에서 적절히 활용하면 더 안전하고 표현력 있는 코드를 작성할 수 있습니다!
